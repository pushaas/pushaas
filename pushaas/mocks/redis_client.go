// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/go-redis/redis"
	"sync"
	"time"
)

var (
	lockUniversalClientMockAppend                     sync.RWMutex
	lockUniversalClientMockBLPop                      sync.RWMutex
	lockUniversalClientMockBRPop                      sync.RWMutex
	lockUniversalClientMockBRPopLPush                 sync.RWMutex
	lockUniversalClientMockBZPopMax                   sync.RWMutex
	lockUniversalClientMockBZPopMin                   sync.RWMutex
	lockUniversalClientMockBgRewriteAOF               sync.RWMutex
	lockUniversalClientMockBgSave                     sync.RWMutex
	lockUniversalClientMockBitCount                   sync.RWMutex
	lockUniversalClientMockBitOpAnd                   sync.RWMutex
	lockUniversalClientMockBitOpNot                   sync.RWMutex
	lockUniversalClientMockBitOpOr                    sync.RWMutex
	lockUniversalClientMockBitOpXor                   sync.RWMutex
	lockUniversalClientMockBitPos                     sync.RWMutex
	lockUniversalClientMockClientGetName              sync.RWMutex
	lockUniversalClientMockClientID                   sync.RWMutex
	lockUniversalClientMockClientKill                 sync.RWMutex
	lockUniversalClientMockClientKillByFilter         sync.RWMutex
	lockUniversalClientMockClientList                 sync.RWMutex
	lockUniversalClientMockClientPause                sync.RWMutex
	lockUniversalClientMockClose                      sync.RWMutex
	lockUniversalClientMockClusterAddSlots            sync.RWMutex
	lockUniversalClientMockClusterAddSlotsRange       sync.RWMutex
	lockUniversalClientMockClusterCountFailureReports sync.RWMutex
	lockUniversalClientMockClusterCountKeysInSlot     sync.RWMutex
	lockUniversalClientMockClusterDelSlots            sync.RWMutex
	lockUniversalClientMockClusterDelSlotsRange       sync.RWMutex
	lockUniversalClientMockClusterFailover            sync.RWMutex
	lockUniversalClientMockClusterForget              sync.RWMutex
	lockUniversalClientMockClusterGetKeysInSlot       sync.RWMutex
	lockUniversalClientMockClusterInfo                sync.RWMutex
	lockUniversalClientMockClusterKeySlot             sync.RWMutex
	lockUniversalClientMockClusterMeet                sync.RWMutex
	lockUniversalClientMockClusterNodes               sync.RWMutex
	lockUniversalClientMockClusterReplicate           sync.RWMutex
	lockUniversalClientMockClusterResetHard           sync.RWMutex
	lockUniversalClientMockClusterResetSoft           sync.RWMutex
	lockUniversalClientMockClusterSaveConfig          sync.RWMutex
	lockUniversalClientMockClusterSlaves              sync.RWMutex
	lockUniversalClientMockClusterSlots               sync.RWMutex
	lockUniversalClientMockCommand                    sync.RWMutex
	lockUniversalClientMockConfigGet                  sync.RWMutex
	lockUniversalClientMockConfigResetStat            sync.RWMutex
	lockUniversalClientMockConfigRewrite              sync.RWMutex
	lockUniversalClientMockConfigSet                  sync.RWMutex
	lockUniversalClientMockDBSize                     sync.RWMutex
	lockUniversalClientMockDebugObject                sync.RWMutex
	lockUniversalClientMockDecr                       sync.RWMutex
	lockUniversalClientMockDecrBy                     sync.RWMutex
	lockUniversalClientMockDel                        sync.RWMutex
	lockUniversalClientMockDump                       sync.RWMutex
	lockUniversalClientMockEcho                       sync.RWMutex
	lockUniversalClientMockEval                       sync.RWMutex
	lockUniversalClientMockEvalSha                    sync.RWMutex
	lockUniversalClientMockExists                     sync.RWMutex
	lockUniversalClientMockExpire                     sync.RWMutex
	lockUniversalClientMockExpireAt                   sync.RWMutex
	lockUniversalClientMockFlushAll                   sync.RWMutex
	lockUniversalClientMockFlushAllAsync              sync.RWMutex
	lockUniversalClientMockFlushDB                    sync.RWMutex
	lockUniversalClientMockFlushDBAsync               sync.RWMutex
	lockUniversalClientMockGeoAdd                     sync.RWMutex
	lockUniversalClientMockGeoDist                    sync.RWMutex
	lockUniversalClientMockGeoHash                    sync.RWMutex
	lockUniversalClientMockGeoPos                     sync.RWMutex
	lockUniversalClientMockGeoRadius                  sync.RWMutex
	lockUniversalClientMockGeoRadiusByMember          sync.RWMutex
	lockUniversalClientMockGeoRadiusByMemberRO        sync.RWMutex
	lockUniversalClientMockGeoRadiusRO                sync.RWMutex
	lockUniversalClientMockGet                        sync.RWMutex
	lockUniversalClientMockGetBit                     sync.RWMutex
	lockUniversalClientMockGetRange                   sync.RWMutex
	lockUniversalClientMockGetSet                     sync.RWMutex
	lockUniversalClientMockHDel                       sync.RWMutex
	lockUniversalClientMockHExists                    sync.RWMutex
	lockUniversalClientMockHGet                       sync.RWMutex
	lockUniversalClientMockHGetAll                    sync.RWMutex
	lockUniversalClientMockHIncrBy                    sync.RWMutex
	lockUniversalClientMockHIncrByFloat               sync.RWMutex
	lockUniversalClientMockHKeys                      sync.RWMutex
	lockUniversalClientMockHLen                       sync.RWMutex
	lockUniversalClientMockHMGet                      sync.RWMutex
	lockUniversalClientMockHMSet                      sync.RWMutex
	lockUniversalClientMockHScan                      sync.RWMutex
	lockUniversalClientMockHSet                       sync.RWMutex
	lockUniversalClientMockHSetNX                     sync.RWMutex
	lockUniversalClientMockHVals                      sync.RWMutex
	lockUniversalClientMockIncr                       sync.RWMutex
	lockUniversalClientMockIncrBy                     sync.RWMutex
	lockUniversalClientMockIncrByFloat                sync.RWMutex
	lockUniversalClientMockInfo                       sync.RWMutex
	lockUniversalClientMockKeys                       sync.RWMutex
	lockUniversalClientMockLIndex                     sync.RWMutex
	lockUniversalClientMockLInsert                    sync.RWMutex
	lockUniversalClientMockLInsertAfter               sync.RWMutex
	lockUniversalClientMockLInsertBefore              sync.RWMutex
	lockUniversalClientMockLLen                       sync.RWMutex
	lockUniversalClientMockLPop                       sync.RWMutex
	lockUniversalClientMockLPush                      sync.RWMutex
	lockUniversalClientMockLPushX                     sync.RWMutex
	lockUniversalClientMockLRange                     sync.RWMutex
	lockUniversalClientMockLRem                       sync.RWMutex
	lockUniversalClientMockLSet                       sync.RWMutex
	lockUniversalClientMockLTrim                      sync.RWMutex
	lockUniversalClientMockLastSave                   sync.RWMutex
	lockUniversalClientMockMGet                       sync.RWMutex
	lockUniversalClientMockMSet                       sync.RWMutex
	lockUniversalClientMockMSetNX                     sync.RWMutex
	lockUniversalClientMockMemoryUsage                sync.RWMutex
	lockUniversalClientMockMigrate                    sync.RWMutex
	lockUniversalClientMockMove                       sync.RWMutex
	lockUniversalClientMockObjectEncoding             sync.RWMutex
	lockUniversalClientMockObjectIdleTime             sync.RWMutex
	lockUniversalClientMockObjectRefCount             sync.RWMutex
	lockUniversalClientMockPExpire                    sync.RWMutex
	lockUniversalClientMockPExpireAt                  sync.RWMutex
	lockUniversalClientMockPFAdd                      sync.RWMutex
	lockUniversalClientMockPFCount                    sync.RWMutex
	lockUniversalClientMockPFMerge                    sync.RWMutex
	lockUniversalClientMockPSubscribe                 sync.RWMutex
	lockUniversalClientMockPTTL                       sync.RWMutex
	lockUniversalClientMockPersist                    sync.RWMutex
	lockUniversalClientMockPing                       sync.RWMutex
	lockUniversalClientMockPipeline                   sync.RWMutex
	lockUniversalClientMockPipelined                  sync.RWMutex
	lockUniversalClientMockProcess                    sync.RWMutex
	lockUniversalClientMockPubSubChannels             sync.RWMutex
	lockUniversalClientMockPubSubNumPat               sync.RWMutex
	lockUniversalClientMockPubSubNumSub               sync.RWMutex
	lockUniversalClientMockPublish                    sync.RWMutex
	lockUniversalClientMockQuit                       sync.RWMutex
	lockUniversalClientMockRPop                       sync.RWMutex
	lockUniversalClientMockRPopLPush                  sync.RWMutex
	lockUniversalClientMockRPush                      sync.RWMutex
	lockUniversalClientMockRPushX                     sync.RWMutex
	lockUniversalClientMockRandomKey                  sync.RWMutex
	lockUniversalClientMockReadOnly                   sync.RWMutex
	lockUniversalClientMockReadWrite                  sync.RWMutex
	lockUniversalClientMockRename                     sync.RWMutex
	lockUniversalClientMockRenameNX                   sync.RWMutex
	lockUniversalClientMockRestore                    sync.RWMutex
	lockUniversalClientMockRestoreReplace             sync.RWMutex
	lockUniversalClientMockSAdd                       sync.RWMutex
	lockUniversalClientMockSCard                      sync.RWMutex
	lockUniversalClientMockSDiff                      sync.RWMutex
	lockUniversalClientMockSDiffStore                 sync.RWMutex
	lockUniversalClientMockSInter                     sync.RWMutex
	lockUniversalClientMockSInterStore                sync.RWMutex
	lockUniversalClientMockSIsMember                  sync.RWMutex
	lockUniversalClientMockSMembers                   sync.RWMutex
	lockUniversalClientMockSMembersMap                sync.RWMutex
	lockUniversalClientMockSMove                      sync.RWMutex
	lockUniversalClientMockSPop                       sync.RWMutex
	lockUniversalClientMockSPopN                      sync.RWMutex
	lockUniversalClientMockSRandMember                sync.RWMutex
	lockUniversalClientMockSRandMemberN               sync.RWMutex
	lockUniversalClientMockSRem                       sync.RWMutex
	lockUniversalClientMockSScan                      sync.RWMutex
	lockUniversalClientMockSUnion                     sync.RWMutex
	lockUniversalClientMockSUnionStore                sync.RWMutex
	lockUniversalClientMockSave                       sync.RWMutex
	lockUniversalClientMockScan                       sync.RWMutex
	lockUniversalClientMockScriptExists               sync.RWMutex
	lockUniversalClientMockScriptFlush                sync.RWMutex
	lockUniversalClientMockScriptKill                 sync.RWMutex
	lockUniversalClientMockScriptLoad                 sync.RWMutex
	lockUniversalClientMockSet                        sync.RWMutex
	lockUniversalClientMockSetBit                     sync.RWMutex
	lockUniversalClientMockSetNX                      sync.RWMutex
	lockUniversalClientMockSetRange                   sync.RWMutex
	lockUniversalClientMockSetXX                      sync.RWMutex
	lockUniversalClientMockShutdown                   sync.RWMutex
	lockUniversalClientMockShutdownNoSave             sync.RWMutex
	lockUniversalClientMockShutdownSave               sync.RWMutex
	lockUniversalClientMockSlaveOf                    sync.RWMutex
	lockUniversalClientMockSort                       sync.RWMutex
	lockUniversalClientMockSortInterfaces             sync.RWMutex
	lockUniversalClientMockSortStore                  sync.RWMutex
	lockUniversalClientMockStrLen                     sync.RWMutex
	lockUniversalClientMockSubscribe                  sync.RWMutex
	lockUniversalClientMockTTL                        sync.RWMutex
	lockUniversalClientMockTime                       sync.RWMutex
	lockUniversalClientMockTouch                      sync.RWMutex
	lockUniversalClientMockTxPipeline                 sync.RWMutex
	lockUniversalClientMockTxPipelined                sync.RWMutex
	lockUniversalClientMockType                       sync.RWMutex
	lockUniversalClientMockUnlink                     sync.RWMutex
	lockUniversalClientMockWatch                      sync.RWMutex
	lockUniversalClientMockWrapProcess                sync.RWMutex
	lockUniversalClientMockXAck                       sync.RWMutex
	lockUniversalClientMockXAdd                       sync.RWMutex
	lockUniversalClientMockXClaim                     sync.RWMutex
	lockUniversalClientMockXClaimJustID               sync.RWMutex
	lockUniversalClientMockXDel                       sync.RWMutex
	lockUniversalClientMockXGroupCreate               sync.RWMutex
	lockUniversalClientMockXGroupCreateMkStream       sync.RWMutex
	lockUniversalClientMockXGroupDelConsumer          sync.RWMutex
	lockUniversalClientMockXGroupDestroy              sync.RWMutex
	lockUniversalClientMockXGroupSetID                sync.RWMutex
	lockUniversalClientMockXLen                       sync.RWMutex
	lockUniversalClientMockXPending                   sync.RWMutex
	lockUniversalClientMockXPendingExt                sync.RWMutex
	lockUniversalClientMockXRange                     sync.RWMutex
	lockUniversalClientMockXRangeN                    sync.RWMutex
	lockUniversalClientMockXRead                      sync.RWMutex
	lockUniversalClientMockXReadGroup                 sync.RWMutex
	lockUniversalClientMockXReadStreams               sync.RWMutex
	lockUniversalClientMockXRevRange                  sync.RWMutex
	lockUniversalClientMockXRevRangeN                 sync.RWMutex
	lockUniversalClientMockXTrim                      sync.RWMutex
	lockUniversalClientMockXTrimApprox                sync.RWMutex
	lockUniversalClientMockZAdd                       sync.RWMutex
	lockUniversalClientMockZAddCh                     sync.RWMutex
	lockUniversalClientMockZAddNX                     sync.RWMutex
	lockUniversalClientMockZAddNXCh                   sync.RWMutex
	lockUniversalClientMockZAddXX                     sync.RWMutex
	lockUniversalClientMockZAddXXCh                   sync.RWMutex
	lockUniversalClientMockZCard                      sync.RWMutex
	lockUniversalClientMockZCount                     sync.RWMutex
	lockUniversalClientMockZIncr                      sync.RWMutex
	lockUniversalClientMockZIncrBy                    sync.RWMutex
	lockUniversalClientMockZIncrNX                    sync.RWMutex
	lockUniversalClientMockZIncrXX                    sync.RWMutex
	lockUniversalClientMockZInterStore                sync.RWMutex
	lockUniversalClientMockZLexCount                  sync.RWMutex
	lockUniversalClientMockZPopMax                    sync.RWMutex
	lockUniversalClientMockZPopMin                    sync.RWMutex
	lockUniversalClientMockZRange                     sync.RWMutex
	lockUniversalClientMockZRangeByLex                sync.RWMutex
	lockUniversalClientMockZRangeByScore              sync.RWMutex
	lockUniversalClientMockZRangeByScoreWithScores    sync.RWMutex
	lockUniversalClientMockZRangeWithScores           sync.RWMutex
	lockUniversalClientMockZRank                      sync.RWMutex
	lockUniversalClientMockZRem                       sync.RWMutex
	lockUniversalClientMockZRemRangeByLex             sync.RWMutex
	lockUniversalClientMockZRemRangeByRank            sync.RWMutex
	lockUniversalClientMockZRemRangeByScore           sync.RWMutex
	lockUniversalClientMockZRevRange                  sync.RWMutex
	lockUniversalClientMockZRevRangeByLex             sync.RWMutex
	lockUniversalClientMockZRevRangeByScore           sync.RWMutex
	lockUniversalClientMockZRevRangeByScoreWithScores sync.RWMutex
	lockUniversalClientMockZRevRangeWithScores        sync.RWMutex
	lockUniversalClientMockZRevRank                   sync.RWMutex
	lockUniversalClientMockZScan                      sync.RWMutex
	lockUniversalClientMockZScore                     sync.RWMutex
	lockUniversalClientMockZUnionStore                sync.RWMutex
)

// Ensure, that UniversalClientMock does implement UniversalClient.
// If this is not the case, regenerate this file with moq.
var _ redis.UniversalClient = &UniversalClientMock{}

// UniversalClientMock is a mock implementation of UniversalClient.
//
//     func TestSomethingThatUsesUniversalClient(t *testing.T) {
//
//         // make and configure a mocked UniversalClient
//         mockedUniversalClient := &UniversalClientMock{
//             AppendFunc: func(key string, value string) *redis.IntCmd {
// 	               panic("mock out the Append method")
//             },
//             BLPopFunc: func(timeout time.Duration, keys ...string) *redis.StringSliceCmd {
// 	               panic("mock out the BLPop method")
//             },
//             BRPopFunc: func(timeout time.Duration, keys ...string) *redis.StringSliceCmd {
// 	               panic("mock out the BRPop method")
//             },
//             BRPopLPushFunc: func(source string, destination string, timeout time.Duration) *redis.StringCmd {
// 	               panic("mock out the BRPopLPush method")
//             },
//             BZPopMaxFunc: func(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
// 	               panic("mock out the BZPopMax method")
//             },
//             BZPopMinFunc: func(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
// 	               panic("mock out the BZPopMin method")
//             },
//             BgRewriteAOFFunc: func() *redis.StatusCmd {
// 	               panic("mock out the BgRewriteAOF method")
//             },
//             BgSaveFunc: func() *redis.StatusCmd {
// 	               panic("mock out the BgSave method")
//             },
//             BitCountFunc: func(key string, bitCount *redis.BitCount) *redis.IntCmd {
// 	               panic("mock out the BitCount method")
//             },
//             BitOpAndFunc: func(destKey string, keys ...string) *redis.IntCmd {
// 	               panic("mock out the BitOpAnd method")
//             },
//             BitOpNotFunc: func(destKey string, key string) *redis.IntCmd {
// 	               panic("mock out the BitOpNot method")
//             },
//             BitOpOrFunc: func(destKey string, keys ...string) *redis.IntCmd {
// 	               panic("mock out the BitOpOr method")
//             },
//             BitOpXorFunc: func(destKey string, keys ...string) *redis.IntCmd {
// 	               panic("mock out the BitOpXor method")
//             },
//             BitPosFunc: func(key string, bit int64, pos ...int64) *redis.IntCmd {
// 	               panic("mock out the BitPos method")
//             },
//             ClientGetNameFunc: func() *redis.StringCmd {
// 	               panic("mock out the ClientGetName method")
//             },
//             ClientIDFunc: func() *redis.IntCmd {
// 	               panic("mock out the ClientID method")
//             },
//             ClientKillFunc: func(ipPort string) *redis.StatusCmd {
// 	               panic("mock out the ClientKill method")
//             },
//             ClientKillByFilterFunc: func(keys ...string) *redis.IntCmd {
// 	               panic("mock out the ClientKillByFilter method")
//             },
//             ClientListFunc: func() *redis.StringCmd {
// 	               panic("mock out the ClientList method")
//             },
//             ClientPauseFunc: func(dur time.Duration) *redis.BoolCmd {
// 	               panic("mock out the ClientPause method")
//             },
//             CloseFunc: func() error {
// 	               panic("mock out the Close method")
//             },
//             ClusterAddSlotsFunc: func(slots ...int) *redis.StatusCmd {
// 	               panic("mock out the ClusterAddSlots method")
//             },
//             ClusterAddSlotsRangeFunc: func(min int, max int) *redis.StatusCmd {
// 	               panic("mock out the ClusterAddSlotsRange method")
//             },
//             ClusterCountFailureReportsFunc: func(nodeID string) *redis.IntCmd {
// 	               panic("mock out the ClusterCountFailureReports method")
//             },
//             ClusterCountKeysInSlotFunc: func(slot int) *redis.IntCmd {
// 	               panic("mock out the ClusterCountKeysInSlot method")
//             },
//             ClusterDelSlotsFunc: func(slots ...int) *redis.StatusCmd {
// 	               panic("mock out the ClusterDelSlots method")
//             },
//             ClusterDelSlotsRangeFunc: func(min int, max int) *redis.StatusCmd {
// 	               panic("mock out the ClusterDelSlotsRange method")
//             },
//             ClusterFailoverFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ClusterFailover method")
//             },
//             ClusterForgetFunc: func(nodeID string) *redis.StatusCmd {
// 	               panic("mock out the ClusterForget method")
//             },
//             ClusterGetKeysInSlotFunc: func(slot int, count int) *redis.StringSliceCmd {
// 	               panic("mock out the ClusterGetKeysInSlot method")
//             },
//             ClusterInfoFunc: func() *redis.StringCmd {
// 	               panic("mock out the ClusterInfo method")
//             },
//             ClusterKeySlotFunc: func(key string) *redis.IntCmd {
// 	               panic("mock out the ClusterKeySlot method")
//             },
//             ClusterMeetFunc: func(host string, port string) *redis.StatusCmd {
// 	               panic("mock out the ClusterMeet method")
//             },
//             ClusterNodesFunc: func() *redis.StringCmd {
// 	               panic("mock out the ClusterNodes method")
//             },
//             ClusterReplicateFunc: func(nodeID string) *redis.StatusCmd {
// 	               panic("mock out the ClusterReplicate method")
//             },
//             ClusterResetHardFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ClusterResetHard method")
//             },
//             ClusterResetSoftFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ClusterResetSoft method")
//             },
//             ClusterSaveConfigFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ClusterSaveConfig method")
//             },
//             ClusterSlavesFunc: func(nodeID string) *redis.StringSliceCmd {
// 	               panic("mock out the ClusterSlaves method")
//             },
//             ClusterSlotsFunc: func() *redis.ClusterSlotsCmd {
// 	               panic("mock out the ClusterSlots method")
//             },
//             CommandFunc: func() *redis.CommandsInfoCmd {
// 	               panic("mock out the Command method")
//             },
//             ConfigGetFunc: func(parameter string) *redis.SliceCmd {
// 	               panic("mock out the ConfigGet method")
//             },
//             ConfigResetStatFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ConfigResetStat method")
//             },
//             ConfigRewriteFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ConfigRewrite method")
//             },
//             ConfigSetFunc: func(parameter string, value string) *redis.StatusCmd {
// 	               panic("mock out the ConfigSet method")
//             },
//             DBSizeFunc: func() *redis.IntCmd {
// 	               panic("mock out the DBSize method")
//             },
//             DebugObjectFunc: func(key string) *redis.StringCmd {
// 	               panic("mock out the DebugObject method")
//             },
//             DecrFunc: func(key string) *redis.IntCmd {
// 	               panic("mock out the Decr method")
//             },
//             DecrByFunc: func(key string, decrement int64) *redis.IntCmd {
// 	               panic("mock out the DecrBy method")
//             },
//             DelFunc: func(keys ...string) *redis.IntCmd {
// 	               panic("mock out the Del method")
//             },
//             DumpFunc: func(key string) *redis.StringCmd {
// 	               panic("mock out the Dump method")
//             },
//             EchoFunc: func(message interface{}) *redis.StringCmd {
// 	               panic("mock out the Echo method")
//             },
//             EvalFunc: func(script string, keys []string, args ...interface{}) *redis.Cmd {
// 	               panic("mock out the Eval method")
//             },
//             EvalShaFunc: func(sha1 string, keys []string, args ...interface{}) *redis.Cmd {
// 	               panic("mock out the EvalSha method")
//             },
//             ExistsFunc: func(keys ...string) *redis.IntCmd {
// 	               panic("mock out the Exists method")
//             },
//             ExpireFunc: func(key string, expiration time.Duration) *redis.BoolCmd {
// 	               panic("mock out the Expire method")
//             },
//             ExpireAtFunc: func(key string, tm time.Time) *redis.BoolCmd {
// 	               panic("mock out the ExpireAt method")
//             },
//             FlushAllFunc: func() *redis.StatusCmd {
// 	               panic("mock out the FlushAll method")
//             },
//             FlushAllAsyncFunc: func() *redis.StatusCmd {
// 	               panic("mock out the FlushAllAsync method")
//             },
//             FlushDBFunc: func() *redis.StatusCmd {
// 	               panic("mock out the FlushDB method")
//             },
//             FlushDBAsyncFunc: func() *redis.StatusCmd {
// 	               panic("mock out the FlushDBAsync method")
//             },
//             GeoAddFunc: func(key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
// 	               panic("mock out the GeoAdd method")
//             },
//             GeoDistFunc: func(key string, member1 string, member2 string, unit string) *redis.FloatCmd {
// 	               panic("mock out the GeoDist method")
//             },
//             GeoHashFunc: func(key string, members ...string) *redis.StringSliceCmd {
// 	               panic("mock out the GeoHash method")
//             },
//             GeoPosFunc: func(key string, members ...string) *redis.GeoPosCmd {
// 	               panic("mock out the GeoPos method")
//             },
//             GeoRadiusFunc: func(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
// 	               panic("mock out the GeoRadius method")
//             },
//             GeoRadiusByMemberFunc: func(key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
// 	               panic("mock out the GeoRadiusByMember method")
//             },
//             GeoRadiusByMemberROFunc: func(key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
// 	               panic("mock out the GeoRadiusByMemberRO method")
//             },
//             GeoRadiusROFunc: func(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
// 	               panic("mock out the GeoRadiusRO method")
//             },
//             GetFunc: func(key string) *redis.StringCmd {
// 	               panic("mock out the Get method")
//             },
//             GetBitFunc: func(key string, offset int64) *redis.IntCmd {
// 	               panic("mock out the GetBit method")
//             },
//             GetRangeFunc: func(key string, start int64, end int64) *redis.StringCmd {
// 	               panic("mock out the GetRange method")
//             },
//             GetSetFunc: func(key string, value interface{}) *redis.StringCmd {
// 	               panic("mock out the GetSet method")
//             },
//             HDelFunc: func(key string, fields ...string) *redis.IntCmd {
// 	               panic("mock out the HDel method")
//             },
//             HExistsFunc: func(key string, field string) *redis.BoolCmd {
// 	               panic("mock out the HExists method")
//             },
//             HGetFunc: func(key string, field string) *redis.StringCmd {
// 	               panic("mock out the HGet method")
//             },
//             HGetAllFunc: func(key string) *redis.StringStringMapCmd {
// 	               panic("mock out the HGetAll method")
//             },
//             HIncrByFunc: func(key string, field string, incr int64) *redis.IntCmd {
// 	               panic("mock out the HIncrBy method")
//             },
//             HIncrByFloatFunc: func(key string, field string, incr float64) *redis.FloatCmd {
// 	               panic("mock out the HIncrByFloat method")
//             },
//             HKeysFunc: func(key string) *redis.StringSliceCmd {
// 	               panic("mock out the HKeys method")
//             },
//             HLenFunc: func(key string) *redis.IntCmd {
// 	               panic("mock out the HLen method")
//             },
//             HMGetFunc: func(key string, fields ...string) *redis.SliceCmd {
// 	               panic("mock out the HMGet method")
//             },
//             HMSetFunc: func(key string, fields map[string]interface{}) *redis.StatusCmd {
// 	               panic("mock out the HMSet method")
//             },
//             HScanFunc: func(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
// 	               panic("mock out the HScan method")
//             },
//             HSetFunc: func(key string, field string, value interface{}) *redis.BoolCmd {
// 	               panic("mock out the HSet method")
//             },
//             HSetNXFunc: func(key string, field string, value interface{}) *redis.BoolCmd {
// 	               panic("mock out the HSetNX method")
//             },
//             HValsFunc: func(key string) *redis.StringSliceCmd {
// 	               panic("mock out the HVals method")
//             },
//             IncrFunc: func(key string) *redis.IntCmd {
// 	               panic("mock out the Incr method")
//             },
//             IncrByFunc: func(key string, value int64) *redis.IntCmd {
// 	               panic("mock out the IncrBy method")
//             },
//             IncrByFloatFunc: func(key string, value float64) *redis.FloatCmd {
// 	               panic("mock out the IncrByFloat method")
//             },
//             InfoFunc: func(section ...string) *redis.StringCmd {
// 	               panic("mock out the Info method")
//             },
//             KeysFunc: func(pattern string) *redis.StringSliceCmd {
// 	               panic("mock out the Keys method")
//             },
//             LIndexFunc: func(key string, index int64) *redis.StringCmd {
// 	               panic("mock out the LIndex method")
//             },
//             LInsertFunc: func(key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
// 	               panic("mock out the LInsert method")
//             },
//             LInsertAfterFunc: func(key string, pivot interface{}, value interface{}) *redis.IntCmd {
// 	               panic("mock out the LInsertAfter method")
//             },
//             LInsertBeforeFunc: func(key string, pivot interface{}, value interface{}) *redis.IntCmd {
// 	               panic("mock out the LInsertBefore method")
//             },
//             LLenFunc: func(key string) *redis.IntCmd {
// 	               panic("mock out the LLen method")
//             },
//             LPopFunc: func(key string) *redis.StringCmd {
// 	               panic("mock out the LPop method")
//             },
//             LPushFunc: func(key string, values ...interface{}) *redis.IntCmd {
// 	               panic("mock out the LPush method")
//             },
//             LPushXFunc: func(key string, value interface{}) *redis.IntCmd {
// 	               panic("mock out the LPushX method")
//             },
//             LRangeFunc: func(key string, start int64, stop int64) *redis.StringSliceCmd {
// 	               panic("mock out the LRange method")
//             },
//             LRemFunc: func(key string, count int64, value interface{}) *redis.IntCmd {
// 	               panic("mock out the LRem method")
//             },
//             LSetFunc: func(key string, index int64, value interface{}) *redis.StatusCmd {
// 	               panic("mock out the LSet method")
//             },
//             LTrimFunc: func(key string, start int64, stop int64) *redis.StatusCmd {
// 	               panic("mock out the LTrim method")
//             },
//             LastSaveFunc: func() *redis.IntCmd {
// 	               panic("mock out the LastSave method")
//             },
//             MGetFunc: func(keys ...string) *redis.SliceCmd {
// 	               panic("mock out the MGet method")
//             },
//             MSetFunc: func(pairs ...interface{}) *redis.StatusCmd {
// 	               panic("mock out the MSet method")
//             },
//             MSetNXFunc: func(pairs ...interface{}) *redis.BoolCmd {
// 	               panic("mock out the MSetNX method")
//             },
//             MemoryUsageFunc: func(key string, samples ...int) *redis.IntCmd {
// 	               panic("mock out the MemoryUsage method")
//             },
//             MigrateFunc: func(host string, port string, key string, db int64, timeout time.Duration) *redis.StatusCmd {
// 	               panic("mock out the Migrate method")
//             },
//             MoveFunc: func(key string, db int64) *redis.BoolCmd {
// 	               panic("mock out the Move method")
//             },
//             ObjectEncodingFunc: func(key string) *redis.StringCmd {
// 	               panic("mock out the ObjectEncoding method")
//             },
//             ObjectIdleTimeFunc: func(key string) *redis.DurationCmd {
// 	               panic("mock out the ObjectIdleTime method")
//             },
//             ObjectRefCountFunc: func(key string) *redis.IntCmd {
// 	               panic("mock out the ObjectRefCount method")
//             },
//             PExpireFunc: func(key string, expiration time.Duration) *redis.BoolCmd {
// 	               panic("mock out the PExpire method")
//             },
//             PExpireAtFunc: func(key string, tm time.Time) *redis.BoolCmd {
// 	               panic("mock out the PExpireAt method")
//             },
//             PFAddFunc: func(key string, els ...interface{}) *redis.IntCmd {
// 	               panic("mock out the PFAdd method")
//             },
//             PFCountFunc: func(keys ...string) *redis.IntCmd {
// 	               panic("mock out the PFCount method")
//             },
//             PFMergeFunc: func(dest string, keys ...string) *redis.StatusCmd {
// 	               panic("mock out the PFMerge method")
//             },
//             PSubscribeFunc: func(channels ...string) *redis.PubSub {
// 	               panic("mock out the PSubscribe method")
//             },
//             PTTLFunc: func(key string) *redis.DurationCmd {
// 	               panic("mock out the PTTL method")
//             },
//             PersistFunc: func(key string) *redis.BoolCmd {
// 	               panic("mock out the Persist method")
//             },
//             PingFunc: func() *redis.StatusCmd {
// 	               panic("mock out the Ping method")
//             },
//             PipelineFunc: func() redis.Pipeliner {
// 	               panic("mock out the Pipeline method")
//             },
//             PipelinedFunc: func(fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
// 	               panic("mock out the Pipelined method")
//             },
//             ProcessFunc: func(cmd redis.Cmder) error {
// 	               panic("mock out the Process method")
//             },
//             PubSubChannelsFunc: func(pattern string) *redis.StringSliceCmd {
// 	               panic("mock out the PubSubChannels method")
//             },
//             PubSubNumPatFunc: func() *redis.IntCmd {
// 	               panic("mock out the PubSubNumPat method")
//             },
//             PubSubNumSubFunc: func(channels ...string) *redis.StringIntMapCmd {
// 	               panic("mock out the PubSubNumSub method")
//             },
//             PublishFunc: func(channel string, message interface{}) *redis.IntCmd {
// 	               panic("mock out the Publish method")
//             },
//             QuitFunc: func() *redis.StatusCmd {
// 	               panic("mock out the Quit method")
//             },
//             RPopFunc: func(key string) *redis.StringCmd {
// 	               panic("mock out the RPop method")
//             },
//             RPopLPushFunc: func(source string, destination string) *redis.StringCmd {
// 	               panic("mock out the RPopLPush method")
//             },
//             RPushFunc: func(key string, values ...interface{}) *redis.IntCmd {
// 	               panic("mock out the RPush method")
//             },
//             RPushXFunc: func(key string, value interface{}) *redis.IntCmd {
// 	               panic("mock out the RPushX method")
//             },
//             RandomKeyFunc: func() *redis.StringCmd {
// 	               panic("mock out the RandomKey method")
//             },
//             ReadOnlyFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ReadOnly method")
//             },
//             ReadWriteFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ReadWrite method")
//             },
//             RenameFunc: func(key string, newkey string) *redis.StatusCmd {
// 	               panic("mock out the Rename method")
//             },
//             RenameNXFunc: func(key string, newkey string) *redis.BoolCmd {
// 	               panic("mock out the RenameNX method")
//             },
//             RestoreFunc: func(key string, ttl time.Duration, value string) *redis.StatusCmd {
// 	               panic("mock out the Restore method")
//             },
//             RestoreReplaceFunc: func(key string, ttl time.Duration, value string) *redis.StatusCmd {
// 	               panic("mock out the RestoreReplace method")
//             },
//             SAddFunc: func(key string, members ...interface{}) *redis.IntCmd {
// 	               panic("mock out the SAdd method")
//             },
//             SCardFunc: func(key string) *redis.IntCmd {
// 	               panic("mock out the SCard method")
//             },
//             SDiffFunc: func(keys ...string) *redis.StringSliceCmd {
// 	               panic("mock out the SDiff method")
//             },
//             SDiffStoreFunc: func(destination string, keys ...string) *redis.IntCmd {
// 	               panic("mock out the SDiffStore method")
//             },
//             SInterFunc: func(keys ...string) *redis.StringSliceCmd {
// 	               panic("mock out the SInter method")
//             },
//             SInterStoreFunc: func(destination string, keys ...string) *redis.IntCmd {
// 	               panic("mock out the SInterStore method")
//             },
//             SIsMemberFunc: func(key string, member interface{}) *redis.BoolCmd {
// 	               panic("mock out the SIsMember method")
//             },
//             SMembersFunc: func(key string) *redis.StringSliceCmd {
// 	               panic("mock out the SMembers method")
//             },
//             SMembersMapFunc: func(key string) *redis.StringStructMapCmd {
// 	               panic("mock out the SMembersMap method")
//             },
//             SMoveFunc: func(source string, destination string, member interface{}) *redis.BoolCmd {
// 	               panic("mock out the SMove method")
//             },
//             SPopFunc: func(key string) *redis.StringCmd {
// 	               panic("mock out the SPop method")
//             },
//             SPopNFunc: func(key string, count int64) *redis.StringSliceCmd {
// 	               panic("mock out the SPopN method")
//             },
//             SRandMemberFunc: func(key string) *redis.StringCmd {
// 	               panic("mock out the SRandMember method")
//             },
//             SRandMemberNFunc: func(key string, count int64) *redis.StringSliceCmd {
// 	               panic("mock out the SRandMemberN method")
//             },
//             SRemFunc: func(key string, members ...interface{}) *redis.IntCmd {
// 	               panic("mock out the SRem method")
//             },
//             SScanFunc: func(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
// 	               panic("mock out the SScan method")
//             },
//             SUnionFunc: func(keys ...string) *redis.StringSliceCmd {
// 	               panic("mock out the SUnion method")
//             },
//             SUnionStoreFunc: func(destination string, keys ...string) *redis.IntCmd {
// 	               panic("mock out the SUnionStore method")
//             },
//             SaveFunc: func() *redis.StatusCmd {
// 	               panic("mock out the Save method")
//             },
//             ScanFunc: func(cursor uint64, match string, count int64) *redis.ScanCmd {
// 	               panic("mock out the Scan method")
//             },
//             ScriptExistsFunc: func(hashes ...string) *redis.BoolSliceCmd {
// 	               panic("mock out the ScriptExists method")
//             },
//             ScriptFlushFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ScriptFlush method")
//             },
//             ScriptKillFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ScriptKill method")
//             },
//             ScriptLoadFunc: func(script string) *redis.StringCmd {
// 	               panic("mock out the ScriptLoad method")
//             },
//             SetFunc: func(key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
// 	               panic("mock out the Set method")
//             },
//             SetBitFunc: func(key string, offset int64, value int) *redis.IntCmd {
// 	               panic("mock out the SetBit method")
//             },
//             SetNXFunc: func(key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
// 	               panic("mock out the SetNX method")
//             },
//             SetRangeFunc: func(key string, offset int64, value string) *redis.IntCmd {
// 	               panic("mock out the SetRange method")
//             },
//             SetXXFunc: func(key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
// 	               panic("mock out the SetXX method")
//             },
//             ShutdownFunc: func() *redis.StatusCmd {
// 	               panic("mock out the Shutdown method")
//             },
//             ShutdownNoSaveFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ShutdownNoSave method")
//             },
//             ShutdownSaveFunc: func() *redis.StatusCmd {
// 	               panic("mock out the ShutdownSave method")
//             },
//             SlaveOfFunc: func(host string, port string) *redis.StatusCmd {
// 	               panic("mock out the SlaveOf method")
//             },
//             SortFunc: func(key string, sort *redis.Sort) *redis.StringSliceCmd {
// 	               panic("mock out the Sort method")
//             },
//             SortInterfacesFunc: func(key string, sort *redis.Sort) *redis.SliceCmd {
// 	               panic("mock out the SortInterfaces method")
//             },
//             SortStoreFunc: func(key string, store string, sort *redis.Sort) *redis.IntCmd {
// 	               panic("mock out the SortStore method")
//             },
//             StrLenFunc: func(key string) *redis.IntCmd {
// 	               panic("mock out the StrLen method")
//             },
//             SubscribeFunc: func(channels ...string) *redis.PubSub {
// 	               panic("mock out the Subscribe method")
//             },
//             TTLFunc: func(key string) *redis.DurationCmd {
// 	               panic("mock out the TTL method")
//             },
//             TimeFunc: func() *redis.TimeCmd {
// 	               panic("mock out the Time method")
//             },
//             TouchFunc: func(keys ...string) *redis.IntCmd {
// 	               panic("mock out the Touch method")
//             },
//             TxPipelineFunc: func() redis.Pipeliner {
// 	               panic("mock out the TxPipeline method")
//             },
//             TxPipelinedFunc: func(fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
// 	               panic("mock out the TxPipelined method")
//             },
//             TypeFunc: func(key string) *redis.StatusCmd {
// 	               panic("mock out the Type method")
//             },
//             UnlinkFunc: func(keys ...string) *redis.IntCmd {
// 	               panic("mock out the Unlink method")
//             },
//             WatchFunc: func(fn func(*redis.Tx) error, keys ...string) error {
// 	               panic("mock out the Watch method")
//             },
//             WrapProcessFunc: func(fn func(oldProcess func(cmd redis.Cmder) error) func(cmd redis.Cmder) error)  {
// 	               panic("mock out the WrapProcess method")
//             },
//             XAckFunc: func(stream string, group string, ids ...string) *redis.IntCmd {
// 	               panic("mock out the XAck method")
//             },
//             XAddFunc: func(a *redis.XAddArgs) *redis.StringCmd {
// 	               panic("mock out the XAdd method")
//             },
//             XClaimFunc: func(a *redis.XClaimArgs) *redis.XMessageSliceCmd {
// 	               panic("mock out the XClaim method")
//             },
//             XClaimJustIDFunc: func(a *redis.XClaimArgs) *redis.StringSliceCmd {
// 	               panic("mock out the XClaimJustID method")
//             },
//             XDelFunc: func(stream string, ids ...string) *redis.IntCmd {
// 	               panic("mock out the XDel method")
//             },
//             XGroupCreateFunc: func(stream string, group string, start string) *redis.StatusCmd {
// 	               panic("mock out the XGroupCreate method")
//             },
//             XGroupCreateMkStreamFunc: func(stream string, group string, start string) *redis.StatusCmd {
// 	               panic("mock out the XGroupCreateMkStream method")
//             },
//             XGroupDelConsumerFunc: func(stream string, group string, consumer string) *redis.IntCmd {
// 	               panic("mock out the XGroupDelConsumer method")
//             },
//             XGroupDestroyFunc: func(stream string, group string) *redis.IntCmd {
// 	               panic("mock out the XGroupDestroy method")
//             },
//             XGroupSetIDFunc: func(stream string, group string, start string) *redis.StatusCmd {
// 	               panic("mock out the XGroupSetID method")
//             },
//             XLenFunc: func(stream string) *redis.IntCmd {
// 	               panic("mock out the XLen method")
//             },
//             XPendingFunc: func(stream string, group string) *redis.XPendingCmd {
// 	               panic("mock out the XPending method")
//             },
//             XPendingExtFunc: func(a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
// 	               panic("mock out the XPendingExt method")
//             },
//             XRangeFunc: func(stream string, start string, stop string) *redis.XMessageSliceCmd {
// 	               panic("mock out the XRange method")
//             },
//             XRangeNFunc: func(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
// 	               panic("mock out the XRangeN method")
//             },
//             XReadFunc: func(a *redis.XReadArgs) *redis.XStreamSliceCmd {
// 	               panic("mock out the XRead method")
//             },
//             XReadGroupFunc: func(a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
// 	               panic("mock out the XReadGroup method")
//             },
//             XReadStreamsFunc: func(streams ...string) *redis.XStreamSliceCmd {
// 	               panic("mock out the XReadStreams method")
//             },
//             XRevRangeFunc: func(stream string, start string, stop string) *redis.XMessageSliceCmd {
// 	               panic("mock out the XRevRange method")
//             },
//             XRevRangeNFunc: func(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
// 	               panic("mock out the XRevRangeN method")
//             },
//             XTrimFunc: func(key string, maxLen int64) *redis.IntCmd {
// 	               panic("mock out the XTrim method")
//             },
//             XTrimApproxFunc: func(key string, maxLen int64) *redis.IntCmd {
// 	               panic("mock out the XTrimApprox method")
//             },
//             ZAddFunc: func(key string, members ...redis.Z) *redis.IntCmd {
// 	               panic("mock out the ZAdd method")
//             },
//             ZAddChFunc: func(key string, members ...redis.Z) *redis.IntCmd {
// 	               panic("mock out the ZAddCh method")
//             },
//             ZAddNXFunc: func(key string, members ...redis.Z) *redis.IntCmd {
// 	               panic("mock out the ZAddNX method")
//             },
//             ZAddNXChFunc: func(key string, members ...redis.Z) *redis.IntCmd {
// 	               panic("mock out the ZAddNXCh method")
//             },
//             ZAddXXFunc: func(key string, members ...redis.Z) *redis.IntCmd {
// 	               panic("mock out the ZAddXX method")
//             },
//             ZAddXXChFunc: func(key string, members ...redis.Z) *redis.IntCmd {
// 	               panic("mock out the ZAddXXCh method")
//             },
//             ZCardFunc: func(key string) *redis.IntCmd {
// 	               panic("mock out the ZCard method")
//             },
//             ZCountFunc: func(key string, min string, max string) *redis.IntCmd {
// 	               panic("mock out the ZCount method")
//             },
//             ZIncrFunc: func(key string, member redis.Z) *redis.FloatCmd {
// 	               panic("mock out the ZIncr method")
//             },
//             ZIncrByFunc: func(key string, increment float64, member string) *redis.FloatCmd {
// 	               panic("mock out the ZIncrBy method")
//             },
//             ZIncrNXFunc: func(key string, member redis.Z) *redis.FloatCmd {
// 	               panic("mock out the ZIncrNX method")
//             },
//             ZIncrXXFunc: func(key string, member redis.Z) *redis.FloatCmd {
// 	               panic("mock out the ZIncrXX method")
//             },
//             ZInterStoreFunc: func(destination string, store redis.ZStore, keys ...string) *redis.IntCmd {
// 	               panic("mock out the ZInterStore method")
//             },
//             ZLexCountFunc: func(key string, min string, max string) *redis.IntCmd {
// 	               panic("mock out the ZLexCount method")
//             },
//             ZPopMaxFunc: func(key string, count ...int64) *redis.ZSliceCmd {
// 	               panic("mock out the ZPopMax method")
//             },
//             ZPopMinFunc: func(key string, count ...int64) *redis.ZSliceCmd {
// 	               panic("mock out the ZPopMin method")
//             },
//             ZRangeFunc: func(key string, start int64, stop int64) *redis.StringSliceCmd {
// 	               panic("mock out the ZRange method")
//             },
//             ZRangeByLexFunc: func(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
// 	               panic("mock out the ZRangeByLex method")
//             },
//             ZRangeByScoreFunc: func(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
// 	               panic("mock out the ZRangeByScore method")
//             },
//             ZRangeByScoreWithScoresFunc: func(key string, opt redis.ZRangeBy) *redis.ZSliceCmd {
// 	               panic("mock out the ZRangeByScoreWithScores method")
//             },
//             ZRangeWithScoresFunc: func(key string, start int64, stop int64) *redis.ZSliceCmd {
// 	               panic("mock out the ZRangeWithScores method")
//             },
//             ZRankFunc: func(key string, member string) *redis.IntCmd {
// 	               panic("mock out the ZRank method")
//             },
//             ZRemFunc: func(key string, members ...interface{}) *redis.IntCmd {
// 	               panic("mock out the ZRem method")
//             },
//             ZRemRangeByLexFunc: func(key string, min string, max string) *redis.IntCmd {
// 	               panic("mock out the ZRemRangeByLex method")
//             },
//             ZRemRangeByRankFunc: func(key string, start int64, stop int64) *redis.IntCmd {
// 	               panic("mock out the ZRemRangeByRank method")
//             },
//             ZRemRangeByScoreFunc: func(key string, min string, max string) *redis.IntCmd {
// 	               panic("mock out the ZRemRangeByScore method")
//             },
//             ZRevRangeFunc: func(key string, start int64, stop int64) *redis.StringSliceCmd {
// 	               panic("mock out the ZRevRange method")
//             },
//             ZRevRangeByLexFunc: func(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
// 	               panic("mock out the ZRevRangeByLex method")
//             },
//             ZRevRangeByScoreFunc: func(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
// 	               panic("mock out the ZRevRangeByScore method")
//             },
//             ZRevRangeByScoreWithScoresFunc: func(key string, opt redis.ZRangeBy) *redis.ZSliceCmd {
// 	               panic("mock out the ZRevRangeByScoreWithScores method")
//             },
//             ZRevRangeWithScoresFunc: func(key string, start int64, stop int64) *redis.ZSliceCmd {
// 	               panic("mock out the ZRevRangeWithScores method")
//             },
//             ZRevRankFunc: func(key string, member string) *redis.IntCmd {
// 	               panic("mock out the ZRevRank method")
//             },
//             ZScanFunc: func(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
// 	               panic("mock out the ZScan method")
//             },
//             ZScoreFunc: func(key string, member string) *redis.FloatCmd {
// 	               panic("mock out the ZScore method")
//             },
//             ZUnionStoreFunc: func(dest string, store redis.ZStore, keys ...string) *redis.IntCmd {
// 	               panic("mock out the ZUnionStore method")
//             },
//         }
//
//         // use mockedUniversalClient in code that requires UniversalClient
//         // and then make assertions.
//
//     }
type UniversalClientMock struct {
	// AppendFunc mocks the Append method.
	AppendFunc func(key string, value string) *redis.IntCmd

	// BLPopFunc mocks the BLPop method.
	BLPopFunc func(timeout time.Duration, keys ...string) *redis.StringSliceCmd

	// BRPopFunc mocks the BRPop method.
	BRPopFunc func(timeout time.Duration, keys ...string) *redis.StringSliceCmd

	// BRPopLPushFunc mocks the BRPopLPush method.
	BRPopLPushFunc func(source string, destination string, timeout time.Duration) *redis.StringCmd

	// BZPopMaxFunc mocks the BZPopMax method.
	BZPopMaxFunc func(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd

	// BZPopMinFunc mocks the BZPopMin method.
	BZPopMinFunc func(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd

	// BgRewriteAOFFunc mocks the BgRewriteAOF method.
	BgRewriteAOFFunc func() *redis.StatusCmd

	// BgSaveFunc mocks the BgSave method.
	BgSaveFunc func() *redis.StatusCmd

	// BitCountFunc mocks the BitCount method.
	BitCountFunc func(key string, bitCount *redis.BitCount) *redis.IntCmd

	// BitOpAndFunc mocks the BitOpAnd method.
	BitOpAndFunc func(destKey string, keys ...string) *redis.IntCmd

	// BitOpNotFunc mocks the BitOpNot method.
	BitOpNotFunc func(destKey string, key string) *redis.IntCmd

	// BitOpOrFunc mocks the BitOpOr method.
	BitOpOrFunc func(destKey string, keys ...string) *redis.IntCmd

	// BitOpXorFunc mocks the BitOpXor method.
	BitOpXorFunc func(destKey string, keys ...string) *redis.IntCmd

	// BitPosFunc mocks the BitPos method.
	BitPosFunc func(key string, bit int64, pos ...int64) *redis.IntCmd

	// ClientGetNameFunc mocks the ClientGetName method.
	ClientGetNameFunc func() *redis.StringCmd

	// ClientIDFunc mocks the ClientID method.
	ClientIDFunc func() *redis.IntCmd

	// ClientKillFunc mocks the ClientKill method.
	ClientKillFunc func(ipPort string) *redis.StatusCmd

	// ClientKillByFilterFunc mocks the ClientKillByFilter method.
	ClientKillByFilterFunc func(keys ...string) *redis.IntCmd

	// ClientListFunc mocks the ClientList method.
	ClientListFunc func() *redis.StringCmd

	// ClientPauseFunc mocks the ClientPause method.
	ClientPauseFunc func(dur time.Duration) *redis.BoolCmd

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ClusterAddSlotsFunc mocks the ClusterAddSlots method.
	ClusterAddSlotsFunc func(slots ...int) *redis.StatusCmd

	// ClusterAddSlotsRangeFunc mocks the ClusterAddSlotsRange method.
	ClusterAddSlotsRangeFunc func(min int, max int) *redis.StatusCmd

	// ClusterCountFailureReportsFunc mocks the ClusterCountFailureReports method.
	ClusterCountFailureReportsFunc func(nodeID string) *redis.IntCmd

	// ClusterCountKeysInSlotFunc mocks the ClusterCountKeysInSlot method.
	ClusterCountKeysInSlotFunc func(slot int) *redis.IntCmd

	// ClusterDelSlotsFunc mocks the ClusterDelSlots method.
	ClusterDelSlotsFunc func(slots ...int) *redis.StatusCmd

	// ClusterDelSlotsRangeFunc mocks the ClusterDelSlotsRange method.
	ClusterDelSlotsRangeFunc func(min int, max int) *redis.StatusCmd

	// ClusterFailoverFunc mocks the ClusterFailover method.
	ClusterFailoverFunc func() *redis.StatusCmd

	// ClusterForgetFunc mocks the ClusterForget method.
	ClusterForgetFunc func(nodeID string) *redis.StatusCmd

	// ClusterGetKeysInSlotFunc mocks the ClusterGetKeysInSlot method.
	ClusterGetKeysInSlotFunc func(slot int, count int) *redis.StringSliceCmd

	// ClusterInfoFunc mocks the ClusterInfo method.
	ClusterInfoFunc func() *redis.StringCmd

	// ClusterKeySlotFunc mocks the ClusterKeySlot method.
	ClusterKeySlotFunc func(key string) *redis.IntCmd

	// ClusterMeetFunc mocks the ClusterMeet method.
	ClusterMeetFunc func(host string, port string) *redis.StatusCmd

	// ClusterNodesFunc mocks the ClusterNodes method.
	ClusterNodesFunc func() *redis.StringCmd

	// ClusterReplicateFunc mocks the ClusterReplicate method.
	ClusterReplicateFunc func(nodeID string) *redis.StatusCmd

	// ClusterResetHardFunc mocks the ClusterResetHard method.
	ClusterResetHardFunc func() *redis.StatusCmd

	// ClusterResetSoftFunc mocks the ClusterResetSoft method.
	ClusterResetSoftFunc func() *redis.StatusCmd

	// ClusterSaveConfigFunc mocks the ClusterSaveConfig method.
	ClusterSaveConfigFunc func() *redis.StatusCmd

	// ClusterSlavesFunc mocks the ClusterSlaves method.
	ClusterSlavesFunc func(nodeID string) *redis.StringSliceCmd

	// ClusterSlotsFunc mocks the ClusterSlots method.
	ClusterSlotsFunc func() *redis.ClusterSlotsCmd

	// CommandFunc mocks the Command method.
	CommandFunc func() *redis.CommandsInfoCmd

	// ConfigGetFunc mocks the ConfigGet method.
	ConfigGetFunc func(parameter string) *redis.SliceCmd

	// ConfigResetStatFunc mocks the ConfigResetStat method.
	ConfigResetStatFunc func() *redis.StatusCmd

	// ConfigRewriteFunc mocks the ConfigRewrite method.
	ConfigRewriteFunc func() *redis.StatusCmd

	// ConfigSetFunc mocks the ConfigSet method.
	ConfigSetFunc func(parameter string, value string) *redis.StatusCmd

	// DBSizeFunc mocks the DBSize method.
	DBSizeFunc func() *redis.IntCmd

	// DebugObjectFunc mocks the DebugObject method.
	DebugObjectFunc func(key string) *redis.StringCmd

	// DecrFunc mocks the Decr method.
	DecrFunc func(key string) *redis.IntCmd

	// DecrByFunc mocks the DecrBy method.
	DecrByFunc func(key string, decrement int64) *redis.IntCmd

	// DelFunc mocks the Del method.
	DelFunc func(keys ...string) *redis.IntCmd

	// DumpFunc mocks the Dump method.
	DumpFunc func(key string) *redis.StringCmd

	// EchoFunc mocks the Echo method.
	EchoFunc func(message interface{}) *redis.StringCmd

	// EvalFunc mocks the Eval method.
	EvalFunc func(script string, keys []string, args ...interface{}) *redis.Cmd

	// EvalShaFunc mocks the EvalSha method.
	EvalShaFunc func(sha1 string, keys []string, args ...interface{}) *redis.Cmd

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(keys ...string) *redis.IntCmd

	// ExpireFunc mocks the Expire method.
	ExpireFunc func(key string, expiration time.Duration) *redis.BoolCmd

	// ExpireAtFunc mocks the ExpireAt method.
	ExpireAtFunc func(key string, tm time.Time) *redis.BoolCmd

	// FlushAllFunc mocks the FlushAll method.
	FlushAllFunc func() *redis.StatusCmd

	// FlushAllAsyncFunc mocks the FlushAllAsync method.
	FlushAllAsyncFunc func() *redis.StatusCmd

	// FlushDBFunc mocks the FlushDB method.
	FlushDBFunc func() *redis.StatusCmd

	// FlushDBAsyncFunc mocks the FlushDBAsync method.
	FlushDBAsyncFunc func() *redis.StatusCmd

	// GeoAddFunc mocks the GeoAdd method.
	GeoAddFunc func(key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd

	// GeoDistFunc mocks the GeoDist method.
	GeoDistFunc func(key string, member1 string, member2 string, unit string) *redis.FloatCmd

	// GeoHashFunc mocks the GeoHash method.
	GeoHashFunc func(key string, members ...string) *redis.StringSliceCmd

	// GeoPosFunc mocks the GeoPos method.
	GeoPosFunc func(key string, members ...string) *redis.GeoPosCmd

	// GeoRadiusFunc mocks the GeoRadius method.
	GeoRadiusFunc func(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd

	// GeoRadiusByMemberFunc mocks the GeoRadiusByMember method.
	GeoRadiusByMemberFunc func(key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd

	// GeoRadiusByMemberROFunc mocks the GeoRadiusByMemberRO method.
	GeoRadiusByMemberROFunc func(key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd

	// GeoRadiusROFunc mocks the GeoRadiusRO method.
	GeoRadiusROFunc func(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd

	// GetFunc mocks the Get method.
	GetFunc func(key string) *redis.StringCmd

	// GetBitFunc mocks the GetBit method.
	GetBitFunc func(key string, offset int64) *redis.IntCmd

	// GetRangeFunc mocks the GetRange method.
	GetRangeFunc func(key string, start int64, end int64) *redis.StringCmd

	// GetSetFunc mocks the GetSet method.
	GetSetFunc func(key string, value interface{}) *redis.StringCmd

	// HDelFunc mocks the HDel method.
	HDelFunc func(key string, fields ...string) *redis.IntCmd

	// HExistsFunc mocks the HExists method.
	HExistsFunc func(key string, field string) *redis.BoolCmd

	// HGetFunc mocks the HGet method.
	HGetFunc func(key string, field string) *redis.StringCmd

	// HGetAllFunc mocks the HGetAll method.
	HGetAllFunc func(key string) *redis.StringStringMapCmd

	// HIncrByFunc mocks the HIncrBy method.
	HIncrByFunc func(key string, field string, incr int64) *redis.IntCmd

	// HIncrByFloatFunc mocks the HIncrByFloat method.
	HIncrByFloatFunc func(key string, field string, incr float64) *redis.FloatCmd

	// HKeysFunc mocks the HKeys method.
	HKeysFunc func(key string) *redis.StringSliceCmd

	// HLenFunc mocks the HLen method.
	HLenFunc func(key string) *redis.IntCmd

	// HMGetFunc mocks the HMGet method.
	HMGetFunc func(key string, fields ...string) *redis.SliceCmd

	// HMSetFunc mocks the HMSet method.
	HMSetFunc func(key string, fields map[string]interface{}) *redis.StatusCmd

	// HScanFunc mocks the HScan method.
	HScanFunc func(key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// HSetFunc mocks the HSet method.
	HSetFunc func(key string, field string, value interface{}) *redis.BoolCmd

	// HSetNXFunc mocks the HSetNX method.
	HSetNXFunc func(key string, field string, value interface{}) *redis.BoolCmd

	// HValsFunc mocks the HVals method.
	HValsFunc func(key string) *redis.StringSliceCmd

	// IncrFunc mocks the Incr method.
	IncrFunc func(key string) *redis.IntCmd

	// IncrByFunc mocks the IncrBy method.
	IncrByFunc func(key string, value int64) *redis.IntCmd

	// IncrByFloatFunc mocks the IncrByFloat method.
	IncrByFloatFunc func(key string, value float64) *redis.FloatCmd

	// InfoFunc mocks the Info method.
	InfoFunc func(section ...string) *redis.StringCmd

	// KeysFunc mocks the Keys method.
	KeysFunc func(pattern string) *redis.StringSliceCmd

	// LIndexFunc mocks the LIndex method.
	LIndexFunc func(key string, index int64) *redis.StringCmd

	// LInsertFunc mocks the LInsert method.
	LInsertFunc func(key string, op string, pivot interface{}, value interface{}) *redis.IntCmd

	// LInsertAfterFunc mocks the LInsertAfter method.
	LInsertAfterFunc func(key string, pivot interface{}, value interface{}) *redis.IntCmd

	// LInsertBeforeFunc mocks the LInsertBefore method.
	LInsertBeforeFunc func(key string, pivot interface{}, value interface{}) *redis.IntCmd

	// LLenFunc mocks the LLen method.
	LLenFunc func(key string) *redis.IntCmd

	// LPopFunc mocks the LPop method.
	LPopFunc func(key string) *redis.StringCmd

	// LPushFunc mocks the LPush method.
	LPushFunc func(key string, values ...interface{}) *redis.IntCmd

	// LPushXFunc mocks the LPushX method.
	LPushXFunc func(key string, value interface{}) *redis.IntCmd

	// LRangeFunc mocks the LRange method.
	LRangeFunc func(key string, start int64, stop int64) *redis.StringSliceCmd

	// LRemFunc mocks the LRem method.
	LRemFunc func(key string, count int64, value interface{}) *redis.IntCmd

	// LSetFunc mocks the LSet method.
	LSetFunc func(key string, index int64, value interface{}) *redis.StatusCmd

	// LTrimFunc mocks the LTrim method.
	LTrimFunc func(key string, start int64, stop int64) *redis.StatusCmd

	// LastSaveFunc mocks the LastSave method.
	LastSaveFunc func() *redis.IntCmd

	// MGetFunc mocks the MGet method.
	MGetFunc func(keys ...string) *redis.SliceCmd

	// MSetFunc mocks the MSet method.
	MSetFunc func(pairs ...interface{}) *redis.StatusCmd

	// MSetNXFunc mocks the MSetNX method.
	MSetNXFunc func(pairs ...interface{}) *redis.BoolCmd

	// MemoryUsageFunc mocks the MemoryUsage method.
	MemoryUsageFunc func(key string, samples ...int) *redis.IntCmd

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(host string, port string, key string, db int64, timeout time.Duration) *redis.StatusCmd

	// MoveFunc mocks the Move method.
	MoveFunc func(key string, db int64) *redis.BoolCmd

	// ObjectEncodingFunc mocks the ObjectEncoding method.
	ObjectEncodingFunc func(key string) *redis.StringCmd

	// ObjectIdleTimeFunc mocks the ObjectIdleTime method.
	ObjectIdleTimeFunc func(key string) *redis.DurationCmd

	// ObjectRefCountFunc mocks the ObjectRefCount method.
	ObjectRefCountFunc func(key string) *redis.IntCmd

	// PExpireFunc mocks the PExpire method.
	PExpireFunc func(key string, expiration time.Duration) *redis.BoolCmd

	// PExpireAtFunc mocks the PExpireAt method.
	PExpireAtFunc func(key string, tm time.Time) *redis.BoolCmd

	// PFAddFunc mocks the PFAdd method.
	PFAddFunc func(key string, els ...interface{}) *redis.IntCmd

	// PFCountFunc mocks the PFCount method.
	PFCountFunc func(keys ...string) *redis.IntCmd

	// PFMergeFunc mocks the PFMerge method.
	PFMergeFunc func(dest string, keys ...string) *redis.StatusCmd

	// PSubscribeFunc mocks the PSubscribe method.
	PSubscribeFunc func(channels ...string) *redis.PubSub

	// PTTLFunc mocks the PTTL method.
	PTTLFunc func(key string) *redis.DurationCmd

	// PersistFunc mocks the Persist method.
	PersistFunc func(key string) *redis.BoolCmd

	// PingFunc mocks the Ping method.
	PingFunc func() *redis.StatusCmd

	// PipelineFunc mocks the Pipeline method.
	PipelineFunc func() redis.Pipeliner

	// PipelinedFunc mocks the Pipelined method.
	PipelinedFunc func(fn func(redis.Pipeliner) error) ([]redis.Cmder, error)

	// ProcessFunc mocks the Process method.
	ProcessFunc func(cmd redis.Cmder) error

	// PubSubChannelsFunc mocks the PubSubChannels method.
	PubSubChannelsFunc func(pattern string) *redis.StringSliceCmd

	// PubSubNumPatFunc mocks the PubSubNumPat method.
	PubSubNumPatFunc func() *redis.IntCmd

	// PubSubNumSubFunc mocks the PubSubNumSub method.
	PubSubNumSubFunc func(channels ...string) *redis.StringIntMapCmd

	// PublishFunc mocks the Publish method.
	PublishFunc func(channel string, message interface{}) *redis.IntCmd

	// QuitFunc mocks the Quit method.
	QuitFunc func() *redis.StatusCmd

	// RPopFunc mocks the RPop method.
	RPopFunc func(key string) *redis.StringCmd

	// RPopLPushFunc mocks the RPopLPush method.
	RPopLPushFunc func(source string, destination string) *redis.StringCmd

	// RPushFunc mocks the RPush method.
	RPushFunc func(key string, values ...interface{}) *redis.IntCmd

	// RPushXFunc mocks the RPushX method.
	RPushXFunc func(key string, value interface{}) *redis.IntCmd

	// RandomKeyFunc mocks the RandomKey method.
	RandomKeyFunc func() *redis.StringCmd

	// ReadOnlyFunc mocks the ReadOnly method.
	ReadOnlyFunc func() *redis.StatusCmd

	// ReadWriteFunc mocks the ReadWrite method.
	ReadWriteFunc func() *redis.StatusCmd

	// RenameFunc mocks the Rename method.
	RenameFunc func(key string, newkey string) *redis.StatusCmd

	// RenameNXFunc mocks the RenameNX method.
	RenameNXFunc func(key string, newkey string) *redis.BoolCmd

	// RestoreFunc mocks the Restore method.
	RestoreFunc func(key string, ttl time.Duration, value string) *redis.StatusCmd

	// RestoreReplaceFunc mocks the RestoreReplace method.
	RestoreReplaceFunc func(key string, ttl time.Duration, value string) *redis.StatusCmd

	// SAddFunc mocks the SAdd method.
	SAddFunc func(key string, members ...interface{}) *redis.IntCmd

	// SCardFunc mocks the SCard method.
	SCardFunc func(key string) *redis.IntCmd

	// SDiffFunc mocks the SDiff method.
	SDiffFunc func(keys ...string) *redis.StringSliceCmd

	// SDiffStoreFunc mocks the SDiffStore method.
	SDiffStoreFunc func(destination string, keys ...string) *redis.IntCmd

	// SInterFunc mocks the SInter method.
	SInterFunc func(keys ...string) *redis.StringSliceCmd

	// SInterStoreFunc mocks the SInterStore method.
	SInterStoreFunc func(destination string, keys ...string) *redis.IntCmd

	// SIsMemberFunc mocks the SIsMember method.
	SIsMemberFunc func(key string, member interface{}) *redis.BoolCmd

	// SMembersFunc mocks the SMembers method.
	SMembersFunc func(key string) *redis.StringSliceCmd

	// SMembersMapFunc mocks the SMembersMap method.
	SMembersMapFunc func(key string) *redis.StringStructMapCmd

	// SMoveFunc mocks the SMove method.
	SMoveFunc func(source string, destination string, member interface{}) *redis.BoolCmd

	// SPopFunc mocks the SPop method.
	SPopFunc func(key string) *redis.StringCmd

	// SPopNFunc mocks the SPopN method.
	SPopNFunc func(key string, count int64) *redis.StringSliceCmd

	// SRandMemberFunc mocks the SRandMember method.
	SRandMemberFunc func(key string) *redis.StringCmd

	// SRandMemberNFunc mocks the SRandMemberN method.
	SRandMemberNFunc func(key string, count int64) *redis.StringSliceCmd

	// SRemFunc mocks the SRem method.
	SRemFunc func(key string, members ...interface{}) *redis.IntCmd

	// SScanFunc mocks the SScan method.
	SScanFunc func(key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// SUnionFunc mocks the SUnion method.
	SUnionFunc func(keys ...string) *redis.StringSliceCmd

	// SUnionStoreFunc mocks the SUnionStore method.
	SUnionStoreFunc func(destination string, keys ...string) *redis.IntCmd

	// SaveFunc mocks the Save method.
	SaveFunc func() *redis.StatusCmd

	// ScanFunc mocks the Scan method.
	ScanFunc func(cursor uint64, match string, count int64) *redis.ScanCmd

	// ScriptExistsFunc mocks the ScriptExists method.
	ScriptExistsFunc func(hashes ...string) *redis.BoolSliceCmd

	// ScriptFlushFunc mocks the ScriptFlush method.
	ScriptFlushFunc func() *redis.StatusCmd

	// ScriptKillFunc mocks the ScriptKill method.
	ScriptKillFunc func() *redis.StatusCmd

	// ScriptLoadFunc mocks the ScriptLoad method.
	ScriptLoadFunc func(script string) *redis.StringCmd

	// SetFunc mocks the Set method.
	SetFunc func(key string, value interface{}, expiration time.Duration) *redis.StatusCmd

	// SetBitFunc mocks the SetBit method.
	SetBitFunc func(key string, offset int64, value int) *redis.IntCmd

	// SetNXFunc mocks the SetNX method.
	SetNXFunc func(key string, value interface{}, expiration time.Duration) *redis.BoolCmd

	// SetRangeFunc mocks the SetRange method.
	SetRangeFunc func(key string, offset int64, value string) *redis.IntCmd

	// SetXXFunc mocks the SetXX method.
	SetXXFunc func(key string, value interface{}, expiration time.Duration) *redis.BoolCmd

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func() *redis.StatusCmd

	// ShutdownNoSaveFunc mocks the ShutdownNoSave method.
	ShutdownNoSaveFunc func() *redis.StatusCmd

	// ShutdownSaveFunc mocks the ShutdownSave method.
	ShutdownSaveFunc func() *redis.StatusCmd

	// SlaveOfFunc mocks the SlaveOf method.
	SlaveOfFunc func(host string, port string) *redis.StatusCmd

	// SortFunc mocks the Sort method.
	SortFunc func(key string, sort *redis.Sort) *redis.StringSliceCmd

	// SortInterfacesFunc mocks the SortInterfaces method.
	SortInterfacesFunc func(key string, sort *redis.Sort) *redis.SliceCmd

	// SortStoreFunc mocks the SortStore method.
	SortStoreFunc func(key string, store string, sort *redis.Sort) *redis.IntCmd

	// StrLenFunc mocks the StrLen method.
	StrLenFunc func(key string) *redis.IntCmd

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(channels ...string) *redis.PubSub

	// TTLFunc mocks the TTL method.
	TTLFunc func(key string) *redis.DurationCmd

	// TimeFunc mocks the Time method.
	TimeFunc func() *redis.TimeCmd

	// TouchFunc mocks the Touch method.
	TouchFunc func(keys ...string) *redis.IntCmd

	// TxPipelineFunc mocks the TxPipeline method.
	TxPipelineFunc func() redis.Pipeliner

	// TxPipelinedFunc mocks the TxPipelined method.
	TxPipelinedFunc func(fn func(redis.Pipeliner) error) ([]redis.Cmder, error)

	// TypeFunc mocks the Type method.
	TypeFunc func(key string) *redis.StatusCmd

	// UnlinkFunc mocks the Unlink method.
	UnlinkFunc func(keys ...string) *redis.IntCmd

	// WatchFunc mocks the Watch method.
	WatchFunc func(fn func(*redis.Tx) error, keys ...string) error

	// WrapProcessFunc mocks the WrapProcess method.
	WrapProcessFunc func(fn func(oldProcess func(cmd redis.Cmder) error) func(cmd redis.Cmder) error)

	// XAckFunc mocks the XAck method.
	XAckFunc func(stream string, group string, ids ...string) *redis.IntCmd

	// XAddFunc mocks the XAdd method.
	XAddFunc func(a *redis.XAddArgs) *redis.StringCmd

	// XClaimFunc mocks the XClaim method.
	XClaimFunc func(a *redis.XClaimArgs) *redis.XMessageSliceCmd

	// XClaimJustIDFunc mocks the XClaimJustID method.
	XClaimJustIDFunc func(a *redis.XClaimArgs) *redis.StringSliceCmd

	// XDelFunc mocks the XDel method.
	XDelFunc func(stream string, ids ...string) *redis.IntCmd

	// XGroupCreateFunc mocks the XGroupCreate method.
	XGroupCreateFunc func(stream string, group string, start string) *redis.StatusCmd

	// XGroupCreateMkStreamFunc mocks the XGroupCreateMkStream method.
	XGroupCreateMkStreamFunc func(stream string, group string, start string) *redis.StatusCmd

	// XGroupDelConsumerFunc mocks the XGroupDelConsumer method.
	XGroupDelConsumerFunc func(stream string, group string, consumer string) *redis.IntCmd

	// XGroupDestroyFunc mocks the XGroupDestroy method.
	XGroupDestroyFunc func(stream string, group string) *redis.IntCmd

	// XGroupSetIDFunc mocks the XGroupSetID method.
	XGroupSetIDFunc func(stream string, group string, start string) *redis.StatusCmd

	// XLenFunc mocks the XLen method.
	XLenFunc func(stream string) *redis.IntCmd

	// XPendingFunc mocks the XPending method.
	XPendingFunc func(stream string, group string) *redis.XPendingCmd

	// XPendingExtFunc mocks the XPendingExt method.
	XPendingExtFunc func(a *redis.XPendingExtArgs) *redis.XPendingExtCmd

	// XRangeFunc mocks the XRange method.
	XRangeFunc func(stream string, start string, stop string) *redis.XMessageSliceCmd

	// XRangeNFunc mocks the XRangeN method.
	XRangeNFunc func(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd

	// XReadFunc mocks the XRead method.
	XReadFunc func(a *redis.XReadArgs) *redis.XStreamSliceCmd

	// XReadGroupFunc mocks the XReadGroup method.
	XReadGroupFunc func(a *redis.XReadGroupArgs) *redis.XStreamSliceCmd

	// XReadStreamsFunc mocks the XReadStreams method.
	XReadStreamsFunc func(streams ...string) *redis.XStreamSliceCmd

	// XRevRangeFunc mocks the XRevRange method.
	XRevRangeFunc func(stream string, start string, stop string) *redis.XMessageSliceCmd

	// XRevRangeNFunc mocks the XRevRangeN method.
	XRevRangeNFunc func(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd

	// XTrimFunc mocks the XTrim method.
	XTrimFunc func(key string, maxLen int64) *redis.IntCmd

	// XTrimApproxFunc mocks the XTrimApprox method.
	XTrimApproxFunc func(key string, maxLen int64) *redis.IntCmd

	// ZAddFunc mocks the ZAdd method.
	ZAddFunc func(key string, members ...redis.Z) *redis.IntCmd

	// ZAddChFunc mocks the ZAddCh method.
	ZAddChFunc func(key string, members ...redis.Z) *redis.IntCmd

	// ZAddNXFunc mocks the ZAddNX method.
	ZAddNXFunc func(key string, members ...redis.Z) *redis.IntCmd

	// ZAddNXChFunc mocks the ZAddNXCh method.
	ZAddNXChFunc func(key string, members ...redis.Z) *redis.IntCmd

	// ZAddXXFunc mocks the ZAddXX method.
	ZAddXXFunc func(key string, members ...redis.Z) *redis.IntCmd

	// ZAddXXChFunc mocks the ZAddXXCh method.
	ZAddXXChFunc func(key string, members ...redis.Z) *redis.IntCmd

	// ZCardFunc mocks the ZCard method.
	ZCardFunc func(key string) *redis.IntCmd

	// ZCountFunc mocks the ZCount method.
	ZCountFunc func(key string, min string, max string) *redis.IntCmd

	// ZIncrFunc mocks the ZIncr method.
	ZIncrFunc func(key string, member redis.Z) *redis.FloatCmd

	// ZIncrByFunc mocks the ZIncrBy method.
	ZIncrByFunc func(key string, increment float64, member string) *redis.FloatCmd

	// ZIncrNXFunc mocks the ZIncrNX method.
	ZIncrNXFunc func(key string, member redis.Z) *redis.FloatCmd

	// ZIncrXXFunc mocks the ZIncrXX method.
	ZIncrXXFunc func(key string, member redis.Z) *redis.FloatCmd

	// ZInterStoreFunc mocks the ZInterStore method.
	ZInterStoreFunc func(destination string, store redis.ZStore, keys ...string) *redis.IntCmd

	// ZLexCountFunc mocks the ZLexCount method.
	ZLexCountFunc func(key string, min string, max string) *redis.IntCmd

	// ZPopMaxFunc mocks the ZPopMax method.
	ZPopMaxFunc func(key string, count ...int64) *redis.ZSliceCmd

	// ZPopMinFunc mocks the ZPopMin method.
	ZPopMinFunc func(key string, count ...int64) *redis.ZSliceCmd

	// ZRangeFunc mocks the ZRange method.
	ZRangeFunc func(key string, start int64, stop int64) *redis.StringSliceCmd

	// ZRangeByLexFunc mocks the ZRangeByLex method.
	ZRangeByLexFunc func(key string, opt redis.ZRangeBy) *redis.StringSliceCmd

	// ZRangeByScoreFunc mocks the ZRangeByScore method.
	ZRangeByScoreFunc func(key string, opt redis.ZRangeBy) *redis.StringSliceCmd

	// ZRangeByScoreWithScoresFunc mocks the ZRangeByScoreWithScores method.
	ZRangeByScoreWithScoresFunc func(key string, opt redis.ZRangeBy) *redis.ZSliceCmd

	// ZRangeWithScoresFunc mocks the ZRangeWithScores method.
	ZRangeWithScoresFunc func(key string, start int64, stop int64) *redis.ZSliceCmd

	// ZRankFunc mocks the ZRank method.
	ZRankFunc func(key string, member string) *redis.IntCmd

	// ZRemFunc mocks the ZRem method.
	ZRemFunc func(key string, members ...interface{}) *redis.IntCmd

	// ZRemRangeByLexFunc mocks the ZRemRangeByLex method.
	ZRemRangeByLexFunc func(key string, min string, max string) *redis.IntCmd

	// ZRemRangeByRankFunc mocks the ZRemRangeByRank method.
	ZRemRangeByRankFunc func(key string, start int64, stop int64) *redis.IntCmd

	// ZRemRangeByScoreFunc mocks the ZRemRangeByScore method.
	ZRemRangeByScoreFunc func(key string, min string, max string) *redis.IntCmd

	// ZRevRangeFunc mocks the ZRevRange method.
	ZRevRangeFunc func(key string, start int64, stop int64) *redis.StringSliceCmd

	// ZRevRangeByLexFunc mocks the ZRevRangeByLex method.
	ZRevRangeByLexFunc func(key string, opt redis.ZRangeBy) *redis.StringSliceCmd

	// ZRevRangeByScoreFunc mocks the ZRevRangeByScore method.
	ZRevRangeByScoreFunc func(key string, opt redis.ZRangeBy) *redis.StringSliceCmd

	// ZRevRangeByScoreWithScoresFunc mocks the ZRevRangeByScoreWithScores method.
	ZRevRangeByScoreWithScoresFunc func(key string, opt redis.ZRangeBy) *redis.ZSliceCmd

	// ZRevRangeWithScoresFunc mocks the ZRevRangeWithScores method.
	ZRevRangeWithScoresFunc func(key string, start int64, stop int64) *redis.ZSliceCmd

	// ZRevRankFunc mocks the ZRevRank method.
	ZRevRankFunc func(key string, member string) *redis.IntCmd

	// ZScanFunc mocks the ZScan method.
	ZScanFunc func(key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// ZScoreFunc mocks the ZScore method.
	ZScoreFunc func(key string, member string) *redis.FloatCmd

	// ZUnionStoreFunc mocks the ZUnionStore method.
	ZUnionStoreFunc func(dest string, store redis.ZStore, keys ...string) *redis.IntCmd

	// calls tracks calls to the methods.
	calls struct {
		// Append holds details about calls to the Append method.
		Append []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
		}
		// BLPop holds details about calls to the BLPop method.
		BLPop []struct {
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BRPop holds details about calls to the BRPop method.
		BRPop []struct {
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BRPopLPush holds details about calls to the BRPopLPush method.
		BRPopLPush []struct {
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
		// BZPopMax holds details about calls to the BZPopMax method.
		BZPopMax []struct {
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BZPopMin holds details about calls to the BZPopMin method.
		BZPopMin []struct {
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BgRewriteAOF holds details about calls to the BgRewriteAOF method.
		BgRewriteAOF []struct {
		}
		// BgSave holds details about calls to the BgSave method.
		BgSave []struct {
		}
		// BitCount holds details about calls to the BitCount method.
		BitCount []struct {
			// Key is the key argument value.
			Key string
			// BitCount is the bitCount argument value.
			BitCount *redis.BitCount
		}
		// BitOpAnd holds details about calls to the BitOpAnd method.
		BitOpAnd []struct {
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpNot holds details about calls to the BitOpNot method.
		BitOpNot []struct {
			// DestKey is the destKey argument value.
			DestKey string
			// Key is the key argument value.
			Key string
		}
		// BitOpOr holds details about calls to the BitOpOr method.
		BitOpOr []struct {
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpXor holds details about calls to the BitOpXor method.
		BitOpXor []struct {
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitPos holds details about calls to the BitPos method.
		BitPos []struct {
			// Key is the key argument value.
			Key string
			// Bit is the bit argument value.
			Bit int64
			// Pos is the pos argument value.
			Pos []int64
		}
		// ClientGetName holds details about calls to the ClientGetName method.
		ClientGetName []struct {
		}
		// ClientID holds details about calls to the ClientID method.
		ClientID []struct {
		}
		// ClientKill holds details about calls to the ClientKill method.
		ClientKill []struct {
			// IpPort is the ipPort argument value.
			IpPort string
		}
		// ClientKillByFilter holds details about calls to the ClientKillByFilter method.
		ClientKillByFilter []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// ClientList holds details about calls to the ClientList method.
		ClientList []struct {
		}
		// ClientPause holds details about calls to the ClientPause method.
		ClientPause []struct {
			// Dur is the dur argument value.
			Dur time.Duration
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// ClusterAddSlots holds details about calls to the ClusterAddSlots method.
		ClusterAddSlots []struct {
			// Slots is the slots argument value.
			Slots []int
		}
		// ClusterAddSlotsRange holds details about calls to the ClusterAddSlotsRange method.
		ClusterAddSlotsRange []struct {
			// Min is the min argument value.
			Min int
			// Max is the max argument value.
			Max int
		}
		// ClusterCountFailureReports holds details about calls to the ClusterCountFailureReports method.
		ClusterCountFailureReports []struct {
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterCountKeysInSlot holds details about calls to the ClusterCountKeysInSlot method.
		ClusterCountKeysInSlot []struct {
			// Slot is the slot argument value.
			Slot int
		}
		// ClusterDelSlots holds details about calls to the ClusterDelSlots method.
		ClusterDelSlots []struct {
			// Slots is the slots argument value.
			Slots []int
		}
		// ClusterDelSlotsRange holds details about calls to the ClusterDelSlotsRange method.
		ClusterDelSlotsRange []struct {
			// Min is the min argument value.
			Min int
			// Max is the max argument value.
			Max int
		}
		// ClusterFailover holds details about calls to the ClusterFailover method.
		ClusterFailover []struct {
		}
		// ClusterForget holds details about calls to the ClusterForget method.
		ClusterForget []struct {
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterGetKeysInSlot holds details about calls to the ClusterGetKeysInSlot method.
		ClusterGetKeysInSlot []struct {
			// Slot is the slot argument value.
			Slot int
			// Count is the count argument value.
			Count int
		}
		// ClusterInfo holds details about calls to the ClusterInfo method.
		ClusterInfo []struct {
		}
		// ClusterKeySlot holds details about calls to the ClusterKeySlot method.
		ClusterKeySlot []struct {
			// Key is the key argument value.
			Key string
		}
		// ClusterMeet holds details about calls to the ClusterMeet method.
		ClusterMeet []struct {
			// Host is the host argument value.
			Host string
			// Port is the port argument value.
			Port string
		}
		// ClusterNodes holds details about calls to the ClusterNodes method.
		ClusterNodes []struct {
		}
		// ClusterReplicate holds details about calls to the ClusterReplicate method.
		ClusterReplicate []struct {
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterResetHard holds details about calls to the ClusterResetHard method.
		ClusterResetHard []struct {
		}
		// ClusterResetSoft holds details about calls to the ClusterResetSoft method.
		ClusterResetSoft []struct {
		}
		// ClusterSaveConfig holds details about calls to the ClusterSaveConfig method.
		ClusterSaveConfig []struct {
		}
		// ClusterSlaves holds details about calls to the ClusterSlaves method.
		ClusterSlaves []struct {
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterSlots holds details about calls to the ClusterSlots method.
		ClusterSlots []struct {
		}
		// Command holds details about calls to the Command method.
		Command []struct {
		}
		// ConfigGet holds details about calls to the ConfigGet method.
		ConfigGet []struct {
			// Parameter is the parameter argument value.
			Parameter string
		}
		// ConfigResetStat holds details about calls to the ConfigResetStat method.
		ConfigResetStat []struct {
		}
		// ConfigRewrite holds details about calls to the ConfigRewrite method.
		ConfigRewrite []struct {
		}
		// ConfigSet holds details about calls to the ConfigSet method.
		ConfigSet []struct {
			// Parameter is the parameter argument value.
			Parameter string
			// Value is the value argument value.
			Value string
		}
		// DBSize holds details about calls to the DBSize method.
		DBSize []struct {
		}
		// DebugObject holds details about calls to the DebugObject method.
		DebugObject []struct {
			// Key is the key argument value.
			Key string
		}
		// Decr holds details about calls to the Decr method.
		Decr []struct {
			// Key is the key argument value.
			Key string
		}
		// DecrBy holds details about calls to the DecrBy method.
		DecrBy []struct {
			// Key is the key argument value.
			Key string
			// Decrement is the decrement argument value.
			Decrement int64
		}
		// Del holds details about calls to the Del method.
		Del []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// Dump holds details about calls to the Dump method.
		Dump []struct {
			// Key is the key argument value.
			Key string
		}
		// Echo holds details about calls to the Echo method.
		Echo []struct {
			// Message is the message argument value.
			Message interface{}
		}
		// Eval holds details about calls to the Eval method.
		Eval []struct {
			// Script is the script argument value.
			Script string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// EvalSha holds details about calls to the EvalSha method.
		EvalSha []struct {
			// Sha1 is the sha1 argument value.
			Sha1 string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// Expire holds details about calls to the Expire method.
		Expire []struct {
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// ExpireAt holds details about calls to the ExpireAt method.
		ExpireAt []struct {
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
		}
		// FlushAll holds details about calls to the FlushAll method.
		FlushAll []struct {
		}
		// FlushAllAsync holds details about calls to the FlushAllAsync method.
		FlushAllAsync []struct {
		}
		// FlushDB holds details about calls to the FlushDB method.
		FlushDB []struct {
		}
		// FlushDBAsync holds details about calls to the FlushDBAsync method.
		FlushDBAsync []struct {
		}
		// GeoAdd holds details about calls to the GeoAdd method.
		GeoAdd []struct {
			// Key is the key argument value.
			Key string
			// GeoLocation is the geoLocation argument value.
			GeoLocation []*redis.GeoLocation
		}
		// GeoDist holds details about calls to the GeoDist method.
		GeoDist []struct {
			// Key is the key argument value.
			Key string
			// Member1 is the member1 argument value.
			Member1 string
			// Member2 is the member2 argument value.
			Member2 string
			// Unit is the unit argument value.
			Unit string
		}
		// GeoHash holds details about calls to the GeoHash method.
		GeoHash []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []string
		}
		// GeoPos holds details about calls to the GeoPos method.
		GeoPos []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []string
		}
		// GeoRadius holds details about calls to the GeoRadius method.
		GeoRadius []struct {
			// Key is the key argument value.
			Key string
			// Longitude is the longitude argument value.
			Longitude float64
			// Latitude is the latitude argument value.
			Latitude float64
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoRadiusByMember holds details about calls to the GeoRadiusByMember method.
		GeoRadiusByMember []struct {
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoRadiusByMemberRO holds details about calls to the GeoRadiusByMemberRO method.
		GeoRadiusByMemberRO []struct {
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoRadiusRO holds details about calls to the GeoRadiusRO method.
		GeoRadiusRO []struct {
			// Key is the key argument value.
			Key string
			// Longitude is the longitude argument value.
			Longitude float64
			// Latitude is the latitude argument value.
			Latitude float64
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Key is the key argument value.
			Key string
		}
		// GetBit holds details about calls to the GetBit method.
		GetBit []struct {
			// Key is the key argument value.
			Key string
			// Offset is the offset argument value.
			Offset int64
		}
		// GetRange holds details about calls to the GetRange method.
		GetRange []struct {
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// End is the end argument value.
			End int64
		}
		// GetSet holds details about calls to the GetSet method.
		GetSet []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
		}
		// HDel holds details about calls to the HDel method.
		HDel []struct {
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HExists holds details about calls to the HExists method.
		HExists []struct {
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
		}
		// HGet holds details about calls to the HGet method.
		HGet []struct {
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
		}
		// HGetAll holds details about calls to the HGetAll method.
		HGetAll []struct {
			// Key is the key argument value.
			Key string
		}
		// HIncrBy holds details about calls to the HIncrBy method.
		HIncrBy []struct {
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Incr is the incr argument value.
			Incr int64
		}
		// HIncrByFloat holds details about calls to the HIncrByFloat method.
		HIncrByFloat []struct {
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Incr is the incr argument value.
			Incr float64
		}
		// HKeys holds details about calls to the HKeys method.
		HKeys []struct {
			// Key is the key argument value.
			Key string
		}
		// HLen holds details about calls to the HLen method.
		HLen []struct {
			// Key is the key argument value.
			Key string
		}
		// HMGet holds details about calls to the HMGet method.
		HMGet []struct {
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HMSet holds details about calls to the HMSet method.
		HMSet []struct {
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields map[string]interface{}
		}
		// HScan holds details about calls to the HScan method.
		HScan []struct {
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// HSet holds details about calls to the HSet method.
		HSet []struct {
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Value is the value argument value.
			Value interface{}
		}
		// HSetNX holds details about calls to the HSetNX method.
		HSetNX []struct {
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Value is the value argument value.
			Value interface{}
		}
		// HVals holds details about calls to the HVals method.
		HVals []struct {
			// Key is the key argument value.
			Key string
		}
		// Incr holds details about calls to the Incr method.
		Incr []struct {
			// Key is the key argument value.
			Key string
		}
		// IncrBy holds details about calls to the IncrBy method.
		IncrBy []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value int64
		}
		// IncrByFloat holds details about calls to the IncrByFloat method.
		IncrByFloat []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value float64
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Section is the section argument value.
			Section []string
		}
		// Keys holds details about calls to the Keys method.
		Keys []struct {
			// Pattern is the pattern argument value.
			Pattern string
		}
		// LIndex holds details about calls to the LIndex method.
		LIndex []struct {
			// Key is the key argument value.
			Key string
			// Index is the index argument value.
			Index int64
		}
		// LInsert holds details about calls to the LInsert method.
		LInsert []struct {
			// Key is the key argument value.
			Key string
			// Op is the op argument value.
			Op string
			// Pivot is the pivot argument value.
			Pivot interface{}
			// Value is the value argument value.
			Value interface{}
		}
		// LInsertAfter holds details about calls to the LInsertAfter method.
		LInsertAfter []struct {
			// Key is the key argument value.
			Key string
			// Pivot is the pivot argument value.
			Pivot interface{}
			// Value is the value argument value.
			Value interface{}
		}
		// LInsertBefore holds details about calls to the LInsertBefore method.
		LInsertBefore []struct {
			// Key is the key argument value.
			Key string
			// Pivot is the pivot argument value.
			Pivot interface{}
			// Value is the value argument value.
			Value interface{}
		}
		// LLen holds details about calls to the LLen method.
		LLen []struct {
			// Key is the key argument value.
			Key string
		}
		// LPop holds details about calls to the LPop method.
		LPop []struct {
			// Key is the key argument value.
			Key string
		}
		// LPush holds details about calls to the LPush method.
		LPush []struct {
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// LPushX holds details about calls to the LPushX method.
		LPushX []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
		}
		// LRange holds details about calls to the LRange method.
		LRange []struct {
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// LRem holds details about calls to the LRem method.
		LRem []struct {
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int64
			// Value is the value argument value.
			Value interface{}
		}
		// LSet holds details about calls to the LSet method.
		LSet []struct {
			// Key is the key argument value.
			Key string
			// Index is the index argument value.
			Index int64
			// Value is the value argument value.
			Value interface{}
		}
		// LTrim holds details about calls to the LTrim method.
		LTrim []struct {
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// LastSave holds details about calls to the LastSave method.
		LastSave []struct {
		}
		// MGet holds details about calls to the MGet method.
		MGet []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// MSet holds details about calls to the MSet method.
		MSet []struct {
			// Pairs is the pairs argument value.
			Pairs []interface{}
		}
		// MSetNX holds details about calls to the MSetNX method.
		MSetNX []struct {
			// Pairs is the pairs argument value.
			Pairs []interface{}
		}
		// MemoryUsage holds details about calls to the MemoryUsage method.
		MemoryUsage []struct {
			// Key is the key argument value.
			Key string
			// Samples is the samples argument value.
			Samples []int
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Host is the host argument value.
			Host string
			// Port is the port argument value.
			Port string
			// Key is the key argument value.
			Key string
			// Db is the db argument value.
			Db int64
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
		// Move holds details about calls to the Move method.
		Move []struct {
			// Key is the key argument value.
			Key string
			// Db is the db argument value.
			Db int64
		}
		// ObjectEncoding holds details about calls to the ObjectEncoding method.
		ObjectEncoding []struct {
			// Key is the key argument value.
			Key string
		}
		// ObjectIdleTime holds details about calls to the ObjectIdleTime method.
		ObjectIdleTime []struct {
			// Key is the key argument value.
			Key string
		}
		// ObjectRefCount holds details about calls to the ObjectRefCount method.
		ObjectRefCount []struct {
			// Key is the key argument value.
			Key string
		}
		// PExpire holds details about calls to the PExpire method.
		PExpire []struct {
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// PExpireAt holds details about calls to the PExpireAt method.
		PExpireAt []struct {
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
		}
		// PFAdd holds details about calls to the PFAdd method.
		PFAdd []struct {
			// Key is the key argument value.
			Key string
			// Els is the els argument value.
			Els []interface{}
		}
		// PFCount holds details about calls to the PFCount method.
		PFCount []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// PFMerge holds details about calls to the PFMerge method.
		PFMerge []struct {
			// Dest is the dest argument value.
			Dest string
			// Keys is the keys argument value.
			Keys []string
		}
		// PSubscribe holds details about calls to the PSubscribe method.
		PSubscribe []struct {
			// Channels is the channels argument value.
			Channels []string
		}
		// PTTL holds details about calls to the PTTL method.
		PTTL []struct {
			// Key is the key argument value.
			Key string
		}
		// Persist holds details about calls to the Persist method.
		Persist []struct {
			// Key is the key argument value.
			Key string
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
		}
		// Pipeline holds details about calls to the Pipeline method.
		Pipeline []struct {
		}
		// Pipelined holds details about calls to the Pipelined method.
		Pipelined []struct {
			// Fn is the fn argument value.
			Fn func(redis.Pipeliner) error
		}
		// Process holds details about calls to the Process method.
		Process []struct {
			// Cmd is the cmd argument value.
			Cmd redis.Cmder
		}
		// PubSubChannels holds details about calls to the PubSubChannels method.
		PubSubChannels []struct {
			// Pattern is the pattern argument value.
			Pattern string
		}
		// PubSubNumPat holds details about calls to the PubSubNumPat method.
		PubSubNumPat []struct {
		}
		// PubSubNumSub holds details about calls to the PubSubNumSub method.
		PubSubNumSub []struct {
			// Channels is the channels argument value.
			Channels []string
		}
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Channel is the channel argument value.
			Channel string
			// Message is the message argument value.
			Message interface{}
		}
		// Quit holds details about calls to the Quit method.
		Quit []struct {
		}
		// RPop holds details about calls to the RPop method.
		RPop []struct {
			// Key is the key argument value.
			Key string
		}
		// RPopLPush holds details about calls to the RPopLPush method.
		RPopLPush []struct {
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
		}
		// RPush holds details about calls to the RPush method.
		RPush []struct {
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// RPushX holds details about calls to the RPushX method.
		RPushX []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
		}
		// RandomKey holds details about calls to the RandomKey method.
		RandomKey []struct {
		}
		// ReadOnly holds details about calls to the ReadOnly method.
		ReadOnly []struct {
		}
		// ReadWrite holds details about calls to the ReadWrite method.
		ReadWrite []struct {
		}
		// Rename holds details about calls to the Rename method.
		Rename []struct {
			// Key is the key argument value.
			Key string
			// Newkey is the newkey argument value.
			Newkey string
		}
		// RenameNX holds details about calls to the RenameNX method.
		RenameNX []struct {
			// Key is the key argument value.
			Key string
			// Newkey is the newkey argument value.
			Newkey string
		}
		// Restore holds details about calls to the Restore method.
		Restore []struct {
			// Key is the key argument value.
			Key string
			// TTL is the ttl argument value.
			TTL time.Duration
			// Value is the value argument value.
			Value string
		}
		// RestoreReplace holds details about calls to the RestoreReplace method.
		RestoreReplace []struct {
			// Key is the key argument value.
			Key string
			// TTL is the ttl argument value.
			TTL time.Duration
			// Value is the value argument value.
			Value string
		}
		// SAdd holds details about calls to the SAdd method.
		SAdd []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// SCard holds details about calls to the SCard method.
		SCard []struct {
			// Key is the key argument value.
			Key string
		}
		// SDiff holds details about calls to the SDiff method.
		SDiff []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// SDiffStore holds details about calls to the SDiffStore method.
		SDiffStore []struct {
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// SInter holds details about calls to the SInter method.
		SInter []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// SInterStore holds details about calls to the SInterStore method.
		SInterStore []struct {
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// SIsMember holds details about calls to the SIsMember method.
		SIsMember []struct {
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member interface{}
		}
		// SMembers holds details about calls to the SMembers method.
		SMembers []struct {
			// Key is the key argument value.
			Key string
		}
		// SMembersMap holds details about calls to the SMembersMap method.
		SMembersMap []struct {
			// Key is the key argument value.
			Key string
		}
		// SMove holds details about calls to the SMove method.
		SMove []struct {
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Member is the member argument value.
			Member interface{}
		}
		// SPop holds details about calls to the SPop method.
		SPop []struct {
			// Key is the key argument value.
			Key string
		}
		// SPopN holds details about calls to the SPopN method.
		SPopN []struct {
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int64
		}
		// SRandMember holds details about calls to the SRandMember method.
		SRandMember []struct {
			// Key is the key argument value.
			Key string
		}
		// SRandMemberN holds details about calls to the SRandMemberN method.
		SRandMemberN []struct {
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int64
		}
		// SRem holds details about calls to the SRem method.
		SRem []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// SScan holds details about calls to the SScan method.
		SScan []struct {
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// SUnion holds details about calls to the SUnion method.
		SUnion []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// SUnionStore holds details about calls to the SUnionStore method.
		SUnionStore []struct {
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
		}
		// Scan holds details about calls to the Scan method.
		Scan []struct {
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// ScriptExists holds details about calls to the ScriptExists method.
		ScriptExists []struct {
			// Hashes is the hashes argument value.
			Hashes []string
		}
		// ScriptFlush holds details about calls to the ScriptFlush method.
		ScriptFlush []struct {
		}
		// ScriptKill holds details about calls to the ScriptKill method.
		ScriptKill []struct {
		}
		// ScriptLoad holds details about calls to the ScriptLoad method.
		ScriptLoad []struct {
			// Script is the script argument value.
			Script string
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetBit holds details about calls to the SetBit method.
		SetBit []struct {
			// Key is the key argument value.
			Key string
			// Offset is the offset argument value.
			Offset int64
			// Value is the value argument value.
			Value int
		}
		// SetNX holds details about calls to the SetNX method.
		SetNX []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetRange holds details about calls to the SetRange method.
		SetRange []struct {
			// Key is the key argument value.
			Key string
			// Offset is the offset argument value.
			Offset int64
			// Value is the value argument value.
			Value string
		}
		// SetXX holds details about calls to the SetXX method.
		SetXX []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
		}
		// ShutdownNoSave holds details about calls to the ShutdownNoSave method.
		ShutdownNoSave []struct {
		}
		// ShutdownSave holds details about calls to the ShutdownSave method.
		ShutdownSave []struct {
		}
		// SlaveOf holds details about calls to the SlaveOf method.
		SlaveOf []struct {
			// Host is the host argument value.
			Host string
			// Port is the port argument value.
			Port string
		}
		// Sort holds details about calls to the Sort method.
		Sort []struct {
			// Key is the key argument value.
			Key string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// SortInterfaces holds details about calls to the SortInterfaces method.
		SortInterfaces []struct {
			// Key is the key argument value.
			Key string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// SortStore holds details about calls to the SortStore method.
		SortStore []struct {
			// Key is the key argument value.
			Key string
			// Store is the store argument value.
			Store string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// StrLen holds details about calls to the StrLen method.
		StrLen []struct {
			// Key is the key argument value.
			Key string
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Channels is the channels argument value.
			Channels []string
		}
		// TTL holds details about calls to the TTL method.
		TTL []struct {
			// Key is the key argument value.
			Key string
		}
		// Time holds details about calls to the Time method.
		Time []struct {
		}
		// Touch holds details about calls to the Touch method.
		Touch []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// TxPipeline holds details about calls to the TxPipeline method.
		TxPipeline []struct {
		}
		// TxPipelined holds details about calls to the TxPipelined method.
		TxPipelined []struct {
			// Fn is the fn argument value.
			Fn func(redis.Pipeliner) error
		}
		// Type holds details about calls to the Type method.
		Type []struct {
			// Key is the key argument value.
			Key string
		}
		// Unlink holds details about calls to the Unlink method.
		Unlink []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// Watch holds details about calls to the Watch method.
		Watch []struct {
			// Fn is the fn argument value.
			Fn func(*redis.Tx) error
			// Keys is the keys argument value.
			Keys []string
		}
		// WrapProcess holds details about calls to the WrapProcess method.
		WrapProcess []struct {
			// Fn is the fn argument value.
			Fn func(oldProcess func(cmd redis.Cmder) error) func(cmd redis.Cmder) error
		}
		// XAck holds details about calls to the XAck method.
		XAck []struct {
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Ids is the ids argument value.
			Ids []string
		}
		// XAdd holds details about calls to the XAdd method.
		XAdd []struct {
			// A is the a argument value.
			A *redis.XAddArgs
		}
		// XClaim holds details about calls to the XClaim method.
		XClaim []struct {
			// A is the a argument value.
			A *redis.XClaimArgs
		}
		// XClaimJustID holds details about calls to the XClaimJustID method.
		XClaimJustID []struct {
			// A is the a argument value.
			A *redis.XClaimArgs
		}
		// XDel holds details about calls to the XDel method.
		XDel []struct {
			// Stream is the stream argument value.
			Stream string
			// Ids is the ids argument value.
			Ids []string
		}
		// XGroupCreate holds details about calls to the XGroupCreate method.
		XGroupCreate []struct {
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Start is the start argument value.
			Start string
		}
		// XGroupCreateMkStream holds details about calls to the XGroupCreateMkStream method.
		XGroupCreateMkStream []struct {
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Start is the start argument value.
			Start string
		}
		// XGroupDelConsumer holds details about calls to the XGroupDelConsumer method.
		XGroupDelConsumer []struct {
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Consumer is the consumer argument value.
			Consumer string
		}
		// XGroupDestroy holds details about calls to the XGroupDestroy method.
		XGroupDestroy []struct {
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
		}
		// XGroupSetID holds details about calls to the XGroupSetID method.
		XGroupSetID []struct {
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Start is the start argument value.
			Start string
		}
		// XLen holds details about calls to the XLen method.
		XLen []struct {
			// Stream is the stream argument value.
			Stream string
		}
		// XPending holds details about calls to the XPending method.
		XPending []struct {
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
		}
		// XPendingExt holds details about calls to the XPendingExt method.
		XPendingExt []struct {
			// A is the a argument value.
			A *redis.XPendingExtArgs
		}
		// XRange holds details about calls to the XRange method.
		XRange []struct {
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
		}
		// XRangeN holds details about calls to the XRangeN method.
		XRangeN []struct {
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
			// Count is the count argument value.
			Count int64
		}
		// XRead holds details about calls to the XRead method.
		XRead []struct {
			// A is the a argument value.
			A *redis.XReadArgs
		}
		// XReadGroup holds details about calls to the XReadGroup method.
		XReadGroup []struct {
			// A is the a argument value.
			A *redis.XReadGroupArgs
		}
		// XReadStreams holds details about calls to the XReadStreams method.
		XReadStreams []struct {
			// Streams is the streams argument value.
			Streams []string
		}
		// XRevRange holds details about calls to the XRevRange method.
		XRevRange []struct {
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
		}
		// XRevRangeN holds details about calls to the XRevRangeN method.
		XRevRangeN []struct {
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
			// Count is the count argument value.
			Count int64
		}
		// XTrim holds details about calls to the XTrim method.
		XTrim []struct {
			// Key is the key argument value.
			Key string
			// MaxLen is the maxLen argument value.
			MaxLen int64
		}
		// XTrimApprox holds details about calls to the XTrimApprox method.
		XTrimApprox []struct {
			// Key is the key argument value.
			Key string
			// MaxLen is the maxLen argument value.
			MaxLen int64
		}
		// ZAdd holds details about calls to the ZAdd method.
		ZAdd []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddCh holds details about calls to the ZAddCh method.
		ZAddCh []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddNX holds details about calls to the ZAddNX method.
		ZAddNX []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddNXCh holds details about calls to the ZAddNXCh method.
		ZAddNXCh []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddXX holds details about calls to the ZAddXX method.
		ZAddXX []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddXXCh holds details about calls to the ZAddXXCh method.
		ZAddXXCh []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZCard holds details about calls to the ZCard method.
		ZCard []struct {
			// Key is the key argument value.
			Key string
		}
		// ZCount holds details about calls to the ZCount method.
		ZCount []struct {
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZIncr holds details about calls to the ZIncr method.
		ZIncr []struct {
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member redis.Z
		}
		// ZIncrBy holds details about calls to the ZIncrBy method.
		ZIncrBy []struct {
			// Key is the key argument value.
			Key string
			// Increment is the increment argument value.
			Increment float64
			// Member is the member argument value.
			Member string
		}
		// ZIncrNX holds details about calls to the ZIncrNX method.
		ZIncrNX []struct {
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member redis.Z
		}
		// ZIncrXX holds details about calls to the ZIncrXX method.
		ZIncrXX []struct {
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member redis.Z
		}
		// ZInterStore holds details about calls to the ZInterStore method.
		ZInterStore []struct {
			// Destination is the destination argument value.
			Destination string
			// Store is the store argument value.
			Store redis.ZStore
			// Keys is the keys argument value.
			Keys []string
		}
		// ZLexCount holds details about calls to the ZLexCount method.
		ZLexCount []struct {
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZPopMax holds details about calls to the ZPopMax method.
		ZPopMax []struct {
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count []int64
		}
		// ZPopMin holds details about calls to the ZPopMin method.
		ZPopMin []struct {
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count []int64
		}
		// ZRange holds details about calls to the ZRange method.
		ZRange []struct {
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRangeByLex holds details about calls to the ZRangeByLex method.
		ZRangeByLex []struct {
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt redis.ZRangeBy
		}
		// ZRangeByScore holds details about calls to the ZRangeByScore method.
		ZRangeByScore []struct {
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt redis.ZRangeBy
		}
		// ZRangeByScoreWithScores holds details about calls to the ZRangeByScoreWithScores method.
		ZRangeByScoreWithScores []struct {
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt redis.ZRangeBy
		}
		// ZRangeWithScores holds details about calls to the ZRangeWithScores method.
		ZRangeWithScores []struct {
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRank holds details about calls to the ZRank method.
		ZRank []struct {
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZRem holds details about calls to the ZRem method.
		ZRem []struct {
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// ZRemRangeByLex holds details about calls to the ZRemRangeByLex method.
		ZRemRangeByLex []struct {
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZRemRangeByRank holds details about calls to the ZRemRangeByRank method.
		ZRemRangeByRank []struct {
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRemRangeByScore holds details about calls to the ZRemRangeByScore method.
		ZRemRangeByScore []struct {
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZRevRange holds details about calls to the ZRevRange method.
		ZRevRange []struct {
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRevRangeByLex holds details about calls to the ZRevRangeByLex method.
		ZRevRangeByLex []struct {
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt redis.ZRangeBy
		}
		// ZRevRangeByScore holds details about calls to the ZRevRangeByScore method.
		ZRevRangeByScore []struct {
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt redis.ZRangeBy
		}
		// ZRevRangeByScoreWithScores holds details about calls to the ZRevRangeByScoreWithScores method.
		ZRevRangeByScoreWithScores []struct {
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt redis.ZRangeBy
		}
		// ZRevRangeWithScores holds details about calls to the ZRevRangeWithScores method.
		ZRevRangeWithScores []struct {
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRevRank holds details about calls to the ZRevRank method.
		ZRevRank []struct {
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZScan holds details about calls to the ZScan method.
		ZScan []struct {
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// ZScore holds details about calls to the ZScore method.
		ZScore []struct {
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZUnionStore holds details about calls to the ZUnionStore method.
		ZUnionStore []struct {
			// Dest is the dest argument value.
			Dest string
			// Store is the store argument value.
			Store redis.ZStore
			// Keys is the keys argument value.
			Keys []string
		}
	}
}

// Append calls AppendFunc.
func (mock *UniversalClientMock) Append(key string, value string) *redis.IntCmd {
	if mock.AppendFunc == nil {
		panic("UniversalClientMock.AppendFunc: method is nil but UniversalClient.Append was just called")
	}
	callInfo := struct {
		Key   string
		Value string
	}{
		Key:   key,
		Value: value,
	}
	lockUniversalClientMockAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	lockUniversalClientMockAppend.Unlock()
	return mock.AppendFunc(key, value)
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//     len(mockedUniversalClient.AppendCalls())
func (mock *UniversalClientMock) AppendCalls() []struct {
	Key   string
	Value string
} {
	var calls []struct {
		Key   string
		Value string
	}
	lockUniversalClientMockAppend.RLock()
	calls = mock.calls.Append
	lockUniversalClientMockAppend.RUnlock()
	return calls
}

// BLPop calls BLPopFunc.
func (mock *UniversalClientMock) BLPop(timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	if mock.BLPopFunc == nil {
		panic("UniversalClientMock.BLPopFunc: method is nil but UniversalClient.BLPop was just called")
	}
	callInfo := struct {
		Timeout time.Duration
		Keys    []string
	}{
		Timeout: timeout,
		Keys:    keys,
	}
	lockUniversalClientMockBLPop.Lock()
	mock.calls.BLPop = append(mock.calls.BLPop, callInfo)
	lockUniversalClientMockBLPop.Unlock()
	return mock.BLPopFunc(timeout, keys...)
}

// BLPopCalls gets all the calls that were made to BLPop.
// Check the length with:
//     len(mockedUniversalClient.BLPopCalls())
func (mock *UniversalClientMock) BLPopCalls() []struct {
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Timeout time.Duration
		Keys    []string
	}
	lockUniversalClientMockBLPop.RLock()
	calls = mock.calls.BLPop
	lockUniversalClientMockBLPop.RUnlock()
	return calls
}

// BRPop calls BRPopFunc.
func (mock *UniversalClientMock) BRPop(timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	if mock.BRPopFunc == nil {
		panic("UniversalClientMock.BRPopFunc: method is nil but UniversalClient.BRPop was just called")
	}
	callInfo := struct {
		Timeout time.Duration
		Keys    []string
	}{
		Timeout: timeout,
		Keys:    keys,
	}
	lockUniversalClientMockBRPop.Lock()
	mock.calls.BRPop = append(mock.calls.BRPop, callInfo)
	lockUniversalClientMockBRPop.Unlock()
	return mock.BRPopFunc(timeout, keys...)
}

// BRPopCalls gets all the calls that were made to BRPop.
// Check the length with:
//     len(mockedUniversalClient.BRPopCalls())
func (mock *UniversalClientMock) BRPopCalls() []struct {
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Timeout time.Duration
		Keys    []string
	}
	lockUniversalClientMockBRPop.RLock()
	calls = mock.calls.BRPop
	lockUniversalClientMockBRPop.RUnlock()
	return calls
}

// BRPopLPush calls BRPopLPushFunc.
func (mock *UniversalClientMock) BRPopLPush(source string, destination string, timeout time.Duration) *redis.StringCmd {
	if mock.BRPopLPushFunc == nil {
		panic("UniversalClientMock.BRPopLPushFunc: method is nil but UniversalClient.BRPopLPush was just called")
	}
	callInfo := struct {
		Source      string
		Destination string
		Timeout     time.Duration
	}{
		Source:      source,
		Destination: destination,
		Timeout:     timeout,
	}
	lockUniversalClientMockBRPopLPush.Lock()
	mock.calls.BRPopLPush = append(mock.calls.BRPopLPush, callInfo)
	lockUniversalClientMockBRPopLPush.Unlock()
	return mock.BRPopLPushFunc(source, destination, timeout)
}

// BRPopLPushCalls gets all the calls that were made to BRPopLPush.
// Check the length with:
//     len(mockedUniversalClient.BRPopLPushCalls())
func (mock *UniversalClientMock) BRPopLPushCalls() []struct {
	Source      string
	Destination string
	Timeout     time.Duration
} {
	var calls []struct {
		Source      string
		Destination string
		Timeout     time.Duration
	}
	lockUniversalClientMockBRPopLPush.RLock()
	calls = mock.calls.BRPopLPush
	lockUniversalClientMockBRPopLPush.RUnlock()
	return calls
}

// BZPopMax calls BZPopMaxFunc.
func (mock *UniversalClientMock) BZPopMax(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	if mock.BZPopMaxFunc == nil {
		panic("UniversalClientMock.BZPopMaxFunc: method is nil but UniversalClient.BZPopMax was just called")
	}
	callInfo := struct {
		Timeout time.Duration
		Keys    []string
	}{
		Timeout: timeout,
		Keys:    keys,
	}
	lockUniversalClientMockBZPopMax.Lock()
	mock.calls.BZPopMax = append(mock.calls.BZPopMax, callInfo)
	lockUniversalClientMockBZPopMax.Unlock()
	return mock.BZPopMaxFunc(timeout, keys...)
}

// BZPopMaxCalls gets all the calls that were made to BZPopMax.
// Check the length with:
//     len(mockedUniversalClient.BZPopMaxCalls())
func (mock *UniversalClientMock) BZPopMaxCalls() []struct {
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Timeout time.Duration
		Keys    []string
	}
	lockUniversalClientMockBZPopMax.RLock()
	calls = mock.calls.BZPopMax
	lockUniversalClientMockBZPopMax.RUnlock()
	return calls
}

// BZPopMin calls BZPopMinFunc.
func (mock *UniversalClientMock) BZPopMin(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	if mock.BZPopMinFunc == nil {
		panic("UniversalClientMock.BZPopMinFunc: method is nil but UniversalClient.BZPopMin was just called")
	}
	callInfo := struct {
		Timeout time.Duration
		Keys    []string
	}{
		Timeout: timeout,
		Keys:    keys,
	}
	lockUniversalClientMockBZPopMin.Lock()
	mock.calls.BZPopMin = append(mock.calls.BZPopMin, callInfo)
	lockUniversalClientMockBZPopMin.Unlock()
	return mock.BZPopMinFunc(timeout, keys...)
}

// BZPopMinCalls gets all the calls that were made to BZPopMin.
// Check the length with:
//     len(mockedUniversalClient.BZPopMinCalls())
func (mock *UniversalClientMock) BZPopMinCalls() []struct {
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Timeout time.Duration
		Keys    []string
	}
	lockUniversalClientMockBZPopMin.RLock()
	calls = mock.calls.BZPopMin
	lockUniversalClientMockBZPopMin.RUnlock()
	return calls
}

// BgRewriteAOF calls BgRewriteAOFFunc.
func (mock *UniversalClientMock) BgRewriteAOF() *redis.StatusCmd {
	if mock.BgRewriteAOFFunc == nil {
		panic("UniversalClientMock.BgRewriteAOFFunc: method is nil but UniversalClient.BgRewriteAOF was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockBgRewriteAOF.Lock()
	mock.calls.BgRewriteAOF = append(mock.calls.BgRewriteAOF, callInfo)
	lockUniversalClientMockBgRewriteAOF.Unlock()
	return mock.BgRewriteAOFFunc()
}

// BgRewriteAOFCalls gets all the calls that were made to BgRewriteAOF.
// Check the length with:
//     len(mockedUniversalClient.BgRewriteAOFCalls())
func (mock *UniversalClientMock) BgRewriteAOFCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockBgRewriteAOF.RLock()
	calls = mock.calls.BgRewriteAOF
	lockUniversalClientMockBgRewriteAOF.RUnlock()
	return calls
}

// BgSave calls BgSaveFunc.
func (mock *UniversalClientMock) BgSave() *redis.StatusCmd {
	if mock.BgSaveFunc == nil {
		panic("UniversalClientMock.BgSaveFunc: method is nil but UniversalClient.BgSave was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockBgSave.Lock()
	mock.calls.BgSave = append(mock.calls.BgSave, callInfo)
	lockUniversalClientMockBgSave.Unlock()
	return mock.BgSaveFunc()
}

// BgSaveCalls gets all the calls that were made to BgSave.
// Check the length with:
//     len(mockedUniversalClient.BgSaveCalls())
func (mock *UniversalClientMock) BgSaveCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockBgSave.RLock()
	calls = mock.calls.BgSave
	lockUniversalClientMockBgSave.RUnlock()
	return calls
}

// BitCount calls BitCountFunc.
func (mock *UniversalClientMock) BitCount(key string, bitCount *redis.BitCount) *redis.IntCmd {
	if mock.BitCountFunc == nil {
		panic("UniversalClientMock.BitCountFunc: method is nil but UniversalClient.BitCount was just called")
	}
	callInfo := struct {
		Key      string
		BitCount *redis.BitCount
	}{
		Key:      key,
		BitCount: bitCount,
	}
	lockUniversalClientMockBitCount.Lock()
	mock.calls.BitCount = append(mock.calls.BitCount, callInfo)
	lockUniversalClientMockBitCount.Unlock()
	return mock.BitCountFunc(key, bitCount)
}

// BitCountCalls gets all the calls that were made to BitCount.
// Check the length with:
//     len(mockedUniversalClient.BitCountCalls())
func (mock *UniversalClientMock) BitCountCalls() []struct {
	Key      string
	BitCount *redis.BitCount
} {
	var calls []struct {
		Key      string
		BitCount *redis.BitCount
	}
	lockUniversalClientMockBitCount.RLock()
	calls = mock.calls.BitCount
	lockUniversalClientMockBitCount.RUnlock()
	return calls
}

// BitOpAnd calls BitOpAndFunc.
func (mock *UniversalClientMock) BitOpAnd(destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpAndFunc == nil {
		panic("UniversalClientMock.BitOpAndFunc: method is nil but UniversalClient.BitOpAnd was just called")
	}
	callInfo := struct {
		DestKey string
		Keys    []string
	}{
		DestKey: destKey,
		Keys:    keys,
	}
	lockUniversalClientMockBitOpAnd.Lock()
	mock.calls.BitOpAnd = append(mock.calls.BitOpAnd, callInfo)
	lockUniversalClientMockBitOpAnd.Unlock()
	return mock.BitOpAndFunc(destKey, keys...)
}

// BitOpAndCalls gets all the calls that were made to BitOpAnd.
// Check the length with:
//     len(mockedUniversalClient.BitOpAndCalls())
func (mock *UniversalClientMock) BitOpAndCalls() []struct {
	DestKey string
	Keys    []string
} {
	var calls []struct {
		DestKey string
		Keys    []string
	}
	lockUniversalClientMockBitOpAnd.RLock()
	calls = mock.calls.BitOpAnd
	lockUniversalClientMockBitOpAnd.RUnlock()
	return calls
}

// BitOpNot calls BitOpNotFunc.
func (mock *UniversalClientMock) BitOpNot(destKey string, key string) *redis.IntCmd {
	if mock.BitOpNotFunc == nil {
		panic("UniversalClientMock.BitOpNotFunc: method is nil but UniversalClient.BitOpNot was just called")
	}
	callInfo := struct {
		DestKey string
		Key     string
	}{
		DestKey: destKey,
		Key:     key,
	}
	lockUniversalClientMockBitOpNot.Lock()
	mock.calls.BitOpNot = append(mock.calls.BitOpNot, callInfo)
	lockUniversalClientMockBitOpNot.Unlock()
	return mock.BitOpNotFunc(destKey, key)
}

// BitOpNotCalls gets all the calls that were made to BitOpNot.
// Check the length with:
//     len(mockedUniversalClient.BitOpNotCalls())
func (mock *UniversalClientMock) BitOpNotCalls() []struct {
	DestKey string
	Key     string
} {
	var calls []struct {
		DestKey string
		Key     string
	}
	lockUniversalClientMockBitOpNot.RLock()
	calls = mock.calls.BitOpNot
	lockUniversalClientMockBitOpNot.RUnlock()
	return calls
}

// BitOpOr calls BitOpOrFunc.
func (mock *UniversalClientMock) BitOpOr(destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpOrFunc == nil {
		panic("UniversalClientMock.BitOpOrFunc: method is nil but UniversalClient.BitOpOr was just called")
	}
	callInfo := struct {
		DestKey string
		Keys    []string
	}{
		DestKey: destKey,
		Keys:    keys,
	}
	lockUniversalClientMockBitOpOr.Lock()
	mock.calls.BitOpOr = append(mock.calls.BitOpOr, callInfo)
	lockUniversalClientMockBitOpOr.Unlock()
	return mock.BitOpOrFunc(destKey, keys...)
}

// BitOpOrCalls gets all the calls that were made to BitOpOr.
// Check the length with:
//     len(mockedUniversalClient.BitOpOrCalls())
func (mock *UniversalClientMock) BitOpOrCalls() []struct {
	DestKey string
	Keys    []string
} {
	var calls []struct {
		DestKey string
		Keys    []string
	}
	lockUniversalClientMockBitOpOr.RLock()
	calls = mock.calls.BitOpOr
	lockUniversalClientMockBitOpOr.RUnlock()
	return calls
}

// BitOpXor calls BitOpXorFunc.
func (mock *UniversalClientMock) BitOpXor(destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpXorFunc == nil {
		panic("UniversalClientMock.BitOpXorFunc: method is nil but UniversalClient.BitOpXor was just called")
	}
	callInfo := struct {
		DestKey string
		Keys    []string
	}{
		DestKey: destKey,
		Keys:    keys,
	}
	lockUniversalClientMockBitOpXor.Lock()
	mock.calls.BitOpXor = append(mock.calls.BitOpXor, callInfo)
	lockUniversalClientMockBitOpXor.Unlock()
	return mock.BitOpXorFunc(destKey, keys...)
}

// BitOpXorCalls gets all the calls that were made to BitOpXor.
// Check the length with:
//     len(mockedUniversalClient.BitOpXorCalls())
func (mock *UniversalClientMock) BitOpXorCalls() []struct {
	DestKey string
	Keys    []string
} {
	var calls []struct {
		DestKey string
		Keys    []string
	}
	lockUniversalClientMockBitOpXor.RLock()
	calls = mock.calls.BitOpXor
	lockUniversalClientMockBitOpXor.RUnlock()
	return calls
}

// BitPos calls BitPosFunc.
func (mock *UniversalClientMock) BitPos(key string, bit int64, pos ...int64) *redis.IntCmd {
	if mock.BitPosFunc == nil {
		panic("UniversalClientMock.BitPosFunc: method is nil but UniversalClient.BitPos was just called")
	}
	callInfo := struct {
		Key string
		Bit int64
		Pos []int64
	}{
		Key: key,
		Bit: bit,
		Pos: pos,
	}
	lockUniversalClientMockBitPos.Lock()
	mock.calls.BitPos = append(mock.calls.BitPos, callInfo)
	lockUniversalClientMockBitPos.Unlock()
	return mock.BitPosFunc(key, bit, pos...)
}

// BitPosCalls gets all the calls that were made to BitPos.
// Check the length with:
//     len(mockedUniversalClient.BitPosCalls())
func (mock *UniversalClientMock) BitPosCalls() []struct {
	Key string
	Bit int64
	Pos []int64
} {
	var calls []struct {
		Key string
		Bit int64
		Pos []int64
	}
	lockUniversalClientMockBitPos.RLock()
	calls = mock.calls.BitPos
	lockUniversalClientMockBitPos.RUnlock()
	return calls
}

// ClientGetName calls ClientGetNameFunc.
func (mock *UniversalClientMock) ClientGetName() *redis.StringCmd {
	if mock.ClientGetNameFunc == nil {
		panic("UniversalClientMock.ClientGetNameFunc: method is nil but UniversalClient.ClientGetName was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClientGetName.Lock()
	mock.calls.ClientGetName = append(mock.calls.ClientGetName, callInfo)
	lockUniversalClientMockClientGetName.Unlock()
	return mock.ClientGetNameFunc()
}

// ClientGetNameCalls gets all the calls that were made to ClientGetName.
// Check the length with:
//     len(mockedUniversalClient.ClientGetNameCalls())
func (mock *UniversalClientMock) ClientGetNameCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClientGetName.RLock()
	calls = mock.calls.ClientGetName
	lockUniversalClientMockClientGetName.RUnlock()
	return calls
}

// ClientID calls ClientIDFunc.
func (mock *UniversalClientMock) ClientID() *redis.IntCmd {
	if mock.ClientIDFunc == nil {
		panic("UniversalClientMock.ClientIDFunc: method is nil but UniversalClient.ClientID was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClientID.Lock()
	mock.calls.ClientID = append(mock.calls.ClientID, callInfo)
	lockUniversalClientMockClientID.Unlock()
	return mock.ClientIDFunc()
}

// ClientIDCalls gets all the calls that were made to ClientID.
// Check the length with:
//     len(mockedUniversalClient.ClientIDCalls())
func (mock *UniversalClientMock) ClientIDCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClientID.RLock()
	calls = mock.calls.ClientID
	lockUniversalClientMockClientID.RUnlock()
	return calls
}

// ClientKill calls ClientKillFunc.
func (mock *UniversalClientMock) ClientKill(ipPort string) *redis.StatusCmd {
	if mock.ClientKillFunc == nil {
		panic("UniversalClientMock.ClientKillFunc: method is nil but UniversalClient.ClientKill was just called")
	}
	callInfo := struct {
		IpPort string
	}{
		IpPort: ipPort,
	}
	lockUniversalClientMockClientKill.Lock()
	mock.calls.ClientKill = append(mock.calls.ClientKill, callInfo)
	lockUniversalClientMockClientKill.Unlock()
	return mock.ClientKillFunc(ipPort)
}

// ClientKillCalls gets all the calls that were made to ClientKill.
// Check the length with:
//     len(mockedUniversalClient.ClientKillCalls())
func (mock *UniversalClientMock) ClientKillCalls() []struct {
	IpPort string
} {
	var calls []struct {
		IpPort string
	}
	lockUniversalClientMockClientKill.RLock()
	calls = mock.calls.ClientKill
	lockUniversalClientMockClientKill.RUnlock()
	return calls
}

// ClientKillByFilter calls ClientKillByFilterFunc.
func (mock *UniversalClientMock) ClientKillByFilter(keys ...string) *redis.IntCmd {
	if mock.ClientKillByFilterFunc == nil {
		panic("UniversalClientMock.ClientKillByFilterFunc: method is nil but UniversalClient.ClientKillByFilter was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockClientKillByFilter.Lock()
	mock.calls.ClientKillByFilter = append(mock.calls.ClientKillByFilter, callInfo)
	lockUniversalClientMockClientKillByFilter.Unlock()
	return mock.ClientKillByFilterFunc(keys...)
}

// ClientKillByFilterCalls gets all the calls that were made to ClientKillByFilter.
// Check the length with:
//     len(mockedUniversalClient.ClientKillByFilterCalls())
func (mock *UniversalClientMock) ClientKillByFilterCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockClientKillByFilter.RLock()
	calls = mock.calls.ClientKillByFilter
	lockUniversalClientMockClientKillByFilter.RUnlock()
	return calls
}

// ClientList calls ClientListFunc.
func (mock *UniversalClientMock) ClientList() *redis.StringCmd {
	if mock.ClientListFunc == nil {
		panic("UniversalClientMock.ClientListFunc: method is nil but UniversalClient.ClientList was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClientList.Lock()
	mock.calls.ClientList = append(mock.calls.ClientList, callInfo)
	lockUniversalClientMockClientList.Unlock()
	return mock.ClientListFunc()
}

// ClientListCalls gets all the calls that were made to ClientList.
// Check the length with:
//     len(mockedUniversalClient.ClientListCalls())
func (mock *UniversalClientMock) ClientListCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClientList.RLock()
	calls = mock.calls.ClientList
	lockUniversalClientMockClientList.RUnlock()
	return calls
}

// ClientPause calls ClientPauseFunc.
func (mock *UniversalClientMock) ClientPause(dur time.Duration) *redis.BoolCmd {
	if mock.ClientPauseFunc == nil {
		panic("UniversalClientMock.ClientPauseFunc: method is nil but UniversalClient.ClientPause was just called")
	}
	callInfo := struct {
		Dur time.Duration
	}{
		Dur: dur,
	}
	lockUniversalClientMockClientPause.Lock()
	mock.calls.ClientPause = append(mock.calls.ClientPause, callInfo)
	lockUniversalClientMockClientPause.Unlock()
	return mock.ClientPauseFunc(dur)
}

// ClientPauseCalls gets all the calls that were made to ClientPause.
// Check the length with:
//     len(mockedUniversalClient.ClientPauseCalls())
func (mock *UniversalClientMock) ClientPauseCalls() []struct {
	Dur time.Duration
} {
	var calls []struct {
		Dur time.Duration
	}
	lockUniversalClientMockClientPause.RLock()
	calls = mock.calls.ClientPause
	lockUniversalClientMockClientPause.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *UniversalClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("UniversalClientMock.CloseFunc: method is nil but UniversalClient.Close was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockUniversalClientMockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedUniversalClient.CloseCalls())
func (mock *UniversalClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClose.RLock()
	calls = mock.calls.Close
	lockUniversalClientMockClose.RUnlock()
	return calls
}

// ClusterAddSlots calls ClusterAddSlotsFunc.
func (mock *UniversalClientMock) ClusterAddSlots(slots ...int) *redis.StatusCmd {
	if mock.ClusterAddSlotsFunc == nil {
		panic("UniversalClientMock.ClusterAddSlotsFunc: method is nil but UniversalClient.ClusterAddSlots was just called")
	}
	callInfo := struct {
		Slots []int
	}{
		Slots: slots,
	}
	lockUniversalClientMockClusterAddSlots.Lock()
	mock.calls.ClusterAddSlots = append(mock.calls.ClusterAddSlots, callInfo)
	lockUniversalClientMockClusterAddSlots.Unlock()
	return mock.ClusterAddSlotsFunc(slots...)
}

// ClusterAddSlotsCalls gets all the calls that were made to ClusterAddSlots.
// Check the length with:
//     len(mockedUniversalClient.ClusterAddSlotsCalls())
func (mock *UniversalClientMock) ClusterAddSlotsCalls() []struct {
	Slots []int
} {
	var calls []struct {
		Slots []int
	}
	lockUniversalClientMockClusterAddSlots.RLock()
	calls = mock.calls.ClusterAddSlots
	lockUniversalClientMockClusterAddSlots.RUnlock()
	return calls
}

// ClusterAddSlotsRange calls ClusterAddSlotsRangeFunc.
func (mock *UniversalClientMock) ClusterAddSlotsRange(min int, max int) *redis.StatusCmd {
	if mock.ClusterAddSlotsRangeFunc == nil {
		panic("UniversalClientMock.ClusterAddSlotsRangeFunc: method is nil but UniversalClient.ClusterAddSlotsRange was just called")
	}
	callInfo := struct {
		Min int
		Max int
	}{
		Min: min,
		Max: max,
	}
	lockUniversalClientMockClusterAddSlotsRange.Lock()
	mock.calls.ClusterAddSlotsRange = append(mock.calls.ClusterAddSlotsRange, callInfo)
	lockUniversalClientMockClusterAddSlotsRange.Unlock()
	return mock.ClusterAddSlotsRangeFunc(min, max)
}

// ClusterAddSlotsRangeCalls gets all the calls that were made to ClusterAddSlotsRange.
// Check the length with:
//     len(mockedUniversalClient.ClusterAddSlotsRangeCalls())
func (mock *UniversalClientMock) ClusterAddSlotsRangeCalls() []struct {
	Min int
	Max int
} {
	var calls []struct {
		Min int
		Max int
	}
	lockUniversalClientMockClusterAddSlotsRange.RLock()
	calls = mock.calls.ClusterAddSlotsRange
	lockUniversalClientMockClusterAddSlotsRange.RUnlock()
	return calls
}

// ClusterCountFailureReports calls ClusterCountFailureReportsFunc.
func (mock *UniversalClientMock) ClusterCountFailureReports(nodeID string) *redis.IntCmd {
	if mock.ClusterCountFailureReportsFunc == nil {
		panic("UniversalClientMock.ClusterCountFailureReportsFunc: method is nil but UniversalClient.ClusterCountFailureReports was just called")
	}
	callInfo := struct {
		NodeID string
	}{
		NodeID: nodeID,
	}
	lockUniversalClientMockClusterCountFailureReports.Lock()
	mock.calls.ClusterCountFailureReports = append(mock.calls.ClusterCountFailureReports, callInfo)
	lockUniversalClientMockClusterCountFailureReports.Unlock()
	return mock.ClusterCountFailureReportsFunc(nodeID)
}

// ClusterCountFailureReportsCalls gets all the calls that were made to ClusterCountFailureReports.
// Check the length with:
//     len(mockedUniversalClient.ClusterCountFailureReportsCalls())
func (mock *UniversalClientMock) ClusterCountFailureReportsCalls() []struct {
	NodeID string
} {
	var calls []struct {
		NodeID string
	}
	lockUniversalClientMockClusterCountFailureReports.RLock()
	calls = mock.calls.ClusterCountFailureReports
	lockUniversalClientMockClusterCountFailureReports.RUnlock()
	return calls
}

// ClusterCountKeysInSlot calls ClusterCountKeysInSlotFunc.
func (mock *UniversalClientMock) ClusterCountKeysInSlot(slot int) *redis.IntCmd {
	if mock.ClusterCountKeysInSlotFunc == nil {
		panic("UniversalClientMock.ClusterCountKeysInSlotFunc: method is nil but UniversalClient.ClusterCountKeysInSlot was just called")
	}
	callInfo := struct {
		Slot int
	}{
		Slot: slot,
	}
	lockUniversalClientMockClusterCountKeysInSlot.Lock()
	mock.calls.ClusterCountKeysInSlot = append(mock.calls.ClusterCountKeysInSlot, callInfo)
	lockUniversalClientMockClusterCountKeysInSlot.Unlock()
	return mock.ClusterCountKeysInSlotFunc(slot)
}

// ClusterCountKeysInSlotCalls gets all the calls that were made to ClusterCountKeysInSlot.
// Check the length with:
//     len(mockedUniversalClient.ClusterCountKeysInSlotCalls())
func (mock *UniversalClientMock) ClusterCountKeysInSlotCalls() []struct {
	Slot int
} {
	var calls []struct {
		Slot int
	}
	lockUniversalClientMockClusterCountKeysInSlot.RLock()
	calls = mock.calls.ClusterCountKeysInSlot
	lockUniversalClientMockClusterCountKeysInSlot.RUnlock()
	return calls
}

// ClusterDelSlots calls ClusterDelSlotsFunc.
func (mock *UniversalClientMock) ClusterDelSlots(slots ...int) *redis.StatusCmd {
	if mock.ClusterDelSlotsFunc == nil {
		panic("UniversalClientMock.ClusterDelSlotsFunc: method is nil but UniversalClient.ClusterDelSlots was just called")
	}
	callInfo := struct {
		Slots []int
	}{
		Slots: slots,
	}
	lockUniversalClientMockClusterDelSlots.Lock()
	mock.calls.ClusterDelSlots = append(mock.calls.ClusterDelSlots, callInfo)
	lockUniversalClientMockClusterDelSlots.Unlock()
	return mock.ClusterDelSlotsFunc(slots...)
}

// ClusterDelSlotsCalls gets all the calls that were made to ClusterDelSlots.
// Check the length with:
//     len(mockedUniversalClient.ClusterDelSlotsCalls())
func (mock *UniversalClientMock) ClusterDelSlotsCalls() []struct {
	Slots []int
} {
	var calls []struct {
		Slots []int
	}
	lockUniversalClientMockClusterDelSlots.RLock()
	calls = mock.calls.ClusterDelSlots
	lockUniversalClientMockClusterDelSlots.RUnlock()
	return calls
}

// ClusterDelSlotsRange calls ClusterDelSlotsRangeFunc.
func (mock *UniversalClientMock) ClusterDelSlotsRange(min int, max int) *redis.StatusCmd {
	if mock.ClusterDelSlotsRangeFunc == nil {
		panic("UniversalClientMock.ClusterDelSlotsRangeFunc: method is nil but UniversalClient.ClusterDelSlotsRange was just called")
	}
	callInfo := struct {
		Min int
		Max int
	}{
		Min: min,
		Max: max,
	}
	lockUniversalClientMockClusterDelSlotsRange.Lock()
	mock.calls.ClusterDelSlotsRange = append(mock.calls.ClusterDelSlotsRange, callInfo)
	lockUniversalClientMockClusterDelSlotsRange.Unlock()
	return mock.ClusterDelSlotsRangeFunc(min, max)
}

// ClusterDelSlotsRangeCalls gets all the calls that were made to ClusterDelSlotsRange.
// Check the length with:
//     len(mockedUniversalClient.ClusterDelSlotsRangeCalls())
func (mock *UniversalClientMock) ClusterDelSlotsRangeCalls() []struct {
	Min int
	Max int
} {
	var calls []struct {
		Min int
		Max int
	}
	lockUniversalClientMockClusterDelSlotsRange.RLock()
	calls = mock.calls.ClusterDelSlotsRange
	lockUniversalClientMockClusterDelSlotsRange.RUnlock()
	return calls
}

// ClusterFailover calls ClusterFailoverFunc.
func (mock *UniversalClientMock) ClusterFailover() *redis.StatusCmd {
	if mock.ClusterFailoverFunc == nil {
		panic("UniversalClientMock.ClusterFailoverFunc: method is nil but UniversalClient.ClusterFailover was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClusterFailover.Lock()
	mock.calls.ClusterFailover = append(mock.calls.ClusterFailover, callInfo)
	lockUniversalClientMockClusterFailover.Unlock()
	return mock.ClusterFailoverFunc()
}

// ClusterFailoverCalls gets all the calls that were made to ClusterFailover.
// Check the length with:
//     len(mockedUniversalClient.ClusterFailoverCalls())
func (mock *UniversalClientMock) ClusterFailoverCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClusterFailover.RLock()
	calls = mock.calls.ClusterFailover
	lockUniversalClientMockClusterFailover.RUnlock()
	return calls
}

// ClusterForget calls ClusterForgetFunc.
func (mock *UniversalClientMock) ClusterForget(nodeID string) *redis.StatusCmd {
	if mock.ClusterForgetFunc == nil {
		panic("UniversalClientMock.ClusterForgetFunc: method is nil but UniversalClient.ClusterForget was just called")
	}
	callInfo := struct {
		NodeID string
	}{
		NodeID: nodeID,
	}
	lockUniversalClientMockClusterForget.Lock()
	mock.calls.ClusterForget = append(mock.calls.ClusterForget, callInfo)
	lockUniversalClientMockClusterForget.Unlock()
	return mock.ClusterForgetFunc(nodeID)
}

// ClusterForgetCalls gets all the calls that were made to ClusterForget.
// Check the length with:
//     len(mockedUniversalClient.ClusterForgetCalls())
func (mock *UniversalClientMock) ClusterForgetCalls() []struct {
	NodeID string
} {
	var calls []struct {
		NodeID string
	}
	lockUniversalClientMockClusterForget.RLock()
	calls = mock.calls.ClusterForget
	lockUniversalClientMockClusterForget.RUnlock()
	return calls
}

// ClusterGetKeysInSlot calls ClusterGetKeysInSlotFunc.
func (mock *UniversalClientMock) ClusterGetKeysInSlot(slot int, count int) *redis.StringSliceCmd {
	if mock.ClusterGetKeysInSlotFunc == nil {
		panic("UniversalClientMock.ClusterGetKeysInSlotFunc: method is nil but UniversalClient.ClusterGetKeysInSlot was just called")
	}
	callInfo := struct {
		Slot  int
		Count int
	}{
		Slot:  slot,
		Count: count,
	}
	lockUniversalClientMockClusterGetKeysInSlot.Lock()
	mock.calls.ClusterGetKeysInSlot = append(mock.calls.ClusterGetKeysInSlot, callInfo)
	lockUniversalClientMockClusterGetKeysInSlot.Unlock()
	return mock.ClusterGetKeysInSlotFunc(slot, count)
}

// ClusterGetKeysInSlotCalls gets all the calls that were made to ClusterGetKeysInSlot.
// Check the length with:
//     len(mockedUniversalClient.ClusterGetKeysInSlotCalls())
func (mock *UniversalClientMock) ClusterGetKeysInSlotCalls() []struct {
	Slot  int
	Count int
} {
	var calls []struct {
		Slot  int
		Count int
	}
	lockUniversalClientMockClusterGetKeysInSlot.RLock()
	calls = mock.calls.ClusterGetKeysInSlot
	lockUniversalClientMockClusterGetKeysInSlot.RUnlock()
	return calls
}

// ClusterInfo calls ClusterInfoFunc.
func (mock *UniversalClientMock) ClusterInfo() *redis.StringCmd {
	if mock.ClusterInfoFunc == nil {
		panic("UniversalClientMock.ClusterInfoFunc: method is nil but UniversalClient.ClusterInfo was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClusterInfo.Lock()
	mock.calls.ClusterInfo = append(mock.calls.ClusterInfo, callInfo)
	lockUniversalClientMockClusterInfo.Unlock()
	return mock.ClusterInfoFunc()
}

// ClusterInfoCalls gets all the calls that were made to ClusterInfo.
// Check the length with:
//     len(mockedUniversalClient.ClusterInfoCalls())
func (mock *UniversalClientMock) ClusterInfoCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClusterInfo.RLock()
	calls = mock.calls.ClusterInfo
	lockUniversalClientMockClusterInfo.RUnlock()
	return calls
}

// ClusterKeySlot calls ClusterKeySlotFunc.
func (mock *UniversalClientMock) ClusterKeySlot(key string) *redis.IntCmd {
	if mock.ClusterKeySlotFunc == nil {
		panic("UniversalClientMock.ClusterKeySlotFunc: method is nil but UniversalClient.ClusterKeySlot was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockClusterKeySlot.Lock()
	mock.calls.ClusterKeySlot = append(mock.calls.ClusterKeySlot, callInfo)
	lockUniversalClientMockClusterKeySlot.Unlock()
	return mock.ClusterKeySlotFunc(key)
}

// ClusterKeySlotCalls gets all the calls that were made to ClusterKeySlot.
// Check the length with:
//     len(mockedUniversalClient.ClusterKeySlotCalls())
func (mock *UniversalClientMock) ClusterKeySlotCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockClusterKeySlot.RLock()
	calls = mock.calls.ClusterKeySlot
	lockUniversalClientMockClusterKeySlot.RUnlock()
	return calls
}

// ClusterMeet calls ClusterMeetFunc.
func (mock *UniversalClientMock) ClusterMeet(host string, port string) *redis.StatusCmd {
	if mock.ClusterMeetFunc == nil {
		panic("UniversalClientMock.ClusterMeetFunc: method is nil but UniversalClient.ClusterMeet was just called")
	}
	callInfo := struct {
		Host string
		Port string
	}{
		Host: host,
		Port: port,
	}
	lockUniversalClientMockClusterMeet.Lock()
	mock.calls.ClusterMeet = append(mock.calls.ClusterMeet, callInfo)
	lockUniversalClientMockClusterMeet.Unlock()
	return mock.ClusterMeetFunc(host, port)
}

// ClusterMeetCalls gets all the calls that were made to ClusterMeet.
// Check the length with:
//     len(mockedUniversalClient.ClusterMeetCalls())
func (mock *UniversalClientMock) ClusterMeetCalls() []struct {
	Host string
	Port string
} {
	var calls []struct {
		Host string
		Port string
	}
	lockUniversalClientMockClusterMeet.RLock()
	calls = mock.calls.ClusterMeet
	lockUniversalClientMockClusterMeet.RUnlock()
	return calls
}

// ClusterNodes calls ClusterNodesFunc.
func (mock *UniversalClientMock) ClusterNodes() *redis.StringCmd {
	if mock.ClusterNodesFunc == nil {
		panic("UniversalClientMock.ClusterNodesFunc: method is nil but UniversalClient.ClusterNodes was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClusterNodes.Lock()
	mock.calls.ClusterNodes = append(mock.calls.ClusterNodes, callInfo)
	lockUniversalClientMockClusterNodes.Unlock()
	return mock.ClusterNodesFunc()
}

// ClusterNodesCalls gets all the calls that were made to ClusterNodes.
// Check the length with:
//     len(mockedUniversalClient.ClusterNodesCalls())
func (mock *UniversalClientMock) ClusterNodesCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClusterNodes.RLock()
	calls = mock.calls.ClusterNodes
	lockUniversalClientMockClusterNodes.RUnlock()
	return calls
}

// ClusterReplicate calls ClusterReplicateFunc.
func (mock *UniversalClientMock) ClusterReplicate(nodeID string) *redis.StatusCmd {
	if mock.ClusterReplicateFunc == nil {
		panic("UniversalClientMock.ClusterReplicateFunc: method is nil but UniversalClient.ClusterReplicate was just called")
	}
	callInfo := struct {
		NodeID string
	}{
		NodeID: nodeID,
	}
	lockUniversalClientMockClusterReplicate.Lock()
	mock.calls.ClusterReplicate = append(mock.calls.ClusterReplicate, callInfo)
	lockUniversalClientMockClusterReplicate.Unlock()
	return mock.ClusterReplicateFunc(nodeID)
}

// ClusterReplicateCalls gets all the calls that were made to ClusterReplicate.
// Check the length with:
//     len(mockedUniversalClient.ClusterReplicateCalls())
func (mock *UniversalClientMock) ClusterReplicateCalls() []struct {
	NodeID string
} {
	var calls []struct {
		NodeID string
	}
	lockUniversalClientMockClusterReplicate.RLock()
	calls = mock.calls.ClusterReplicate
	lockUniversalClientMockClusterReplicate.RUnlock()
	return calls
}

// ClusterResetHard calls ClusterResetHardFunc.
func (mock *UniversalClientMock) ClusterResetHard() *redis.StatusCmd {
	if mock.ClusterResetHardFunc == nil {
		panic("UniversalClientMock.ClusterResetHardFunc: method is nil but UniversalClient.ClusterResetHard was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClusterResetHard.Lock()
	mock.calls.ClusterResetHard = append(mock.calls.ClusterResetHard, callInfo)
	lockUniversalClientMockClusterResetHard.Unlock()
	return mock.ClusterResetHardFunc()
}

// ClusterResetHardCalls gets all the calls that were made to ClusterResetHard.
// Check the length with:
//     len(mockedUniversalClient.ClusterResetHardCalls())
func (mock *UniversalClientMock) ClusterResetHardCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClusterResetHard.RLock()
	calls = mock.calls.ClusterResetHard
	lockUniversalClientMockClusterResetHard.RUnlock()
	return calls
}

// ClusterResetSoft calls ClusterResetSoftFunc.
func (mock *UniversalClientMock) ClusterResetSoft() *redis.StatusCmd {
	if mock.ClusterResetSoftFunc == nil {
		panic("UniversalClientMock.ClusterResetSoftFunc: method is nil but UniversalClient.ClusterResetSoft was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClusterResetSoft.Lock()
	mock.calls.ClusterResetSoft = append(mock.calls.ClusterResetSoft, callInfo)
	lockUniversalClientMockClusterResetSoft.Unlock()
	return mock.ClusterResetSoftFunc()
}

// ClusterResetSoftCalls gets all the calls that were made to ClusterResetSoft.
// Check the length with:
//     len(mockedUniversalClient.ClusterResetSoftCalls())
func (mock *UniversalClientMock) ClusterResetSoftCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClusterResetSoft.RLock()
	calls = mock.calls.ClusterResetSoft
	lockUniversalClientMockClusterResetSoft.RUnlock()
	return calls
}

// ClusterSaveConfig calls ClusterSaveConfigFunc.
func (mock *UniversalClientMock) ClusterSaveConfig() *redis.StatusCmd {
	if mock.ClusterSaveConfigFunc == nil {
		panic("UniversalClientMock.ClusterSaveConfigFunc: method is nil but UniversalClient.ClusterSaveConfig was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClusterSaveConfig.Lock()
	mock.calls.ClusterSaveConfig = append(mock.calls.ClusterSaveConfig, callInfo)
	lockUniversalClientMockClusterSaveConfig.Unlock()
	return mock.ClusterSaveConfigFunc()
}

// ClusterSaveConfigCalls gets all the calls that were made to ClusterSaveConfig.
// Check the length with:
//     len(mockedUniversalClient.ClusterSaveConfigCalls())
func (mock *UniversalClientMock) ClusterSaveConfigCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClusterSaveConfig.RLock()
	calls = mock.calls.ClusterSaveConfig
	lockUniversalClientMockClusterSaveConfig.RUnlock()
	return calls
}

// ClusterSlaves calls ClusterSlavesFunc.
func (mock *UniversalClientMock) ClusterSlaves(nodeID string) *redis.StringSliceCmd {
	if mock.ClusterSlavesFunc == nil {
		panic("UniversalClientMock.ClusterSlavesFunc: method is nil but UniversalClient.ClusterSlaves was just called")
	}
	callInfo := struct {
		NodeID string
	}{
		NodeID: nodeID,
	}
	lockUniversalClientMockClusterSlaves.Lock()
	mock.calls.ClusterSlaves = append(mock.calls.ClusterSlaves, callInfo)
	lockUniversalClientMockClusterSlaves.Unlock()
	return mock.ClusterSlavesFunc(nodeID)
}

// ClusterSlavesCalls gets all the calls that were made to ClusterSlaves.
// Check the length with:
//     len(mockedUniversalClient.ClusterSlavesCalls())
func (mock *UniversalClientMock) ClusterSlavesCalls() []struct {
	NodeID string
} {
	var calls []struct {
		NodeID string
	}
	lockUniversalClientMockClusterSlaves.RLock()
	calls = mock.calls.ClusterSlaves
	lockUniversalClientMockClusterSlaves.RUnlock()
	return calls
}

// ClusterSlots calls ClusterSlotsFunc.
func (mock *UniversalClientMock) ClusterSlots() *redis.ClusterSlotsCmd {
	if mock.ClusterSlotsFunc == nil {
		panic("UniversalClientMock.ClusterSlotsFunc: method is nil but UniversalClient.ClusterSlots was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockClusterSlots.Lock()
	mock.calls.ClusterSlots = append(mock.calls.ClusterSlots, callInfo)
	lockUniversalClientMockClusterSlots.Unlock()
	return mock.ClusterSlotsFunc()
}

// ClusterSlotsCalls gets all the calls that were made to ClusterSlots.
// Check the length with:
//     len(mockedUniversalClient.ClusterSlotsCalls())
func (mock *UniversalClientMock) ClusterSlotsCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockClusterSlots.RLock()
	calls = mock.calls.ClusterSlots
	lockUniversalClientMockClusterSlots.RUnlock()
	return calls
}

// Command calls CommandFunc.
func (mock *UniversalClientMock) Command() *redis.CommandsInfoCmd {
	if mock.CommandFunc == nil {
		panic("UniversalClientMock.CommandFunc: method is nil but UniversalClient.Command was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockCommand.Lock()
	mock.calls.Command = append(mock.calls.Command, callInfo)
	lockUniversalClientMockCommand.Unlock()
	return mock.CommandFunc()
}

// CommandCalls gets all the calls that were made to Command.
// Check the length with:
//     len(mockedUniversalClient.CommandCalls())
func (mock *UniversalClientMock) CommandCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockCommand.RLock()
	calls = mock.calls.Command
	lockUniversalClientMockCommand.RUnlock()
	return calls
}

// ConfigGet calls ConfigGetFunc.
func (mock *UniversalClientMock) ConfigGet(parameter string) *redis.SliceCmd {
	if mock.ConfigGetFunc == nil {
		panic("UniversalClientMock.ConfigGetFunc: method is nil but UniversalClient.ConfigGet was just called")
	}
	callInfo := struct {
		Parameter string
	}{
		Parameter: parameter,
	}
	lockUniversalClientMockConfigGet.Lock()
	mock.calls.ConfigGet = append(mock.calls.ConfigGet, callInfo)
	lockUniversalClientMockConfigGet.Unlock()
	return mock.ConfigGetFunc(parameter)
}

// ConfigGetCalls gets all the calls that were made to ConfigGet.
// Check the length with:
//     len(mockedUniversalClient.ConfigGetCalls())
func (mock *UniversalClientMock) ConfigGetCalls() []struct {
	Parameter string
} {
	var calls []struct {
		Parameter string
	}
	lockUniversalClientMockConfigGet.RLock()
	calls = mock.calls.ConfigGet
	lockUniversalClientMockConfigGet.RUnlock()
	return calls
}

// ConfigResetStat calls ConfigResetStatFunc.
func (mock *UniversalClientMock) ConfigResetStat() *redis.StatusCmd {
	if mock.ConfigResetStatFunc == nil {
		panic("UniversalClientMock.ConfigResetStatFunc: method is nil but UniversalClient.ConfigResetStat was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockConfigResetStat.Lock()
	mock.calls.ConfigResetStat = append(mock.calls.ConfigResetStat, callInfo)
	lockUniversalClientMockConfigResetStat.Unlock()
	return mock.ConfigResetStatFunc()
}

// ConfigResetStatCalls gets all the calls that were made to ConfigResetStat.
// Check the length with:
//     len(mockedUniversalClient.ConfigResetStatCalls())
func (mock *UniversalClientMock) ConfigResetStatCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockConfigResetStat.RLock()
	calls = mock.calls.ConfigResetStat
	lockUniversalClientMockConfigResetStat.RUnlock()
	return calls
}

// ConfigRewrite calls ConfigRewriteFunc.
func (mock *UniversalClientMock) ConfigRewrite() *redis.StatusCmd {
	if mock.ConfigRewriteFunc == nil {
		panic("UniversalClientMock.ConfigRewriteFunc: method is nil but UniversalClient.ConfigRewrite was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockConfigRewrite.Lock()
	mock.calls.ConfigRewrite = append(mock.calls.ConfigRewrite, callInfo)
	lockUniversalClientMockConfigRewrite.Unlock()
	return mock.ConfigRewriteFunc()
}

// ConfigRewriteCalls gets all the calls that were made to ConfigRewrite.
// Check the length with:
//     len(mockedUniversalClient.ConfigRewriteCalls())
func (mock *UniversalClientMock) ConfigRewriteCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockConfigRewrite.RLock()
	calls = mock.calls.ConfigRewrite
	lockUniversalClientMockConfigRewrite.RUnlock()
	return calls
}

// ConfigSet calls ConfigSetFunc.
func (mock *UniversalClientMock) ConfigSet(parameter string, value string) *redis.StatusCmd {
	if mock.ConfigSetFunc == nil {
		panic("UniversalClientMock.ConfigSetFunc: method is nil but UniversalClient.ConfigSet was just called")
	}
	callInfo := struct {
		Parameter string
		Value     string
	}{
		Parameter: parameter,
		Value:     value,
	}
	lockUniversalClientMockConfigSet.Lock()
	mock.calls.ConfigSet = append(mock.calls.ConfigSet, callInfo)
	lockUniversalClientMockConfigSet.Unlock()
	return mock.ConfigSetFunc(parameter, value)
}

// ConfigSetCalls gets all the calls that were made to ConfigSet.
// Check the length with:
//     len(mockedUniversalClient.ConfigSetCalls())
func (mock *UniversalClientMock) ConfigSetCalls() []struct {
	Parameter string
	Value     string
} {
	var calls []struct {
		Parameter string
		Value     string
	}
	lockUniversalClientMockConfigSet.RLock()
	calls = mock.calls.ConfigSet
	lockUniversalClientMockConfigSet.RUnlock()
	return calls
}

// DBSize calls DBSizeFunc.
func (mock *UniversalClientMock) DBSize() *redis.IntCmd {
	if mock.DBSizeFunc == nil {
		panic("UniversalClientMock.DBSizeFunc: method is nil but UniversalClient.DBSize was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockDBSize.Lock()
	mock.calls.DBSize = append(mock.calls.DBSize, callInfo)
	lockUniversalClientMockDBSize.Unlock()
	return mock.DBSizeFunc()
}

// DBSizeCalls gets all the calls that were made to DBSize.
// Check the length with:
//     len(mockedUniversalClient.DBSizeCalls())
func (mock *UniversalClientMock) DBSizeCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockDBSize.RLock()
	calls = mock.calls.DBSize
	lockUniversalClientMockDBSize.RUnlock()
	return calls
}

// DebugObject calls DebugObjectFunc.
func (mock *UniversalClientMock) DebugObject(key string) *redis.StringCmd {
	if mock.DebugObjectFunc == nil {
		panic("UniversalClientMock.DebugObjectFunc: method is nil but UniversalClient.DebugObject was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockDebugObject.Lock()
	mock.calls.DebugObject = append(mock.calls.DebugObject, callInfo)
	lockUniversalClientMockDebugObject.Unlock()
	return mock.DebugObjectFunc(key)
}

// DebugObjectCalls gets all the calls that were made to DebugObject.
// Check the length with:
//     len(mockedUniversalClient.DebugObjectCalls())
func (mock *UniversalClientMock) DebugObjectCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockDebugObject.RLock()
	calls = mock.calls.DebugObject
	lockUniversalClientMockDebugObject.RUnlock()
	return calls
}

// Decr calls DecrFunc.
func (mock *UniversalClientMock) Decr(key string) *redis.IntCmd {
	if mock.DecrFunc == nil {
		panic("UniversalClientMock.DecrFunc: method is nil but UniversalClient.Decr was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockDecr.Lock()
	mock.calls.Decr = append(mock.calls.Decr, callInfo)
	lockUniversalClientMockDecr.Unlock()
	return mock.DecrFunc(key)
}

// DecrCalls gets all the calls that were made to Decr.
// Check the length with:
//     len(mockedUniversalClient.DecrCalls())
func (mock *UniversalClientMock) DecrCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockDecr.RLock()
	calls = mock.calls.Decr
	lockUniversalClientMockDecr.RUnlock()
	return calls
}

// DecrBy calls DecrByFunc.
func (mock *UniversalClientMock) DecrBy(key string, decrement int64) *redis.IntCmd {
	if mock.DecrByFunc == nil {
		panic("UniversalClientMock.DecrByFunc: method is nil but UniversalClient.DecrBy was just called")
	}
	callInfo := struct {
		Key       string
		Decrement int64
	}{
		Key:       key,
		Decrement: decrement,
	}
	lockUniversalClientMockDecrBy.Lock()
	mock.calls.DecrBy = append(mock.calls.DecrBy, callInfo)
	lockUniversalClientMockDecrBy.Unlock()
	return mock.DecrByFunc(key, decrement)
}

// DecrByCalls gets all the calls that were made to DecrBy.
// Check the length with:
//     len(mockedUniversalClient.DecrByCalls())
func (mock *UniversalClientMock) DecrByCalls() []struct {
	Key       string
	Decrement int64
} {
	var calls []struct {
		Key       string
		Decrement int64
	}
	lockUniversalClientMockDecrBy.RLock()
	calls = mock.calls.DecrBy
	lockUniversalClientMockDecrBy.RUnlock()
	return calls
}

// Del calls DelFunc.
func (mock *UniversalClientMock) Del(keys ...string) *redis.IntCmd {
	if mock.DelFunc == nil {
		panic("UniversalClientMock.DelFunc: method is nil but UniversalClient.Del was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockDel.Lock()
	mock.calls.Del = append(mock.calls.Del, callInfo)
	lockUniversalClientMockDel.Unlock()
	return mock.DelFunc(keys...)
}

// DelCalls gets all the calls that were made to Del.
// Check the length with:
//     len(mockedUniversalClient.DelCalls())
func (mock *UniversalClientMock) DelCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockDel.RLock()
	calls = mock.calls.Del
	lockUniversalClientMockDel.RUnlock()
	return calls
}

// Dump calls DumpFunc.
func (mock *UniversalClientMock) Dump(key string) *redis.StringCmd {
	if mock.DumpFunc == nil {
		panic("UniversalClientMock.DumpFunc: method is nil but UniversalClient.Dump was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockDump.Lock()
	mock.calls.Dump = append(mock.calls.Dump, callInfo)
	lockUniversalClientMockDump.Unlock()
	return mock.DumpFunc(key)
}

// DumpCalls gets all the calls that were made to Dump.
// Check the length with:
//     len(mockedUniversalClient.DumpCalls())
func (mock *UniversalClientMock) DumpCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockDump.RLock()
	calls = mock.calls.Dump
	lockUniversalClientMockDump.RUnlock()
	return calls
}

// Echo calls EchoFunc.
func (mock *UniversalClientMock) Echo(message interface{}) *redis.StringCmd {
	if mock.EchoFunc == nil {
		panic("UniversalClientMock.EchoFunc: method is nil but UniversalClient.Echo was just called")
	}
	callInfo := struct {
		Message interface{}
	}{
		Message: message,
	}
	lockUniversalClientMockEcho.Lock()
	mock.calls.Echo = append(mock.calls.Echo, callInfo)
	lockUniversalClientMockEcho.Unlock()
	return mock.EchoFunc(message)
}

// EchoCalls gets all the calls that were made to Echo.
// Check the length with:
//     len(mockedUniversalClient.EchoCalls())
func (mock *UniversalClientMock) EchoCalls() []struct {
	Message interface{}
} {
	var calls []struct {
		Message interface{}
	}
	lockUniversalClientMockEcho.RLock()
	calls = mock.calls.Echo
	lockUniversalClientMockEcho.RUnlock()
	return calls
}

// Eval calls EvalFunc.
func (mock *UniversalClientMock) Eval(script string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalFunc == nil {
		panic("UniversalClientMock.EvalFunc: method is nil but UniversalClient.Eval was just called")
	}
	callInfo := struct {
		Script string
		Keys   []string
		Args   []interface{}
	}{
		Script: script,
		Keys:   keys,
		Args:   args,
	}
	lockUniversalClientMockEval.Lock()
	mock.calls.Eval = append(mock.calls.Eval, callInfo)
	lockUniversalClientMockEval.Unlock()
	return mock.EvalFunc(script, keys, args...)
}

// EvalCalls gets all the calls that were made to Eval.
// Check the length with:
//     len(mockedUniversalClient.EvalCalls())
func (mock *UniversalClientMock) EvalCalls() []struct {
	Script string
	Keys   []string
	Args   []interface{}
} {
	var calls []struct {
		Script string
		Keys   []string
		Args   []interface{}
	}
	lockUniversalClientMockEval.RLock()
	calls = mock.calls.Eval
	lockUniversalClientMockEval.RUnlock()
	return calls
}

// EvalSha calls EvalShaFunc.
func (mock *UniversalClientMock) EvalSha(sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalShaFunc == nil {
		panic("UniversalClientMock.EvalShaFunc: method is nil but UniversalClient.EvalSha was just called")
	}
	callInfo := struct {
		Sha1 string
		Keys []string
		Args []interface{}
	}{
		Sha1: sha1,
		Keys: keys,
		Args: args,
	}
	lockUniversalClientMockEvalSha.Lock()
	mock.calls.EvalSha = append(mock.calls.EvalSha, callInfo)
	lockUniversalClientMockEvalSha.Unlock()
	return mock.EvalShaFunc(sha1, keys, args...)
}

// EvalShaCalls gets all the calls that were made to EvalSha.
// Check the length with:
//     len(mockedUniversalClient.EvalShaCalls())
func (mock *UniversalClientMock) EvalShaCalls() []struct {
	Sha1 string
	Keys []string
	Args []interface{}
} {
	var calls []struct {
		Sha1 string
		Keys []string
		Args []interface{}
	}
	lockUniversalClientMockEvalSha.RLock()
	calls = mock.calls.EvalSha
	lockUniversalClientMockEvalSha.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *UniversalClientMock) Exists(keys ...string) *redis.IntCmd {
	if mock.ExistsFunc == nil {
		panic("UniversalClientMock.ExistsFunc: method is nil but UniversalClient.Exists was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	lockUniversalClientMockExists.Unlock()
	return mock.ExistsFunc(keys...)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//     len(mockedUniversalClient.ExistsCalls())
func (mock *UniversalClientMock) ExistsCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockExists.RLock()
	calls = mock.calls.Exists
	lockUniversalClientMockExists.RUnlock()
	return calls
}

// Expire calls ExpireFunc.
func (mock *UniversalClientMock) Expire(key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireFunc == nil {
		panic("UniversalClientMock.ExpireFunc: method is nil but UniversalClient.Expire was just called")
	}
	callInfo := struct {
		Key        string
		Expiration time.Duration
	}{
		Key:        key,
		Expiration: expiration,
	}
	lockUniversalClientMockExpire.Lock()
	mock.calls.Expire = append(mock.calls.Expire, callInfo)
	lockUniversalClientMockExpire.Unlock()
	return mock.ExpireFunc(key, expiration)
}

// ExpireCalls gets all the calls that were made to Expire.
// Check the length with:
//     len(mockedUniversalClient.ExpireCalls())
func (mock *UniversalClientMock) ExpireCalls() []struct {
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Key        string
		Expiration time.Duration
	}
	lockUniversalClientMockExpire.RLock()
	calls = mock.calls.Expire
	lockUniversalClientMockExpire.RUnlock()
	return calls
}

// ExpireAt calls ExpireAtFunc.
func (mock *UniversalClientMock) ExpireAt(key string, tm time.Time) *redis.BoolCmd {
	if mock.ExpireAtFunc == nil {
		panic("UniversalClientMock.ExpireAtFunc: method is nil but UniversalClient.ExpireAt was just called")
	}
	callInfo := struct {
		Key string
		Tm  time.Time
	}{
		Key: key,
		Tm:  tm,
	}
	lockUniversalClientMockExpireAt.Lock()
	mock.calls.ExpireAt = append(mock.calls.ExpireAt, callInfo)
	lockUniversalClientMockExpireAt.Unlock()
	return mock.ExpireAtFunc(key, tm)
}

// ExpireAtCalls gets all the calls that were made to ExpireAt.
// Check the length with:
//     len(mockedUniversalClient.ExpireAtCalls())
func (mock *UniversalClientMock) ExpireAtCalls() []struct {
	Key string
	Tm  time.Time
} {
	var calls []struct {
		Key string
		Tm  time.Time
	}
	lockUniversalClientMockExpireAt.RLock()
	calls = mock.calls.ExpireAt
	lockUniversalClientMockExpireAt.RUnlock()
	return calls
}

// FlushAll calls FlushAllFunc.
func (mock *UniversalClientMock) FlushAll() *redis.StatusCmd {
	if mock.FlushAllFunc == nil {
		panic("UniversalClientMock.FlushAllFunc: method is nil but UniversalClient.FlushAll was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockFlushAll.Lock()
	mock.calls.FlushAll = append(mock.calls.FlushAll, callInfo)
	lockUniversalClientMockFlushAll.Unlock()
	return mock.FlushAllFunc()
}

// FlushAllCalls gets all the calls that were made to FlushAll.
// Check the length with:
//     len(mockedUniversalClient.FlushAllCalls())
func (mock *UniversalClientMock) FlushAllCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockFlushAll.RLock()
	calls = mock.calls.FlushAll
	lockUniversalClientMockFlushAll.RUnlock()
	return calls
}

// FlushAllAsync calls FlushAllAsyncFunc.
func (mock *UniversalClientMock) FlushAllAsync() *redis.StatusCmd {
	if mock.FlushAllAsyncFunc == nil {
		panic("UniversalClientMock.FlushAllAsyncFunc: method is nil but UniversalClient.FlushAllAsync was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockFlushAllAsync.Lock()
	mock.calls.FlushAllAsync = append(mock.calls.FlushAllAsync, callInfo)
	lockUniversalClientMockFlushAllAsync.Unlock()
	return mock.FlushAllAsyncFunc()
}

// FlushAllAsyncCalls gets all the calls that were made to FlushAllAsync.
// Check the length with:
//     len(mockedUniversalClient.FlushAllAsyncCalls())
func (mock *UniversalClientMock) FlushAllAsyncCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockFlushAllAsync.RLock()
	calls = mock.calls.FlushAllAsync
	lockUniversalClientMockFlushAllAsync.RUnlock()
	return calls
}

// FlushDB calls FlushDBFunc.
func (mock *UniversalClientMock) FlushDB() *redis.StatusCmd {
	if mock.FlushDBFunc == nil {
		panic("UniversalClientMock.FlushDBFunc: method is nil but UniversalClient.FlushDB was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockFlushDB.Lock()
	mock.calls.FlushDB = append(mock.calls.FlushDB, callInfo)
	lockUniversalClientMockFlushDB.Unlock()
	return mock.FlushDBFunc()
}

// FlushDBCalls gets all the calls that were made to FlushDB.
// Check the length with:
//     len(mockedUniversalClient.FlushDBCalls())
func (mock *UniversalClientMock) FlushDBCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockFlushDB.RLock()
	calls = mock.calls.FlushDB
	lockUniversalClientMockFlushDB.RUnlock()
	return calls
}

// FlushDBAsync calls FlushDBAsyncFunc.
func (mock *UniversalClientMock) FlushDBAsync() *redis.StatusCmd {
	if mock.FlushDBAsyncFunc == nil {
		panic("UniversalClientMock.FlushDBAsyncFunc: method is nil but UniversalClient.FlushDBAsync was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockFlushDBAsync.Lock()
	mock.calls.FlushDBAsync = append(mock.calls.FlushDBAsync, callInfo)
	lockUniversalClientMockFlushDBAsync.Unlock()
	return mock.FlushDBAsyncFunc()
}

// FlushDBAsyncCalls gets all the calls that were made to FlushDBAsync.
// Check the length with:
//     len(mockedUniversalClient.FlushDBAsyncCalls())
func (mock *UniversalClientMock) FlushDBAsyncCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockFlushDBAsync.RLock()
	calls = mock.calls.FlushDBAsync
	lockUniversalClientMockFlushDBAsync.RUnlock()
	return calls
}

// GeoAdd calls GeoAddFunc.
func (mock *UniversalClientMock) GeoAdd(key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
	if mock.GeoAddFunc == nil {
		panic("UniversalClientMock.GeoAddFunc: method is nil but UniversalClient.GeoAdd was just called")
	}
	callInfo := struct {
		Key         string
		GeoLocation []*redis.GeoLocation
	}{
		Key:         key,
		GeoLocation: geoLocation,
	}
	lockUniversalClientMockGeoAdd.Lock()
	mock.calls.GeoAdd = append(mock.calls.GeoAdd, callInfo)
	lockUniversalClientMockGeoAdd.Unlock()
	return mock.GeoAddFunc(key, geoLocation...)
}

// GeoAddCalls gets all the calls that were made to GeoAdd.
// Check the length with:
//     len(mockedUniversalClient.GeoAddCalls())
func (mock *UniversalClientMock) GeoAddCalls() []struct {
	Key         string
	GeoLocation []*redis.GeoLocation
} {
	var calls []struct {
		Key         string
		GeoLocation []*redis.GeoLocation
	}
	lockUniversalClientMockGeoAdd.RLock()
	calls = mock.calls.GeoAdd
	lockUniversalClientMockGeoAdd.RUnlock()
	return calls
}

// GeoDist calls GeoDistFunc.
func (mock *UniversalClientMock) GeoDist(key string, member1 string, member2 string, unit string) *redis.FloatCmd {
	if mock.GeoDistFunc == nil {
		panic("UniversalClientMock.GeoDistFunc: method is nil but UniversalClient.GeoDist was just called")
	}
	callInfo := struct {
		Key     string
		Member1 string
		Member2 string
		Unit    string
	}{
		Key:     key,
		Member1: member1,
		Member2: member2,
		Unit:    unit,
	}
	lockUniversalClientMockGeoDist.Lock()
	mock.calls.GeoDist = append(mock.calls.GeoDist, callInfo)
	lockUniversalClientMockGeoDist.Unlock()
	return mock.GeoDistFunc(key, member1, member2, unit)
}

// GeoDistCalls gets all the calls that were made to GeoDist.
// Check the length with:
//     len(mockedUniversalClient.GeoDistCalls())
func (mock *UniversalClientMock) GeoDistCalls() []struct {
	Key     string
	Member1 string
	Member2 string
	Unit    string
} {
	var calls []struct {
		Key     string
		Member1 string
		Member2 string
		Unit    string
	}
	lockUniversalClientMockGeoDist.RLock()
	calls = mock.calls.GeoDist
	lockUniversalClientMockGeoDist.RUnlock()
	return calls
}

// GeoHash calls GeoHashFunc.
func (mock *UniversalClientMock) GeoHash(key string, members ...string) *redis.StringSliceCmd {
	if mock.GeoHashFunc == nil {
		panic("UniversalClientMock.GeoHashFunc: method is nil but UniversalClient.GeoHash was just called")
	}
	callInfo := struct {
		Key     string
		Members []string
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockGeoHash.Lock()
	mock.calls.GeoHash = append(mock.calls.GeoHash, callInfo)
	lockUniversalClientMockGeoHash.Unlock()
	return mock.GeoHashFunc(key, members...)
}

// GeoHashCalls gets all the calls that were made to GeoHash.
// Check the length with:
//     len(mockedUniversalClient.GeoHashCalls())
func (mock *UniversalClientMock) GeoHashCalls() []struct {
	Key     string
	Members []string
} {
	var calls []struct {
		Key     string
		Members []string
	}
	lockUniversalClientMockGeoHash.RLock()
	calls = mock.calls.GeoHash
	lockUniversalClientMockGeoHash.RUnlock()
	return calls
}

// GeoPos calls GeoPosFunc.
func (mock *UniversalClientMock) GeoPos(key string, members ...string) *redis.GeoPosCmd {
	if mock.GeoPosFunc == nil {
		panic("UniversalClientMock.GeoPosFunc: method is nil but UniversalClient.GeoPos was just called")
	}
	callInfo := struct {
		Key     string
		Members []string
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockGeoPos.Lock()
	mock.calls.GeoPos = append(mock.calls.GeoPos, callInfo)
	lockUniversalClientMockGeoPos.Unlock()
	return mock.GeoPosFunc(key, members...)
}

// GeoPosCalls gets all the calls that were made to GeoPos.
// Check the length with:
//     len(mockedUniversalClient.GeoPosCalls())
func (mock *UniversalClientMock) GeoPosCalls() []struct {
	Key     string
	Members []string
} {
	var calls []struct {
		Key     string
		Members []string
	}
	lockUniversalClientMockGeoPos.RLock()
	calls = mock.calls.GeoPos
	lockUniversalClientMockGeoPos.RUnlock()
	return calls
}

// GeoRadius calls GeoRadiusFunc.
func (mock *UniversalClientMock) GeoRadius(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	if mock.GeoRadiusFunc == nil {
		panic("UniversalClientMock.GeoRadiusFunc: method is nil but UniversalClient.GeoRadius was just called")
	}
	callInfo := struct {
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}{
		Key:       key,
		Longitude: longitude,
		Latitude:  latitude,
		Query:     query,
	}
	lockUniversalClientMockGeoRadius.Lock()
	mock.calls.GeoRadius = append(mock.calls.GeoRadius, callInfo)
	lockUniversalClientMockGeoRadius.Unlock()
	return mock.GeoRadiusFunc(key, longitude, latitude, query)
}

// GeoRadiusCalls gets all the calls that were made to GeoRadius.
// Check the length with:
//     len(mockedUniversalClient.GeoRadiusCalls())
func (mock *UniversalClientMock) GeoRadiusCalls() []struct {
	Key       string
	Longitude float64
	Latitude  float64
	Query     *redis.GeoRadiusQuery
} {
	var calls []struct {
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}
	lockUniversalClientMockGeoRadius.RLock()
	calls = mock.calls.GeoRadius
	lockUniversalClientMockGeoRadius.RUnlock()
	return calls
}

// GeoRadiusByMember calls GeoRadiusByMemberFunc.
func (mock *UniversalClientMock) GeoRadiusByMember(key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	if mock.GeoRadiusByMemberFunc == nil {
		panic("UniversalClientMock.GeoRadiusByMemberFunc: method is nil but UniversalClient.GeoRadiusByMember was just called")
	}
	callInfo := struct {
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}{
		Key:    key,
		Member: member,
		Query:  query,
	}
	lockUniversalClientMockGeoRadiusByMember.Lock()
	mock.calls.GeoRadiusByMember = append(mock.calls.GeoRadiusByMember, callInfo)
	lockUniversalClientMockGeoRadiusByMember.Unlock()
	return mock.GeoRadiusByMemberFunc(key, member, query)
}

// GeoRadiusByMemberCalls gets all the calls that were made to GeoRadiusByMember.
// Check the length with:
//     len(mockedUniversalClient.GeoRadiusByMemberCalls())
func (mock *UniversalClientMock) GeoRadiusByMemberCalls() []struct {
	Key    string
	Member string
	Query  *redis.GeoRadiusQuery
} {
	var calls []struct {
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}
	lockUniversalClientMockGeoRadiusByMember.RLock()
	calls = mock.calls.GeoRadiusByMember
	lockUniversalClientMockGeoRadiusByMember.RUnlock()
	return calls
}

// GeoRadiusByMemberRO calls GeoRadiusByMemberROFunc.
func (mock *UniversalClientMock) GeoRadiusByMemberRO(key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	if mock.GeoRadiusByMemberROFunc == nil {
		panic("UniversalClientMock.GeoRadiusByMemberROFunc: method is nil but UniversalClient.GeoRadiusByMemberRO was just called")
	}
	callInfo := struct {
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}{
		Key:    key,
		Member: member,
		Query:  query,
	}
	lockUniversalClientMockGeoRadiusByMemberRO.Lock()
	mock.calls.GeoRadiusByMemberRO = append(mock.calls.GeoRadiusByMemberRO, callInfo)
	lockUniversalClientMockGeoRadiusByMemberRO.Unlock()
	return mock.GeoRadiusByMemberROFunc(key, member, query)
}

// GeoRadiusByMemberROCalls gets all the calls that were made to GeoRadiusByMemberRO.
// Check the length with:
//     len(mockedUniversalClient.GeoRadiusByMemberROCalls())
func (mock *UniversalClientMock) GeoRadiusByMemberROCalls() []struct {
	Key    string
	Member string
	Query  *redis.GeoRadiusQuery
} {
	var calls []struct {
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}
	lockUniversalClientMockGeoRadiusByMemberRO.RLock()
	calls = mock.calls.GeoRadiusByMemberRO
	lockUniversalClientMockGeoRadiusByMemberRO.RUnlock()
	return calls
}

// GeoRadiusRO calls GeoRadiusROFunc.
func (mock *UniversalClientMock) GeoRadiusRO(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	if mock.GeoRadiusROFunc == nil {
		panic("UniversalClientMock.GeoRadiusROFunc: method is nil but UniversalClient.GeoRadiusRO was just called")
	}
	callInfo := struct {
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}{
		Key:       key,
		Longitude: longitude,
		Latitude:  latitude,
		Query:     query,
	}
	lockUniversalClientMockGeoRadiusRO.Lock()
	mock.calls.GeoRadiusRO = append(mock.calls.GeoRadiusRO, callInfo)
	lockUniversalClientMockGeoRadiusRO.Unlock()
	return mock.GeoRadiusROFunc(key, longitude, latitude, query)
}

// GeoRadiusROCalls gets all the calls that were made to GeoRadiusRO.
// Check the length with:
//     len(mockedUniversalClient.GeoRadiusROCalls())
func (mock *UniversalClientMock) GeoRadiusROCalls() []struct {
	Key       string
	Longitude float64
	Latitude  float64
	Query     *redis.GeoRadiusQuery
} {
	var calls []struct {
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}
	lockUniversalClientMockGeoRadiusRO.RLock()
	calls = mock.calls.GeoRadiusRO
	lockUniversalClientMockGeoRadiusRO.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *UniversalClientMock) Get(key string) *redis.StringCmd {
	if mock.GetFunc == nil {
		panic("UniversalClientMock.GetFunc: method is nil but UniversalClient.Get was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockUniversalClientMockGet.Unlock()
	return mock.GetFunc(key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedUniversalClient.GetCalls())
func (mock *UniversalClientMock) GetCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockGet.RLock()
	calls = mock.calls.Get
	lockUniversalClientMockGet.RUnlock()
	return calls
}

// GetBit calls GetBitFunc.
func (mock *UniversalClientMock) GetBit(key string, offset int64) *redis.IntCmd {
	if mock.GetBitFunc == nil {
		panic("UniversalClientMock.GetBitFunc: method is nil but UniversalClient.GetBit was just called")
	}
	callInfo := struct {
		Key    string
		Offset int64
	}{
		Key:    key,
		Offset: offset,
	}
	lockUniversalClientMockGetBit.Lock()
	mock.calls.GetBit = append(mock.calls.GetBit, callInfo)
	lockUniversalClientMockGetBit.Unlock()
	return mock.GetBitFunc(key, offset)
}

// GetBitCalls gets all the calls that were made to GetBit.
// Check the length with:
//     len(mockedUniversalClient.GetBitCalls())
func (mock *UniversalClientMock) GetBitCalls() []struct {
	Key    string
	Offset int64
} {
	var calls []struct {
		Key    string
		Offset int64
	}
	lockUniversalClientMockGetBit.RLock()
	calls = mock.calls.GetBit
	lockUniversalClientMockGetBit.RUnlock()
	return calls
}

// GetRange calls GetRangeFunc.
func (mock *UniversalClientMock) GetRange(key string, start int64, end int64) *redis.StringCmd {
	if mock.GetRangeFunc == nil {
		panic("UniversalClientMock.GetRangeFunc: method is nil but UniversalClient.GetRange was just called")
	}
	callInfo := struct {
		Key   string
		Start int64
		End   int64
	}{
		Key:   key,
		Start: start,
		End:   end,
	}
	lockUniversalClientMockGetRange.Lock()
	mock.calls.GetRange = append(mock.calls.GetRange, callInfo)
	lockUniversalClientMockGetRange.Unlock()
	return mock.GetRangeFunc(key, start, end)
}

// GetRangeCalls gets all the calls that were made to GetRange.
// Check the length with:
//     len(mockedUniversalClient.GetRangeCalls())
func (mock *UniversalClientMock) GetRangeCalls() []struct {
	Key   string
	Start int64
	End   int64
} {
	var calls []struct {
		Key   string
		Start int64
		End   int64
	}
	lockUniversalClientMockGetRange.RLock()
	calls = mock.calls.GetRange
	lockUniversalClientMockGetRange.RUnlock()
	return calls
}

// GetSet calls GetSetFunc.
func (mock *UniversalClientMock) GetSet(key string, value interface{}) *redis.StringCmd {
	if mock.GetSetFunc == nil {
		panic("UniversalClientMock.GetSetFunc: method is nil but UniversalClient.GetSet was just called")
	}
	callInfo := struct {
		Key   string
		Value interface{}
	}{
		Key:   key,
		Value: value,
	}
	lockUniversalClientMockGetSet.Lock()
	mock.calls.GetSet = append(mock.calls.GetSet, callInfo)
	lockUniversalClientMockGetSet.Unlock()
	return mock.GetSetFunc(key, value)
}

// GetSetCalls gets all the calls that were made to GetSet.
// Check the length with:
//     len(mockedUniversalClient.GetSetCalls())
func (mock *UniversalClientMock) GetSetCalls() []struct {
	Key   string
	Value interface{}
} {
	var calls []struct {
		Key   string
		Value interface{}
	}
	lockUniversalClientMockGetSet.RLock()
	calls = mock.calls.GetSet
	lockUniversalClientMockGetSet.RUnlock()
	return calls
}

// HDel calls HDelFunc.
func (mock *UniversalClientMock) HDel(key string, fields ...string) *redis.IntCmd {
	if mock.HDelFunc == nil {
		panic("UniversalClientMock.HDelFunc: method is nil but UniversalClient.HDel was just called")
	}
	callInfo := struct {
		Key    string
		Fields []string
	}{
		Key:    key,
		Fields: fields,
	}
	lockUniversalClientMockHDel.Lock()
	mock.calls.HDel = append(mock.calls.HDel, callInfo)
	lockUniversalClientMockHDel.Unlock()
	return mock.HDelFunc(key, fields...)
}

// HDelCalls gets all the calls that were made to HDel.
// Check the length with:
//     len(mockedUniversalClient.HDelCalls())
func (mock *UniversalClientMock) HDelCalls() []struct {
	Key    string
	Fields []string
} {
	var calls []struct {
		Key    string
		Fields []string
	}
	lockUniversalClientMockHDel.RLock()
	calls = mock.calls.HDel
	lockUniversalClientMockHDel.RUnlock()
	return calls
}

// HExists calls HExistsFunc.
func (mock *UniversalClientMock) HExists(key string, field string) *redis.BoolCmd {
	if mock.HExistsFunc == nil {
		panic("UniversalClientMock.HExistsFunc: method is nil but UniversalClient.HExists was just called")
	}
	callInfo := struct {
		Key   string
		Field string
	}{
		Key:   key,
		Field: field,
	}
	lockUniversalClientMockHExists.Lock()
	mock.calls.HExists = append(mock.calls.HExists, callInfo)
	lockUniversalClientMockHExists.Unlock()
	return mock.HExistsFunc(key, field)
}

// HExistsCalls gets all the calls that were made to HExists.
// Check the length with:
//     len(mockedUniversalClient.HExistsCalls())
func (mock *UniversalClientMock) HExistsCalls() []struct {
	Key   string
	Field string
} {
	var calls []struct {
		Key   string
		Field string
	}
	lockUniversalClientMockHExists.RLock()
	calls = mock.calls.HExists
	lockUniversalClientMockHExists.RUnlock()
	return calls
}

// HGet calls HGetFunc.
func (mock *UniversalClientMock) HGet(key string, field string) *redis.StringCmd {
	if mock.HGetFunc == nil {
		panic("UniversalClientMock.HGetFunc: method is nil but UniversalClient.HGet was just called")
	}
	callInfo := struct {
		Key   string
		Field string
	}{
		Key:   key,
		Field: field,
	}
	lockUniversalClientMockHGet.Lock()
	mock.calls.HGet = append(mock.calls.HGet, callInfo)
	lockUniversalClientMockHGet.Unlock()
	return mock.HGetFunc(key, field)
}

// HGetCalls gets all the calls that were made to HGet.
// Check the length with:
//     len(mockedUniversalClient.HGetCalls())
func (mock *UniversalClientMock) HGetCalls() []struct {
	Key   string
	Field string
} {
	var calls []struct {
		Key   string
		Field string
	}
	lockUniversalClientMockHGet.RLock()
	calls = mock.calls.HGet
	lockUniversalClientMockHGet.RUnlock()
	return calls
}

// HGetAll calls HGetAllFunc.
func (mock *UniversalClientMock) HGetAll(key string) *redis.StringStringMapCmd {
	if mock.HGetAllFunc == nil {
		panic("UniversalClientMock.HGetAllFunc: method is nil but UniversalClient.HGetAll was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockHGetAll.Lock()
	mock.calls.HGetAll = append(mock.calls.HGetAll, callInfo)
	lockUniversalClientMockHGetAll.Unlock()
	return mock.HGetAllFunc(key)
}

// HGetAllCalls gets all the calls that were made to HGetAll.
// Check the length with:
//     len(mockedUniversalClient.HGetAllCalls())
func (mock *UniversalClientMock) HGetAllCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockHGetAll.RLock()
	calls = mock.calls.HGetAll
	lockUniversalClientMockHGetAll.RUnlock()
	return calls
}

// HIncrBy calls HIncrByFunc.
func (mock *UniversalClientMock) HIncrBy(key string, field string, incr int64) *redis.IntCmd {
	if mock.HIncrByFunc == nil {
		panic("UniversalClientMock.HIncrByFunc: method is nil but UniversalClient.HIncrBy was just called")
	}
	callInfo := struct {
		Key   string
		Field string
		Incr  int64
	}{
		Key:   key,
		Field: field,
		Incr:  incr,
	}
	lockUniversalClientMockHIncrBy.Lock()
	mock.calls.HIncrBy = append(mock.calls.HIncrBy, callInfo)
	lockUniversalClientMockHIncrBy.Unlock()
	return mock.HIncrByFunc(key, field, incr)
}

// HIncrByCalls gets all the calls that were made to HIncrBy.
// Check the length with:
//     len(mockedUniversalClient.HIncrByCalls())
func (mock *UniversalClientMock) HIncrByCalls() []struct {
	Key   string
	Field string
	Incr  int64
} {
	var calls []struct {
		Key   string
		Field string
		Incr  int64
	}
	lockUniversalClientMockHIncrBy.RLock()
	calls = mock.calls.HIncrBy
	lockUniversalClientMockHIncrBy.RUnlock()
	return calls
}

// HIncrByFloat calls HIncrByFloatFunc.
func (mock *UniversalClientMock) HIncrByFloat(key string, field string, incr float64) *redis.FloatCmd {
	if mock.HIncrByFloatFunc == nil {
		panic("UniversalClientMock.HIncrByFloatFunc: method is nil but UniversalClient.HIncrByFloat was just called")
	}
	callInfo := struct {
		Key   string
		Field string
		Incr  float64
	}{
		Key:   key,
		Field: field,
		Incr:  incr,
	}
	lockUniversalClientMockHIncrByFloat.Lock()
	mock.calls.HIncrByFloat = append(mock.calls.HIncrByFloat, callInfo)
	lockUniversalClientMockHIncrByFloat.Unlock()
	return mock.HIncrByFloatFunc(key, field, incr)
}

// HIncrByFloatCalls gets all the calls that were made to HIncrByFloat.
// Check the length with:
//     len(mockedUniversalClient.HIncrByFloatCalls())
func (mock *UniversalClientMock) HIncrByFloatCalls() []struct {
	Key   string
	Field string
	Incr  float64
} {
	var calls []struct {
		Key   string
		Field string
		Incr  float64
	}
	lockUniversalClientMockHIncrByFloat.RLock()
	calls = mock.calls.HIncrByFloat
	lockUniversalClientMockHIncrByFloat.RUnlock()
	return calls
}

// HKeys calls HKeysFunc.
func (mock *UniversalClientMock) HKeys(key string) *redis.StringSliceCmd {
	if mock.HKeysFunc == nil {
		panic("UniversalClientMock.HKeysFunc: method is nil but UniversalClient.HKeys was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockHKeys.Lock()
	mock.calls.HKeys = append(mock.calls.HKeys, callInfo)
	lockUniversalClientMockHKeys.Unlock()
	return mock.HKeysFunc(key)
}

// HKeysCalls gets all the calls that were made to HKeys.
// Check the length with:
//     len(mockedUniversalClient.HKeysCalls())
func (mock *UniversalClientMock) HKeysCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockHKeys.RLock()
	calls = mock.calls.HKeys
	lockUniversalClientMockHKeys.RUnlock()
	return calls
}

// HLen calls HLenFunc.
func (mock *UniversalClientMock) HLen(key string) *redis.IntCmd {
	if mock.HLenFunc == nil {
		panic("UniversalClientMock.HLenFunc: method is nil but UniversalClient.HLen was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockHLen.Lock()
	mock.calls.HLen = append(mock.calls.HLen, callInfo)
	lockUniversalClientMockHLen.Unlock()
	return mock.HLenFunc(key)
}

// HLenCalls gets all the calls that were made to HLen.
// Check the length with:
//     len(mockedUniversalClient.HLenCalls())
func (mock *UniversalClientMock) HLenCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockHLen.RLock()
	calls = mock.calls.HLen
	lockUniversalClientMockHLen.RUnlock()
	return calls
}

// HMGet calls HMGetFunc.
func (mock *UniversalClientMock) HMGet(key string, fields ...string) *redis.SliceCmd {
	if mock.HMGetFunc == nil {
		panic("UniversalClientMock.HMGetFunc: method is nil but UniversalClient.HMGet was just called")
	}
	callInfo := struct {
		Key    string
		Fields []string
	}{
		Key:    key,
		Fields: fields,
	}
	lockUniversalClientMockHMGet.Lock()
	mock.calls.HMGet = append(mock.calls.HMGet, callInfo)
	lockUniversalClientMockHMGet.Unlock()
	return mock.HMGetFunc(key, fields...)
}

// HMGetCalls gets all the calls that were made to HMGet.
// Check the length with:
//     len(mockedUniversalClient.HMGetCalls())
func (mock *UniversalClientMock) HMGetCalls() []struct {
	Key    string
	Fields []string
} {
	var calls []struct {
		Key    string
		Fields []string
	}
	lockUniversalClientMockHMGet.RLock()
	calls = mock.calls.HMGet
	lockUniversalClientMockHMGet.RUnlock()
	return calls
}

// HMSet calls HMSetFunc.
func (mock *UniversalClientMock) HMSet(key string, fields map[string]interface{}) *redis.StatusCmd {
	if mock.HMSetFunc == nil {
		panic("UniversalClientMock.HMSetFunc: method is nil but UniversalClient.HMSet was just called")
	}
	callInfo := struct {
		Key    string
		Fields map[string]interface{}
	}{
		Key:    key,
		Fields: fields,
	}
	lockUniversalClientMockHMSet.Lock()
	mock.calls.HMSet = append(mock.calls.HMSet, callInfo)
	lockUniversalClientMockHMSet.Unlock()
	return mock.HMSetFunc(key, fields)
}

// HMSetCalls gets all the calls that were made to HMSet.
// Check the length with:
//     len(mockedUniversalClient.HMSetCalls())
func (mock *UniversalClientMock) HMSetCalls() []struct {
	Key    string
	Fields map[string]interface{}
} {
	var calls []struct {
		Key    string
		Fields map[string]interface{}
	}
	lockUniversalClientMockHMSet.RLock()
	calls = mock.calls.HMSet
	lockUniversalClientMockHMSet.RUnlock()
	return calls
}

// HScan calls HScanFunc.
func (mock *UniversalClientMock) HScan(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.HScanFunc == nil {
		panic("UniversalClientMock.HScanFunc: method is nil but UniversalClient.HScan was just called")
	}
	callInfo := struct {
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	lockUniversalClientMockHScan.Lock()
	mock.calls.HScan = append(mock.calls.HScan, callInfo)
	lockUniversalClientMockHScan.Unlock()
	return mock.HScanFunc(key, cursor, match, count)
}

// HScanCalls gets all the calls that were made to HScan.
// Check the length with:
//     len(mockedUniversalClient.HScanCalls())
func (mock *UniversalClientMock) HScanCalls() []struct {
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	lockUniversalClientMockHScan.RLock()
	calls = mock.calls.HScan
	lockUniversalClientMockHScan.RUnlock()
	return calls
}

// HSet calls HSetFunc.
func (mock *UniversalClientMock) HSet(key string, field string, value interface{}) *redis.BoolCmd {
	if mock.HSetFunc == nil {
		panic("UniversalClientMock.HSetFunc: method is nil but UniversalClient.HSet was just called")
	}
	callInfo := struct {
		Key   string
		Field string
		Value interface{}
	}{
		Key:   key,
		Field: field,
		Value: value,
	}
	lockUniversalClientMockHSet.Lock()
	mock.calls.HSet = append(mock.calls.HSet, callInfo)
	lockUniversalClientMockHSet.Unlock()
	return mock.HSetFunc(key, field, value)
}

// HSetCalls gets all the calls that were made to HSet.
// Check the length with:
//     len(mockedUniversalClient.HSetCalls())
func (mock *UniversalClientMock) HSetCalls() []struct {
	Key   string
	Field string
	Value interface{}
} {
	var calls []struct {
		Key   string
		Field string
		Value interface{}
	}
	lockUniversalClientMockHSet.RLock()
	calls = mock.calls.HSet
	lockUniversalClientMockHSet.RUnlock()
	return calls
}

// HSetNX calls HSetNXFunc.
func (mock *UniversalClientMock) HSetNX(key string, field string, value interface{}) *redis.BoolCmd {
	if mock.HSetNXFunc == nil {
		panic("UniversalClientMock.HSetNXFunc: method is nil but UniversalClient.HSetNX was just called")
	}
	callInfo := struct {
		Key   string
		Field string
		Value interface{}
	}{
		Key:   key,
		Field: field,
		Value: value,
	}
	lockUniversalClientMockHSetNX.Lock()
	mock.calls.HSetNX = append(mock.calls.HSetNX, callInfo)
	lockUniversalClientMockHSetNX.Unlock()
	return mock.HSetNXFunc(key, field, value)
}

// HSetNXCalls gets all the calls that were made to HSetNX.
// Check the length with:
//     len(mockedUniversalClient.HSetNXCalls())
func (mock *UniversalClientMock) HSetNXCalls() []struct {
	Key   string
	Field string
	Value interface{}
} {
	var calls []struct {
		Key   string
		Field string
		Value interface{}
	}
	lockUniversalClientMockHSetNX.RLock()
	calls = mock.calls.HSetNX
	lockUniversalClientMockHSetNX.RUnlock()
	return calls
}

// HVals calls HValsFunc.
func (mock *UniversalClientMock) HVals(key string) *redis.StringSliceCmd {
	if mock.HValsFunc == nil {
		panic("UniversalClientMock.HValsFunc: method is nil but UniversalClient.HVals was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockHVals.Lock()
	mock.calls.HVals = append(mock.calls.HVals, callInfo)
	lockUniversalClientMockHVals.Unlock()
	return mock.HValsFunc(key)
}

// HValsCalls gets all the calls that were made to HVals.
// Check the length with:
//     len(mockedUniversalClient.HValsCalls())
func (mock *UniversalClientMock) HValsCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockHVals.RLock()
	calls = mock.calls.HVals
	lockUniversalClientMockHVals.RUnlock()
	return calls
}

// Incr calls IncrFunc.
func (mock *UniversalClientMock) Incr(key string) *redis.IntCmd {
	if mock.IncrFunc == nil {
		panic("UniversalClientMock.IncrFunc: method is nil but UniversalClient.Incr was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockIncr.Lock()
	mock.calls.Incr = append(mock.calls.Incr, callInfo)
	lockUniversalClientMockIncr.Unlock()
	return mock.IncrFunc(key)
}

// IncrCalls gets all the calls that were made to Incr.
// Check the length with:
//     len(mockedUniversalClient.IncrCalls())
func (mock *UniversalClientMock) IncrCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockIncr.RLock()
	calls = mock.calls.Incr
	lockUniversalClientMockIncr.RUnlock()
	return calls
}

// IncrBy calls IncrByFunc.
func (mock *UniversalClientMock) IncrBy(key string, value int64) *redis.IntCmd {
	if mock.IncrByFunc == nil {
		panic("UniversalClientMock.IncrByFunc: method is nil but UniversalClient.IncrBy was just called")
	}
	callInfo := struct {
		Key   string
		Value int64
	}{
		Key:   key,
		Value: value,
	}
	lockUniversalClientMockIncrBy.Lock()
	mock.calls.IncrBy = append(mock.calls.IncrBy, callInfo)
	lockUniversalClientMockIncrBy.Unlock()
	return mock.IncrByFunc(key, value)
}

// IncrByCalls gets all the calls that were made to IncrBy.
// Check the length with:
//     len(mockedUniversalClient.IncrByCalls())
func (mock *UniversalClientMock) IncrByCalls() []struct {
	Key   string
	Value int64
} {
	var calls []struct {
		Key   string
		Value int64
	}
	lockUniversalClientMockIncrBy.RLock()
	calls = mock.calls.IncrBy
	lockUniversalClientMockIncrBy.RUnlock()
	return calls
}

// IncrByFloat calls IncrByFloatFunc.
func (mock *UniversalClientMock) IncrByFloat(key string, value float64) *redis.FloatCmd {
	if mock.IncrByFloatFunc == nil {
		panic("UniversalClientMock.IncrByFloatFunc: method is nil but UniversalClient.IncrByFloat was just called")
	}
	callInfo := struct {
		Key   string
		Value float64
	}{
		Key:   key,
		Value: value,
	}
	lockUniversalClientMockIncrByFloat.Lock()
	mock.calls.IncrByFloat = append(mock.calls.IncrByFloat, callInfo)
	lockUniversalClientMockIncrByFloat.Unlock()
	return mock.IncrByFloatFunc(key, value)
}

// IncrByFloatCalls gets all the calls that were made to IncrByFloat.
// Check the length with:
//     len(mockedUniversalClient.IncrByFloatCalls())
func (mock *UniversalClientMock) IncrByFloatCalls() []struct {
	Key   string
	Value float64
} {
	var calls []struct {
		Key   string
		Value float64
	}
	lockUniversalClientMockIncrByFloat.RLock()
	calls = mock.calls.IncrByFloat
	lockUniversalClientMockIncrByFloat.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *UniversalClientMock) Info(section ...string) *redis.StringCmd {
	if mock.InfoFunc == nil {
		panic("UniversalClientMock.InfoFunc: method is nil but UniversalClient.Info was just called")
	}
	callInfo := struct {
		Section []string
	}{
		Section: section,
	}
	lockUniversalClientMockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	lockUniversalClientMockInfo.Unlock()
	return mock.InfoFunc(section...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//     len(mockedUniversalClient.InfoCalls())
func (mock *UniversalClientMock) InfoCalls() []struct {
	Section []string
} {
	var calls []struct {
		Section []string
	}
	lockUniversalClientMockInfo.RLock()
	calls = mock.calls.Info
	lockUniversalClientMockInfo.RUnlock()
	return calls
}

// Keys calls KeysFunc.
func (mock *UniversalClientMock) Keys(pattern string) *redis.StringSliceCmd {
	if mock.KeysFunc == nil {
		panic("UniversalClientMock.KeysFunc: method is nil but UniversalClient.Keys was just called")
	}
	callInfo := struct {
		Pattern string
	}{
		Pattern: pattern,
	}
	lockUniversalClientMockKeys.Lock()
	mock.calls.Keys = append(mock.calls.Keys, callInfo)
	lockUniversalClientMockKeys.Unlock()
	return mock.KeysFunc(pattern)
}

// KeysCalls gets all the calls that were made to Keys.
// Check the length with:
//     len(mockedUniversalClient.KeysCalls())
func (mock *UniversalClientMock) KeysCalls() []struct {
	Pattern string
} {
	var calls []struct {
		Pattern string
	}
	lockUniversalClientMockKeys.RLock()
	calls = mock.calls.Keys
	lockUniversalClientMockKeys.RUnlock()
	return calls
}

// LIndex calls LIndexFunc.
func (mock *UniversalClientMock) LIndex(key string, index int64) *redis.StringCmd {
	if mock.LIndexFunc == nil {
		panic("UniversalClientMock.LIndexFunc: method is nil but UniversalClient.LIndex was just called")
	}
	callInfo := struct {
		Key   string
		Index int64
	}{
		Key:   key,
		Index: index,
	}
	lockUniversalClientMockLIndex.Lock()
	mock.calls.LIndex = append(mock.calls.LIndex, callInfo)
	lockUniversalClientMockLIndex.Unlock()
	return mock.LIndexFunc(key, index)
}

// LIndexCalls gets all the calls that were made to LIndex.
// Check the length with:
//     len(mockedUniversalClient.LIndexCalls())
func (mock *UniversalClientMock) LIndexCalls() []struct {
	Key   string
	Index int64
} {
	var calls []struct {
		Key   string
		Index int64
	}
	lockUniversalClientMockLIndex.RLock()
	calls = mock.calls.LIndex
	lockUniversalClientMockLIndex.RUnlock()
	return calls
}

// LInsert calls LInsertFunc.
func (mock *UniversalClientMock) LInsert(key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
	if mock.LInsertFunc == nil {
		panic("UniversalClientMock.LInsertFunc: method is nil but UniversalClient.LInsert was just called")
	}
	callInfo := struct {
		Key   string
		Op    string
		Pivot interface{}
		Value interface{}
	}{
		Key:   key,
		Op:    op,
		Pivot: pivot,
		Value: value,
	}
	lockUniversalClientMockLInsert.Lock()
	mock.calls.LInsert = append(mock.calls.LInsert, callInfo)
	lockUniversalClientMockLInsert.Unlock()
	return mock.LInsertFunc(key, op, pivot, value)
}

// LInsertCalls gets all the calls that were made to LInsert.
// Check the length with:
//     len(mockedUniversalClient.LInsertCalls())
func (mock *UniversalClientMock) LInsertCalls() []struct {
	Key   string
	Op    string
	Pivot interface{}
	Value interface{}
} {
	var calls []struct {
		Key   string
		Op    string
		Pivot interface{}
		Value interface{}
	}
	lockUniversalClientMockLInsert.RLock()
	calls = mock.calls.LInsert
	lockUniversalClientMockLInsert.RUnlock()
	return calls
}

// LInsertAfter calls LInsertAfterFunc.
func (mock *UniversalClientMock) LInsertAfter(key string, pivot interface{}, value interface{}) *redis.IntCmd {
	if mock.LInsertAfterFunc == nil {
		panic("UniversalClientMock.LInsertAfterFunc: method is nil but UniversalClient.LInsertAfter was just called")
	}
	callInfo := struct {
		Key   string
		Pivot interface{}
		Value interface{}
	}{
		Key:   key,
		Pivot: pivot,
		Value: value,
	}
	lockUniversalClientMockLInsertAfter.Lock()
	mock.calls.LInsertAfter = append(mock.calls.LInsertAfter, callInfo)
	lockUniversalClientMockLInsertAfter.Unlock()
	return mock.LInsertAfterFunc(key, pivot, value)
}

// LInsertAfterCalls gets all the calls that were made to LInsertAfter.
// Check the length with:
//     len(mockedUniversalClient.LInsertAfterCalls())
func (mock *UniversalClientMock) LInsertAfterCalls() []struct {
	Key   string
	Pivot interface{}
	Value interface{}
} {
	var calls []struct {
		Key   string
		Pivot interface{}
		Value interface{}
	}
	lockUniversalClientMockLInsertAfter.RLock()
	calls = mock.calls.LInsertAfter
	lockUniversalClientMockLInsertAfter.RUnlock()
	return calls
}

// LInsertBefore calls LInsertBeforeFunc.
func (mock *UniversalClientMock) LInsertBefore(key string, pivot interface{}, value interface{}) *redis.IntCmd {
	if mock.LInsertBeforeFunc == nil {
		panic("UniversalClientMock.LInsertBeforeFunc: method is nil but UniversalClient.LInsertBefore was just called")
	}
	callInfo := struct {
		Key   string
		Pivot interface{}
		Value interface{}
	}{
		Key:   key,
		Pivot: pivot,
		Value: value,
	}
	lockUniversalClientMockLInsertBefore.Lock()
	mock.calls.LInsertBefore = append(mock.calls.LInsertBefore, callInfo)
	lockUniversalClientMockLInsertBefore.Unlock()
	return mock.LInsertBeforeFunc(key, pivot, value)
}

// LInsertBeforeCalls gets all the calls that were made to LInsertBefore.
// Check the length with:
//     len(mockedUniversalClient.LInsertBeforeCalls())
func (mock *UniversalClientMock) LInsertBeforeCalls() []struct {
	Key   string
	Pivot interface{}
	Value interface{}
} {
	var calls []struct {
		Key   string
		Pivot interface{}
		Value interface{}
	}
	lockUniversalClientMockLInsertBefore.RLock()
	calls = mock.calls.LInsertBefore
	lockUniversalClientMockLInsertBefore.RUnlock()
	return calls
}

// LLen calls LLenFunc.
func (mock *UniversalClientMock) LLen(key string) *redis.IntCmd {
	if mock.LLenFunc == nil {
		panic("UniversalClientMock.LLenFunc: method is nil but UniversalClient.LLen was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockLLen.Lock()
	mock.calls.LLen = append(mock.calls.LLen, callInfo)
	lockUniversalClientMockLLen.Unlock()
	return mock.LLenFunc(key)
}

// LLenCalls gets all the calls that were made to LLen.
// Check the length with:
//     len(mockedUniversalClient.LLenCalls())
func (mock *UniversalClientMock) LLenCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockLLen.RLock()
	calls = mock.calls.LLen
	lockUniversalClientMockLLen.RUnlock()
	return calls
}

// LPop calls LPopFunc.
func (mock *UniversalClientMock) LPop(key string) *redis.StringCmd {
	if mock.LPopFunc == nil {
		panic("UniversalClientMock.LPopFunc: method is nil but UniversalClient.LPop was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockLPop.Lock()
	mock.calls.LPop = append(mock.calls.LPop, callInfo)
	lockUniversalClientMockLPop.Unlock()
	return mock.LPopFunc(key)
}

// LPopCalls gets all the calls that were made to LPop.
// Check the length with:
//     len(mockedUniversalClient.LPopCalls())
func (mock *UniversalClientMock) LPopCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockLPop.RLock()
	calls = mock.calls.LPop
	lockUniversalClientMockLPop.RUnlock()
	return calls
}

// LPush calls LPushFunc.
func (mock *UniversalClientMock) LPush(key string, values ...interface{}) *redis.IntCmd {
	if mock.LPushFunc == nil {
		panic("UniversalClientMock.LPushFunc: method is nil but UniversalClient.LPush was just called")
	}
	callInfo := struct {
		Key    string
		Values []interface{}
	}{
		Key:    key,
		Values: values,
	}
	lockUniversalClientMockLPush.Lock()
	mock.calls.LPush = append(mock.calls.LPush, callInfo)
	lockUniversalClientMockLPush.Unlock()
	return mock.LPushFunc(key, values...)
}

// LPushCalls gets all the calls that were made to LPush.
// Check the length with:
//     len(mockedUniversalClient.LPushCalls())
func (mock *UniversalClientMock) LPushCalls() []struct {
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Key    string
		Values []interface{}
	}
	lockUniversalClientMockLPush.RLock()
	calls = mock.calls.LPush
	lockUniversalClientMockLPush.RUnlock()
	return calls
}

// LPushX calls LPushXFunc.
func (mock *UniversalClientMock) LPushX(key string, value interface{}) *redis.IntCmd {
	if mock.LPushXFunc == nil {
		panic("UniversalClientMock.LPushXFunc: method is nil but UniversalClient.LPushX was just called")
	}
	callInfo := struct {
		Key   string
		Value interface{}
	}{
		Key:   key,
		Value: value,
	}
	lockUniversalClientMockLPushX.Lock()
	mock.calls.LPushX = append(mock.calls.LPushX, callInfo)
	lockUniversalClientMockLPushX.Unlock()
	return mock.LPushXFunc(key, value)
}

// LPushXCalls gets all the calls that were made to LPushX.
// Check the length with:
//     len(mockedUniversalClient.LPushXCalls())
func (mock *UniversalClientMock) LPushXCalls() []struct {
	Key   string
	Value interface{}
} {
	var calls []struct {
		Key   string
		Value interface{}
	}
	lockUniversalClientMockLPushX.RLock()
	calls = mock.calls.LPushX
	lockUniversalClientMockLPushX.RUnlock()
	return calls
}

// LRange calls LRangeFunc.
func (mock *UniversalClientMock) LRange(key string, start int64, stop int64) *redis.StringSliceCmd {
	if mock.LRangeFunc == nil {
		panic("UniversalClientMock.LRangeFunc: method is nil but UniversalClient.LRange was just called")
	}
	callInfo := struct {
		Key   string
		Start int64
		Stop  int64
	}{
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	lockUniversalClientMockLRange.Lock()
	mock.calls.LRange = append(mock.calls.LRange, callInfo)
	lockUniversalClientMockLRange.Unlock()
	return mock.LRangeFunc(key, start, stop)
}

// LRangeCalls gets all the calls that were made to LRange.
// Check the length with:
//     len(mockedUniversalClient.LRangeCalls())
func (mock *UniversalClientMock) LRangeCalls() []struct {
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Key   string
		Start int64
		Stop  int64
	}
	lockUniversalClientMockLRange.RLock()
	calls = mock.calls.LRange
	lockUniversalClientMockLRange.RUnlock()
	return calls
}

// LRem calls LRemFunc.
func (mock *UniversalClientMock) LRem(key string, count int64, value interface{}) *redis.IntCmd {
	if mock.LRemFunc == nil {
		panic("UniversalClientMock.LRemFunc: method is nil but UniversalClient.LRem was just called")
	}
	callInfo := struct {
		Key   string
		Count int64
		Value interface{}
	}{
		Key:   key,
		Count: count,
		Value: value,
	}
	lockUniversalClientMockLRem.Lock()
	mock.calls.LRem = append(mock.calls.LRem, callInfo)
	lockUniversalClientMockLRem.Unlock()
	return mock.LRemFunc(key, count, value)
}

// LRemCalls gets all the calls that were made to LRem.
// Check the length with:
//     len(mockedUniversalClient.LRemCalls())
func (mock *UniversalClientMock) LRemCalls() []struct {
	Key   string
	Count int64
	Value interface{}
} {
	var calls []struct {
		Key   string
		Count int64
		Value interface{}
	}
	lockUniversalClientMockLRem.RLock()
	calls = mock.calls.LRem
	lockUniversalClientMockLRem.RUnlock()
	return calls
}

// LSet calls LSetFunc.
func (mock *UniversalClientMock) LSet(key string, index int64, value interface{}) *redis.StatusCmd {
	if mock.LSetFunc == nil {
		panic("UniversalClientMock.LSetFunc: method is nil but UniversalClient.LSet was just called")
	}
	callInfo := struct {
		Key   string
		Index int64
		Value interface{}
	}{
		Key:   key,
		Index: index,
		Value: value,
	}
	lockUniversalClientMockLSet.Lock()
	mock.calls.LSet = append(mock.calls.LSet, callInfo)
	lockUniversalClientMockLSet.Unlock()
	return mock.LSetFunc(key, index, value)
}

// LSetCalls gets all the calls that were made to LSet.
// Check the length with:
//     len(mockedUniversalClient.LSetCalls())
func (mock *UniversalClientMock) LSetCalls() []struct {
	Key   string
	Index int64
	Value interface{}
} {
	var calls []struct {
		Key   string
		Index int64
		Value interface{}
	}
	lockUniversalClientMockLSet.RLock()
	calls = mock.calls.LSet
	lockUniversalClientMockLSet.RUnlock()
	return calls
}

// LTrim calls LTrimFunc.
func (mock *UniversalClientMock) LTrim(key string, start int64, stop int64) *redis.StatusCmd {
	if mock.LTrimFunc == nil {
		panic("UniversalClientMock.LTrimFunc: method is nil but UniversalClient.LTrim was just called")
	}
	callInfo := struct {
		Key   string
		Start int64
		Stop  int64
	}{
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	lockUniversalClientMockLTrim.Lock()
	mock.calls.LTrim = append(mock.calls.LTrim, callInfo)
	lockUniversalClientMockLTrim.Unlock()
	return mock.LTrimFunc(key, start, stop)
}

// LTrimCalls gets all the calls that were made to LTrim.
// Check the length with:
//     len(mockedUniversalClient.LTrimCalls())
func (mock *UniversalClientMock) LTrimCalls() []struct {
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Key   string
		Start int64
		Stop  int64
	}
	lockUniversalClientMockLTrim.RLock()
	calls = mock.calls.LTrim
	lockUniversalClientMockLTrim.RUnlock()
	return calls
}

// LastSave calls LastSaveFunc.
func (mock *UniversalClientMock) LastSave() *redis.IntCmd {
	if mock.LastSaveFunc == nil {
		panic("UniversalClientMock.LastSaveFunc: method is nil but UniversalClient.LastSave was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockLastSave.Lock()
	mock.calls.LastSave = append(mock.calls.LastSave, callInfo)
	lockUniversalClientMockLastSave.Unlock()
	return mock.LastSaveFunc()
}

// LastSaveCalls gets all the calls that were made to LastSave.
// Check the length with:
//     len(mockedUniversalClient.LastSaveCalls())
func (mock *UniversalClientMock) LastSaveCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockLastSave.RLock()
	calls = mock.calls.LastSave
	lockUniversalClientMockLastSave.RUnlock()
	return calls
}

// MGet calls MGetFunc.
func (mock *UniversalClientMock) MGet(keys ...string) *redis.SliceCmd {
	if mock.MGetFunc == nil {
		panic("UniversalClientMock.MGetFunc: method is nil but UniversalClient.MGet was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockMGet.Lock()
	mock.calls.MGet = append(mock.calls.MGet, callInfo)
	lockUniversalClientMockMGet.Unlock()
	return mock.MGetFunc(keys...)
}

// MGetCalls gets all the calls that were made to MGet.
// Check the length with:
//     len(mockedUniversalClient.MGetCalls())
func (mock *UniversalClientMock) MGetCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockMGet.RLock()
	calls = mock.calls.MGet
	lockUniversalClientMockMGet.RUnlock()
	return calls
}

// MSet calls MSetFunc.
func (mock *UniversalClientMock) MSet(pairs ...interface{}) *redis.StatusCmd {
	if mock.MSetFunc == nil {
		panic("UniversalClientMock.MSetFunc: method is nil but UniversalClient.MSet was just called")
	}
	callInfo := struct {
		Pairs []interface{}
	}{
		Pairs: pairs,
	}
	lockUniversalClientMockMSet.Lock()
	mock.calls.MSet = append(mock.calls.MSet, callInfo)
	lockUniversalClientMockMSet.Unlock()
	return mock.MSetFunc(pairs...)
}

// MSetCalls gets all the calls that were made to MSet.
// Check the length with:
//     len(mockedUniversalClient.MSetCalls())
func (mock *UniversalClientMock) MSetCalls() []struct {
	Pairs []interface{}
} {
	var calls []struct {
		Pairs []interface{}
	}
	lockUniversalClientMockMSet.RLock()
	calls = mock.calls.MSet
	lockUniversalClientMockMSet.RUnlock()
	return calls
}

// MSetNX calls MSetNXFunc.
func (mock *UniversalClientMock) MSetNX(pairs ...interface{}) *redis.BoolCmd {
	if mock.MSetNXFunc == nil {
		panic("UniversalClientMock.MSetNXFunc: method is nil but UniversalClient.MSetNX was just called")
	}
	callInfo := struct {
		Pairs []interface{}
	}{
		Pairs: pairs,
	}
	lockUniversalClientMockMSetNX.Lock()
	mock.calls.MSetNX = append(mock.calls.MSetNX, callInfo)
	lockUniversalClientMockMSetNX.Unlock()
	return mock.MSetNXFunc(pairs...)
}

// MSetNXCalls gets all the calls that were made to MSetNX.
// Check the length with:
//     len(mockedUniversalClient.MSetNXCalls())
func (mock *UniversalClientMock) MSetNXCalls() []struct {
	Pairs []interface{}
} {
	var calls []struct {
		Pairs []interface{}
	}
	lockUniversalClientMockMSetNX.RLock()
	calls = mock.calls.MSetNX
	lockUniversalClientMockMSetNX.RUnlock()
	return calls
}

// MemoryUsage calls MemoryUsageFunc.
func (mock *UniversalClientMock) MemoryUsage(key string, samples ...int) *redis.IntCmd {
	if mock.MemoryUsageFunc == nil {
		panic("UniversalClientMock.MemoryUsageFunc: method is nil but UniversalClient.MemoryUsage was just called")
	}
	callInfo := struct {
		Key     string
		Samples []int
	}{
		Key:     key,
		Samples: samples,
	}
	lockUniversalClientMockMemoryUsage.Lock()
	mock.calls.MemoryUsage = append(mock.calls.MemoryUsage, callInfo)
	lockUniversalClientMockMemoryUsage.Unlock()
	return mock.MemoryUsageFunc(key, samples...)
}

// MemoryUsageCalls gets all the calls that were made to MemoryUsage.
// Check the length with:
//     len(mockedUniversalClient.MemoryUsageCalls())
func (mock *UniversalClientMock) MemoryUsageCalls() []struct {
	Key     string
	Samples []int
} {
	var calls []struct {
		Key     string
		Samples []int
	}
	lockUniversalClientMockMemoryUsage.RLock()
	calls = mock.calls.MemoryUsage
	lockUniversalClientMockMemoryUsage.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *UniversalClientMock) Migrate(host string, port string, key string, db int64, timeout time.Duration) *redis.StatusCmd {
	if mock.MigrateFunc == nil {
		panic("UniversalClientMock.MigrateFunc: method is nil but UniversalClient.Migrate was just called")
	}
	callInfo := struct {
		Host    string
		Port    string
		Key     string
		Db      int64
		Timeout time.Duration
	}{
		Host:    host,
		Port:    port,
		Key:     key,
		Db:      db,
		Timeout: timeout,
	}
	lockUniversalClientMockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	lockUniversalClientMockMigrate.Unlock()
	return mock.MigrateFunc(host, port, key, db, timeout)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//     len(mockedUniversalClient.MigrateCalls())
func (mock *UniversalClientMock) MigrateCalls() []struct {
	Host    string
	Port    string
	Key     string
	Db      int64
	Timeout time.Duration
} {
	var calls []struct {
		Host    string
		Port    string
		Key     string
		Db      int64
		Timeout time.Duration
	}
	lockUniversalClientMockMigrate.RLock()
	calls = mock.calls.Migrate
	lockUniversalClientMockMigrate.RUnlock()
	return calls
}

// Move calls MoveFunc.
func (mock *UniversalClientMock) Move(key string, db int64) *redis.BoolCmd {
	if mock.MoveFunc == nil {
		panic("UniversalClientMock.MoveFunc: method is nil but UniversalClient.Move was just called")
	}
	callInfo := struct {
		Key string
		Db  int64
	}{
		Key: key,
		Db:  db,
	}
	lockUniversalClientMockMove.Lock()
	mock.calls.Move = append(mock.calls.Move, callInfo)
	lockUniversalClientMockMove.Unlock()
	return mock.MoveFunc(key, db)
}

// MoveCalls gets all the calls that were made to Move.
// Check the length with:
//     len(mockedUniversalClient.MoveCalls())
func (mock *UniversalClientMock) MoveCalls() []struct {
	Key string
	Db  int64
} {
	var calls []struct {
		Key string
		Db  int64
	}
	lockUniversalClientMockMove.RLock()
	calls = mock.calls.Move
	lockUniversalClientMockMove.RUnlock()
	return calls
}

// ObjectEncoding calls ObjectEncodingFunc.
func (mock *UniversalClientMock) ObjectEncoding(key string) *redis.StringCmd {
	if mock.ObjectEncodingFunc == nil {
		panic("UniversalClientMock.ObjectEncodingFunc: method is nil but UniversalClient.ObjectEncoding was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockObjectEncoding.Lock()
	mock.calls.ObjectEncoding = append(mock.calls.ObjectEncoding, callInfo)
	lockUniversalClientMockObjectEncoding.Unlock()
	return mock.ObjectEncodingFunc(key)
}

// ObjectEncodingCalls gets all the calls that were made to ObjectEncoding.
// Check the length with:
//     len(mockedUniversalClient.ObjectEncodingCalls())
func (mock *UniversalClientMock) ObjectEncodingCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockObjectEncoding.RLock()
	calls = mock.calls.ObjectEncoding
	lockUniversalClientMockObjectEncoding.RUnlock()
	return calls
}

// ObjectIdleTime calls ObjectIdleTimeFunc.
func (mock *UniversalClientMock) ObjectIdleTime(key string) *redis.DurationCmd {
	if mock.ObjectIdleTimeFunc == nil {
		panic("UniversalClientMock.ObjectIdleTimeFunc: method is nil but UniversalClient.ObjectIdleTime was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockObjectIdleTime.Lock()
	mock.calls.ObjectIdleTime = append(mock.calls.ObjectIdleTime, callInfo)
	lockUniversalClientMockObjectIdleTime.Unlock()
	return mock.ObjectIdleTimeFunc(key)
}

// ObjectIdleTimeCalls gets all the calls that were made to ObjectIdleTime.
// Check the length with:
//     len(mockedUniversalClient.ObjectIdleTimeCalls())
func (mock *UniversalClientMock) ObjectIdleTimeCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockObjectIdleTime.RLock()
	calls = mock.calls.ObjectIdleTime
	lockUniversalClientMockObjectIdleTime.RUnlock()
	return calls
}

// ObjectRefCount calls ObjectRefCountFunc.
func (mock *UniversalClientMock) ObjectRefCount(key string) *redis.IntCmd {
	if mock.ObjectRefCountFunc == nil {
		panic("UniversalClientMock.ObjectRefCountFunc: method is nil but UniversalClient.ObjectRefCount was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockObjectRefCount.Lock()
	mock.calls.ObjectRefCount = append(mock.calls.ObjectRefCount, callInfo)
	lockUniversalClientMockObjectRefCount.Unlock()
	return mock.ObjectRefCountFunc(key)
}

// ObjectRefCountCalls gets all the calls that were made to ObjectRefCount.
// Check the length with:
//     len(mockedUniversalClient.ObjectRefCountCalls())
func (mock *UniversalClientMock) ObjectRefCountCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockObjectRefCount.RLock()
	calls = mock.calls.ObjectRefCount
	lockUniversalClientMockObjectRefCount.RUnlock()
	return calls
}

// PExpire calls PExpireFunc.
func (mock *UniversalClientMock) PExpire(key string, expiration time.Duration) *redis.BoolCmd {
	if mock.PExpireFunc == nil {
		panic("UniversalClientMock.PExpireFunc: method is nil but UniversalClient.PExpire was just called")
	}
	callInfo := struct {
		Key        string
		Expiration time.Duration
	}{
		Key:        key,
		Expiration: expiration,
	}
	lockUniversalClientMockPExpire.Lock()
	mock.calls.PExpire = append(mock.calls.PExpire, callInfo)
	lockUniversalClientMockPExpire.Unlock()
	return mock.PExpireFunc(key, expiration)
}

// PExpireCalls gets all the calls that were made to PExpire.
// Check the length with:
//     len(mockedUniversalClient.PExpireCalls())
func (mock *UniversalClientMock) PExpireCalls() []struct {
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Key        string
		Expiration time.Duration
	}
	lockUniversalClientMockPExpire.RLock()
	calls = mock.calls.PExpire
	lockUniversalClientMockPExpire.RUnlock()
	return calls
}

// PExpireAt calls PExpireAtFunc.
func (mock *UniversalClientMock) PExpireAt(key string, tm time.Time) *redis.BoolCmd {
	if mock.PExpireAtFunc == nil {
		panic("UniversalClientMock.PExpireAtFunc: method is nil but UniversalClient.PExpireAt was just called")
	}
	callInfo := struct {
		Key string
		Tm  time.Time
	}{
		Key: key,
		Tm:  tm,
	}
	lockUniversalClientMockPExpireAt.Lock()
	mock.calls.PExpireAt = append(mock.calls.PExpireAt, callInfo)
	lockUniversalClientMockPExpireAt.Unlock()
	return mock.PExpireAtFunc(key, tm)
}

// PExpireAtCalls gets all the calls that were made to PExpireAt.
// Check the length with:
//     len(mockedUniversalClient.PExpireAtCalls())
func (mock *UniversalClientMock) PExpireAtCalls() []struct {
	Key string
	Tm  time.Time
} {
	var calls []struct {
		Key string
		Tm  time.Time
	}
	lockUniversalClientMockPExpireAt.RLock()
	calls = mock.calls.PExpireAt
	lockUniversalClientMockPExpireAt.RUnlock()
	return calls
}

// PFAdd calls PFAddFunc.
func (mock *UniversalClientMock) PFAdd(key string, els ...interface{}) *redis.IntCmd {
	if mock.PFAddFunc == nil {
		panic("UniversalClientMock.PFAddFunc: method is nil but UniversalClient.PFAdd was just called")
	}
	callInfo := struct {
		Key string
		Els []interface{}
	}{
		Key: key,
		Els: els,
	}
	lockUniversalClientMockPFAdd.Lock()
	mock.calls.PFAdd = append(mock.calls.PFAdd, callInfo)
	lockUniversalClientMockPFAdd.Unlock()
	return mock.PFAddFunc(key, els...)
}

// PFAddCalls gets all the calls that were made to PFAdd.
// Check the length with:
//     len(mockedUniversalClient.PFAddCalls())
func (mock *UniversalClientMock) PFAddCalls() []struct {
	Key string
	Els []interface{}
} {
	var calls []struct {
		Key string
		Els []interface{}
	}
	lockUniversalClientMockPFAdd.RLock()
	calls = mock.calls.PFAdd
	lockUniversalClientMockPFAdd.RUnlock()
	return calls
}

// PFCount calls PFCountFunc.
func (mock *UniversalClientMock) PFCount(keys ...string) *redis.IntCmd {
	if mock.PFCountFunc == nil {
		panic("UniversalClientMock.PFCountFunc: method is nil but UniversalClient.PFCount was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockPFCount.Lock()
	mock.calls.PFCount = append(mock.calls.PFCount, callInfo)
	lockUniversalClientMockPFCount.Unlock()
	return mock.PFCountFunc(keys...)
}

// PFCountCalls gets all the calls that were made to PFCount.
// Check the length with:
//     len(mockedUniversalClient.PFCountCalls())
func (mock *UniversalClientMock) PFCountCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockPFCount.RLock()
	calls = mock.calls.PFCount
	lockUniversalClientMockPFCount.RUnlock()
	return calls
}

// PFMerge calls PFMergeFunc.
func (mock *UniversalClientMock) PFMerge(dest string, keys ...string) *redis.StatusCmd {
	if mock.PFMergeFunc == nil {
		panic("UniversalClientMock.PFMergeFunc: method is nil but UniversalClient.PFMerge was just called")
	}
	callInfo := struct {
		Dest string
		Keys []string
	}{
		Dest: dest,
		Keys: keys,
	}
	lockUniversalClientMockPFMerge.Lock()
	mock.calls.PFMerge = append(mock.calls.PFMerge, callInfo)
	lockUniversalClientMockPFMerge.Unlock()
	return mock.PFMergeFunc(dest, keys...)
}

// PFMergeCalls gets all the calls that were made to PFMerge.
// Check the length with:
//     len(mockedUniversalClient.PFMergeCalls())
func (mock *UniversalClientMock) PFMergeCalls() []struct {
	Dest string
	Keys []string
} {
	var calls []struct {
		Dest string
		Keys []string
	}
	lockUniversalClientMockPFMerge.RLock()
	calls = mock.calls.PFMerge
	lockUniversalClientMockPFMerge.RUnlock()
	return calls
}

// PSubscribe calls PSubscribeFunc.
func (mock *UniversalClientMock) PSubscribe(channels ...string) *redis.PubSub {
	if mock.PSubscribeFunc == nil {
		panic("UniversalClientMock.PSubscribeFunc: method is nil but UniversalClient.PSubscribe was just called")
	}
	callInfo := struct {
		Channels []string
	}{
		Channels: channels,
	}
	lockUniversalClientMockPSubscribe.Lock()
	mock.calls.PSubscribe = append(mock.calls.PSubscribe, callInfo)
	lockUniversalClientMockPSubscribe.Unlock()
	return mock.PSubscribeFunc(channels...)
}

// PSubscribeCalls gets all the calls that were made to PSubscribe.
// Check the length with:
//     len(mockedUniversalClient.PSubscribeCalls())
func (mock *UniversalClientMock) PSubscribeCalls() []struct {
	Channels []string
} {
	var calls []struct {
		Channels []string
	}
	lockUniversalClientMockPSubscribe.RLock()
	calls = mock.calls.PSubscribe
	lockUniversalClientMockPSubscribe.RUnlock()
	return calls
}

// PTTL calls PTTLFunc.
func (mock *UniversalClientMock) PTTL(key string) *redis.DurationCmd {
	if mock.PTTLFunc == nil {
		panic("UniversalClientMock.PTTLFunc: method is nil but UniversalClient.PTTL was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockPTTL.Lock()
	mock.calls.PTTL = append(mock.calls.PTTL, callInfo)
	lockUniversalClientMockPTTL.Unlock()
	return mock.PTTLFunc(key)
}

// PTTLCalls gets all the calls that were made to PTTL.
// Check the length with:
//     len(mockedUniversalClient.PTTLCalls())
func (mock *UniversalClientMock) PTTLCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockPTTL.RLock()
	calls = mock.calls.PTTL
	lockUniversalClientMockPTTL.RUnlock()
	return calls
}

// Persist calls PersistFunc.
func (mock *UniversalClientMock) Persist(key string) *redis.BoolCmd {
	if mock.PersistFunc == nil {
		panic("UniversalClientMock.PersistFunc: method is nil but UniversalClient.Persist was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockPersist.Lock()
	mock.calls.Persist = append(mock.calls.Persist, callInfo)
	lockUniversalClientMockPersist.Unlock()
	return mock.PersistFunc(key)
}

// PersistCalls gets all the calls that were made to Persist.
// Check the length with:
//     len(mockedUniversalClient.PersistCalls())
func (mock *UniversalClientMock) PersistCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockPersist.RLock()
	calls = mock.calls.Persist
	lockUniversalClientMockPersist.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *UniversalClientMock) Ping() *redis.StatusCmd {
	if mock.PingFunc == nil {
		panic("UniversalClientMock.PingFunc: method is nil but UniversalClient.Ping was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	lockUniversalClientMockPing.Unlock()
	return mock.PingFunc()
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//     len(mockedUniversalClient.PingCalls())
func (mock *UniversalClientMock) PingCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockPing.RLock()
	calls = mock.calls.Ping
	lockUniversalClientMockPing.RUnlock()
	return calls
}

// Pipeline calls PipelineFunc.
func (mock *UniversalClientMock) Pipeline() redis.Pipeliner {
	if mock.PipelineFunc == nil {
		panic("UniversalClientMock.PipelineFunc: method is nil but UniversalClient.Pipeline was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockPipeline.Lock()
	mock.calls.Pipeline = append(mock.calls.Pipeline, callInfo)
	lockUniversalClientMockPipeline.Unlock()
	return mock.PipelineFunc()
}

// PipelineCalls gets all the calls that were made to Pipeline.
// Check the length with:
//     len(mockedUniversalClient.PipelineCalls())
func (mock *UniversalClientMock) PipelineCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockPipeline.RLock()
	calls = mock.calls.Pipeline
	lockUniversalClientMockPipeline.RUnlock()
	return calls
}

// Pipelined calls PipelinedFunc.
func (mock *UniversalClientMock) Pipelined(fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	if mock.PipelinedFunc == nil {
		panic("UniversalClientMock.PipelinedFunc: method is nil but UniversalClient.Pipelined was just called")
	}
	callInfo := struct {
		Fn func(redis.Pipeliner) error
	}{
		Fn: fn,
	}
	lockUniversalClientMockPipelined.Lock()
	mock.calls.Pipelined = append(mock.calls.Pipelined, callInfo)
	lockUniversalClientMockPipelined.Unlock()
	return mock.PipelinedFunc(fn)
}

// PipelinedCalls gets all the calls that were made to Pipelined.
// Check the length with:
//     len(mockedUniversalClient.PipelinedCalls())
func (mock *UniversalClientMock) PipelinedCalls() []struct {
	Fn func(redis.Pipeliner) error
} {
	var calls []struct {
		Fn func(redis.Pipeliner) error
	}
	lockUniversalClientMockPipelined.RLock()
	calls = mock.calls.Pipelined
	lockUniversalClientMockPipelined.RUnlock()
	return calls
}

// Process calls ProcessFunc.
func (mock *UniversalClientMock) Process(cmd redis.Cmder) error {
	if mock.ProcessFunc == nil {
		panic("UniversalClientMock.ProcessFunc: method is nil but UniversalClient.Process was just called")
	}
	callInfo := struct {
		Cmd redis.Cmder
	}{
		Cmd: cmd,
	}
	lockUniversalClientMockProcess.Lock()
	mock.calls.Process = append(mock.calls.Process, callInfo)
	lockUniversalClientMockProcess.Unlock()
	return mock.ProcessFunc(cmd)
}

// ProcessCalls gets all the calls that were made to Process.
// Check the length with:
//     len(mockedUniversalClient.ProcessCalls())
func (mock *UniversalClientMock) ProcessCalls() []struct {
	Cmd redis.Cmder
} {
	var calls []struct {
		Cmd redis.Cmder
	}
	lockUniversalClientMockProcess.RLock()
	calls = mock.calls.Process
	lockUniversalClientMockProcess.RUnlock()
	return calls
}

// PubSubChannels calls PubSubChannelsFunc.
func (mock *UniversalClientMock) PubSubChannels(pattern string) *redis.StringSliceCmd {
	if mock.PubSubChannelsFunc == nil {
		panic("UniversalClientMock.PubSubChannelsFunc: method is nil but UniversalClient.PubSubChannels was just called")
	}
	callInfo := struct {
		Pattern string
	}{
		Pattern: pattern,
	}
	lockUniversalClientMockPubSubChannels.Lock()
	mock.calls.PubSubChannels = append(mock.calls.PubSubChannels, callInfo)
	lockUniversalClientMockPubSubChannels.Unlock()
	return mock.PubSubChannelsFunc(pattern)
}

// PubSubChannelsCalls gets all the calls that were made to PubSubChannels.
// Check the length with:
//     len(mockedUniversalClient.PubSubChannelsCalls())
func (mock *UniversalClientMock) PubSubChannelsCalls() []struct {
	Pattern string
} {
	var calls []struct {
		Pattern string
	}
	lockUniversalClientMockPubSubChannels.RLock()
	calls = mock.calls.PubSubChannels
	lockUniversalClientMockPubSubChannels.RUnlock()
	return calls
}

// PubSubNumPat calls PubSubNumPatFunc.
func (mock *UniversalClientMock) PubSubNumPat() *redis.IntCmd {
	if mock.PubSubNumPatFunc == nil {
		panic("UniversalClientMock.PubSubNumPatFunc: method is nil but UniversalClient.PubSubNumPat was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockPubSubNumPat.Lock()
	mock.calls.PubSubNumPat = append(mock.calls.PubSubNumPat, callInfo)
	lockUniversalClientMockPubSubNumPat.Unlock()
	return mock.PubSubNumPatFunc()
}

// PubSubNumPatCalls gets all the calls that were made to PubSubNumPat.
// Check the length with:
//     len(mockedUniversalClient.PubSubNumPatCalls())
func (mock *UniversalClientMock) PubSubNumPatCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockPubSubNumPat.RLock()
	calls = mock.calls.PubSubNumPat
	lockUniversalClientMockPubSubNumPat.RUnlock()
	return calls
}

// PubSubNumSub calls PubSubNumSubFunc.
func (mock *UniversalClientMock) PubSubNumSub(channels ...string) *redis.StringIntMapCmd {
	if mock.PubSubNumSubFunc == nil {
		panic("UniversalClientMock.PubSubNumSubFunc: method is nil but UniversalClient.PubSubNumSub was just called")
	}
	callInfo := struct {
		Channels []string
	}{
		Channels: channels,
	}
	lockUniversalClientMockPubSubNumSub.Lock()
	mock.calls.PubSubNumSub = append(mock.calls.PubSubNumSub, callInfo)
	lockUniversalClientMockPubSubNumSub.Unlock()
	return mock.PubSubNumSubFunc(channels...)
}

// PubSubNumSubCalls gets all the calls that were made to PubSubNumSub.
// Check the length with:
//     len(mockedUniversalClient.PubSubNumSubCalls())
func (mock *UniversalClientMock) PubSubNumSubCalls() []struct {
	Channels []string
} {
	var calls []struct {
		Channels []string
	}
	lockUniversalClientMockPubSubNumSub.RLock()
	calls = mock.calls.PubSubNumSub
	lockUniversalClientMockPubSubNumSub.RUnlock()
	return calls
}

// Publish calls PublishFunc.
func (mock *UniversalClientMock) Publish(channel string, message interface{}) *redis.IntCmd {
	if mock.PublishFunc == nil {
		panic("UniversalClientMock.PublishFunc: method is nil but UniversalClient.Publish was just called")
	}
	callInfo := struct {
		Channel string
		Message interface{}
	}{
		Channel: channel,
		Message: message,
	}
	lockUniversalClientMockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	lockUniversalClientMockPublish.Unlock()
	return mock.PublishFunc(channel, message)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//     len(mockedUniversalClient.PublishCalls())
func (mock *UniversalClientMock) PublishCalls() []struct {
	Channel string
	Message interface{}
} {
	var calls []struct {
		Channel string
		Message interface{}
	}
	lockUniversalClientMockPublish.RLock()
	calls = mock.calls.Publish
	lockUniversalClientMockPublish.RUnlock()
	return calls
}

// Quit calls QuitFunc.
func (mock *UniversalClientMock) Quit() *redis.StatusCmd {
	if mock.QuitFunc == nil {
		panic("UniversalClientMock.QuitFunc: method is nil but UniversalClient.Quit was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockQuit.Lock()
	mock.calls.Quit = append(mock.calls.Quit, callInfo)
	lockUniversalClientMockQuit.Unlock()
	return mock.QuitFunc()
}

// QuitCalls gets all the calls that were made to Quit.
// Check the length with:
//     len(mockedUniversalClient.QuitCalls())
func (mock *UniversalClientMock) QuitCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockQuit.RLock()
	calls = mock.calls.Quit
	lockUniversalClientMockQuit.RUnlock()
	return calls
}

// RPop calls RPopFunc.
func (mock *UniversalClientMock) RPop(key string) *redis.StringCmd {
	if mock.RPopFunc == nil {
		panic("UniversalClientMock.RPopFunc: method is nil but UniversalClient.RPop was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockRPop.Lock()
	mock.calls.RPop = append(mock.calls.RPop, callInfo)
	lockUniversalClientMockRPop.Unlock()
	return mock.RPopFunc(key)
}

// RPopCalls gets all the calls that were made to RPop.
// Check the length with:
//     len(mockedUniversalClient.RPopCalls())
func (mock *UniversalClientMock) RPopCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockRPop.RLock()
	calls = mock.calls.RPop
	lockUniversalClientMockRPop.RUnlock()
	return calls
}

// RPopLPush calls RPopLPushFunc.
func (mock *UniversalClientMock) RPopLPush(source string, destination string) *redis.StringCmd {
	if mock.RPopLPushFunc == nil {
		panic("UniversalClientMock.RPopLPushFunc: method is nil but UniversalClient.RPopLPush was just called")
	}
	callInfo := struct {
		Source      string
		Destination string
	}{
		Source:      source,
		Destination: destination,
	}
	lockUniversalClientMockRPopLPush.Lock()
	mock.calls.RPopLPush = append(mock.calls.RPopLPush, callInfo)
	lockUniversalClientMockRPopLPush.Unlock()
	return mock.RPopLPushFunc(source, destination)
}

// RPopLPushCalls gets all the calls that were made to RPopLPush.
// Check the length with:
//     len(mockedUniversalClient.RPopLPushCalls())
func (mock *UniversalClientMock) RPopLPushCalls() []struct {
	Source      string
	Destination string
} {
	var calls []struct {
		Source      string
		Destination string
	}
	lockUniversalClientMockRPopLPush.RLock()
	calls = mock.calls.RPopLPush
	lockUniversalClientMockRPopLPush.RUnlock()
	return calls
}

// RPush calls RPushFunc.
func (mock *UniversalClientMock) RPush(key string, values ...interface{}) *redis.IntCmd {
	if mock.RPushFunc == nil {
		panic("UniversalClientMock.RPushFunc: method is nil but UniversalClient.RPush was just called")
	}
	callInfo := struct {
		Key    string
		Values []interface{}
	}{
		Key:    key,
		Values: values,
	}
	lockUniversalClientMockRPush.Lock()
	mock.calls.RPush = append(mock.calls.RPush, callInfo)
	lockUniversalClientMockRPush.Unlock()
	return mock.RPushFunc(key, values...)
}

// RPushCalls gets all the calls that were made to RPush.
// Check the length with:
//     len(mockedUniversalClient.RPushCalls())
func (mock *UniversalClientMock) RPushCalls() []struct {
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Key    string
		Values []interface{}
	}
	lockUniversalClientMockRPush.RLock()
	calls = mock.calls.RPush
	lockUniversalClientMockRPush.RUnlock()
	return calls
}

// RPushX calls RPushXFunc.
func (mock *UniversalClientMock) RPushX(key string, value interface{}) *redis.IntCmd {
	if mock.RPushXFunc == nil {
		panic("UniversalClientMock.RPushXFunc: method is nil but UniversalClient.RPushX was just called")
	}
	callInfo := struct {
		Key   string
		Value interface{}
	}{
		Key:   key,
		Value: value,
	}
	lockUniversalClientMockRPushX.Lock()
	mock.calls.RPushX = append(mock.calls.RPushX, callInfo)
	lockUniversalClientMockRPushX.Unlock()
	return mock.RPushXFunc(key, value)
}

// RPushXCalls gets all the calls that were made to RPushX.
// Check the length with:
//     len(mockedUniversalClient.RPushXCalls())
func (mock *UniversalClientMock) RPushXCalls() []struct {
	Key   string
	Value interface{}
} {
	var calls []struct {
		Key   string
		Value interface{}
	}
	lockUniversalClientMockRPushX.RLock()
	calls = mock.calls.RPushX
	lockUniversalClientMockRPushX.RUnlock()
	return calls
}

// RandomKey calls RandomKeyFunc.
func (mock *UniversalClientMock) RandomKey() *redis.StringCmd {
	if mock.RandomKeyFunc == nil {
		panic("UniversalClientMock.RandomKeyFunc: method is nil but UniversalClient.RandomKey was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockRandomKey.Lock()
	mock.calls.RandomKey = append(mock.calls.RandomKey, callInfo)
	lockUniversalClientMockRandomKey.Unlock()
	return mock.RandomKeyFunc()
}

// RandomKeyCalls gets all the calls that were made to RandomKey.
// Check the length with:
//     len(mockedUniversalClient.RandomKeyCalls())
func (mock *UniversalClientMock) RandomKeyCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockRandomKey.RLock()
	calls = mock.calls.RandomKey
	lockUniversalClientMockRandomKey.RUnlock()
	return calls
}

// ReadOnly calls ReadOnlyFunc.
func (mock *UniversalClientMock) ReadOnly() *redis.StatusCmd {
	if mock.ReadOnlyFunc == nil {
		panic("UniversalClientMock.ReadOnlyFunc: method is nil but UniversalClient.ReadOnly was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockReadOnly.Lock()
	mock.calls.ReadOnly = append(mock.calls.ReadOnly, callInfo)
	lockUniversalClientMockReadOnly.Unlock()
	return mock.ReadOnlyFunc()
}

// ReadOnlyCalls gets all the calls that were made to ReadOnly.
// Check the length with:
//     len(mockedUniversalClient.ReadOnlyCalls())
func (mock *UniversalClientMock) ReadOnlyCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockReadOnly.RLock()
	calls = mock.calls.ReadOnly
	lockUniversalClientMockReadOnly.RUnlock()
	return calls
}

// ReadWrite calls ReadWriteFunc.
func (mock *UniversalClientMock) ReadWrite() *redis.StatusCmd {
	if mock.ReadWriteFunc == nil {
		panic("UniversalClientMock.ReadWriteFunc: method is nil but UniversalClient.ReadWrite was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockReadWrite.Lock()
	mock.calls.ReadWrite = append(mock.calls.ReadWrite, callInfo)
	lockUniversalClientMockReadWrite.Unlock()
	return mock.ReadWriteFunc()
}

// ReadWriteCalls gets all the calls that were made to ReadWrite.
// Check the length with:
//     len(mockedUniversalClient.ReadWriteCalls())
func (mock *UniversalClientMock) ReadWriteCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockReadWrite.RLock()
	calls = mock.calls.ReadWrite
	lockUniversalClientMockReadWrite.RUnlock()
	return calls
}

// Rename calls RenameFunc.
func (mock *UniversalClientMock) Rename(key string, newkey string) *redis.StatusCmd {
	if mock.RenameFunc == nil {
		panic("UniversalClientMock.RenameFunc: method is nil but UniversalClient.Rename was just called")
	}
	callInfo := struct {
		Key    string
		Newkey string
	}{
		Key:    key,
		Newkey: newkey,
	}
	lockUniversalClientMockRename.Lock()
	mock.calls.Rename = append(mock.calls.Rename, callInfo)
	lockUniversalClientMockRename.Unlock()
	return mock.RenameFunc(key, newkey)
}

// RenameCalls gets all the calls that were made to Rename.
// Check the length with:
//     len(mockedUniversalClient.RenameCalls())
func (mock *UniversalClientMock) RenameCalls() []struct {
	Key    string
	Newkey string
} {
	var calls []struct {
		Key    string
		Newkey string
	}
	lockUniversalClientMockRename.RLock()
	calls = mock.calls.Rename
	lockUniversalClientMockRename.RUnlock()
	return calls
}

// RenameNX calls RenameNXFunc.
func (mock *UniversalClientMock) RenameNX(key string, newkey string) *redis.BoolCmd {
	if mock.RenameNXFunc == nil {
		panic("UniversalClientMock.RenameNXFunc: method is nil but UniversalClient.RenameNX was just called")
	}
	callInfo := struct {
		Key    string
		Newkey string
	}{
		Key:    key,
		Newkey: newkey,
	}
	lockUniversalClientMockRenameNX.Lock()
	mock.calls.RenameNX = append(mock.calls.RenameNX, callInfo)
	lockUniversalClientMockRenameNX.Unlock()
	return mock.RenameNXFunc(key, newkey)
}

// RenameNXCalls gets all the calls that were made to RenameNX.
// Check the length with:
//     len(mockedUniversalClient.RenameNXCalls())
func (mock *UniversalClientMock) RenameNXCalls() []struct {
	Key    string
	Newkey string
} {
	var calls []struct {
		Key    string
		Newkey string
	}
	lockUniversalClientMockRenameNX.RLock()
	calls = mock.calls.RenameNX
	lockUniversalClientMockRenameNX.RUnlock()
	return calls
}

// Restore calls RestoreFunc.
func (mock *UniversalClientMock) Restore(key string, ttl time.Duration, value string) *redis.StatusCmd {
	if mock.RestoreFunc == nil {
		panic("UniversalClientMock.RestoreFunc: method is nil but UniversalClient.Restore was just called")
	}
	callInfo := struct {
		Key   string
		TTL   time.Duration
		Value string
	}{
		Key:   key,
		TTL:   ttl,
		Value: value,
	}
	lockUniversalClientMockRestore.Lock()
	mock.calls.Restore = append(mock.calls.Restore, callInfo)
	lockUniversalClientMockRestore.Unlock()
	return mock.RestoreFunc(key, ttl, value)
}

// RestoreCalls gets all the calls that were made to Restore.
// Check the length with:
//     len(mockedUniversalClient.RestoreCalls())
func (mock *UniversalClientMock) RestoreCalls() []struct {
	Key   string
	TTL   time.Duration
	Value string
} {
	var calls []struct {
		Key   string
		TTL   time.Duration
		Value string
	}
	lockUniversalClientMockRestore.RLock()
	calls = mock.calls.Restore
	lockUniversalClientMockRestore.RUnlock()
	return calls
}

// RestoreReplace calls RestoreReplaceFunc.
func (mock *UniversalClientMock) RestoreReplace(key string, ttl time.Duration, value string) *redis.StatusCmd {
	if mock.RestoreReplaceFunc == nil {
		panic("UniversalClientMock.RestoreReplaceFunc: method is nil but UniversalClient.RestoreReplace was just called")
	}
	callInfo := struct {
		Key   string
		TTL   time.Duration
		Value string
	}{
		Key:   key,
		TTL:   ttl,
		Value: value,
	}
	lockUniversalClientMockRestoreReplace.Lock()
	mock.calls.RestoreReplace = append(mock.calls.RestoreReplace, callInfo)
	lockUniversalClientMockRestoreReplace.Unlock()
	return mock.RestoreReplaceFunc(key, ttl, value)
}

// RestoreReplaceCalls gets all the calls that were made to RestoreReplace.
// Check the length with:
//     len(mockedUniversalClient.RestoreReplaceCalls())
func (mock *UniversalClientMock) RestoreReplaceCalls() []struct {
	Key   string
	TTL   time.Duration
	Value string
} {
	var calls []struct {
		Key   string
		TTL   time.Duration
		Value string
	}
	lockUniversalClientMockRestoreReplace.RLock()
	calls = mock.calls.RestoreReplace
	lockUniversalClientMockRestoreReplace.RUnlock()
	return calls
}

// SAdd calls SAddFunc.
func (mock *UniversalClientMock) SAdd(key string, members ...interface{}) *redis.IntCmd {
	if mock.SAddFunc == nil {
		panic("UniversalClientMock.SAddFunc: method is nil but UniversalClient.SAdd was just called")
	}
	callInfo := struct {
		Key     string
		Members []interface{}
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockSAdd.Lock()
	mock.calls.SAdd = append(mock.calls.SAdd, callInfo)
	lockUniversalClientMockSAdd.Unlock()
	return mock.SAddFunc(key, members...)
}

// SAddCalls gets all the calls that were made to SAdd.
// Check the length with:
//     len(mockedUniversalClient.SAddCalls())
func (mock *UniversalClientMock) SAddCalls() []struct {
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Key     string
		Members []interface{}
	}
	lockUniversalClientMockSAdd.RLock()
	calls = mock.calls.SAdd
	lockUniversalClientMockSAdd.RUnlock()
	return calls
}

// SCard calls SCardFunc.
func (mock *UniversalClientMock) SCard(key string) *redis.IntCmd {
	if mock.SCardFunc == nil {
		panic("UniversalClientMock.SCardFunc: method is nil but UniversalClient.SCard was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockSCard.Lock()
	mock.calls.SCard = append(mock.calls.SCard, callInfo)
	lockUniversalClientMockSCard.Unlock()
	return mock.SCardFunc(key)
}

// SCardCalls gets all the calls that were made to SCard.
// Check the length with:
//     len(mockedUniversalClient.SCardCalls())
func (mock *UniversalClientMock) SCardCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockSCard.RLock()
	calls = mock.calls.SCard
	lockUniversalClientMockSCard.RUnlock()
	return calls
}

// SDiff calls SDiffFunc.
func (mock *UniversalClientMock) SDiff(keys ...string) *redis.StringSliceCmd {
	if mock.SDiffFunc == nil {
		panic("UniversalClientMock.SDiffFunc: method is nil but UniversalClient.SDiff was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockSDiff.Lock()
	mock.calls.SDiff = append(mock.calls.SDiff, callInfo)
	lockUniversalClientMockSDiff.Unlock()
	return mock.SDiffFunc(keys...)
}

// SDiffCalls gets all the calls that were made to SDiff.
// Check the length with:
//     len(mockedUniversalClient.SDiffCalls())
func (mock *UniversalClientMock) SDiffCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockSDiff.RLock()
	calls = mock.calls.SDiff
	lockUniversalClientMockSDiff.RUnlock()
	return calls
}

// SDiffStore calls SDiffStoreFunc.
func (mock *UniversalClientMock) SDiffStore(destination string, keys ...string) *redis.IntCmd {
	if mock.SDiffStoreFunc == nil {
		panic("UniversalClientMock.SDiffStoreFunc: method is nil but UniversalClient.SDiffStore was just called")
	}
	callInfo := struct {
		Destination string
		Keys        []string
	}{
		Destination: destination,
		Keys:        keys,
	}
	lockUniversalClientMockSDiffStore.Lock()
	mock.calls.SDiffStore = append(mock.calls.SDiffStore, callInfo)
	lockUniversalClientMockSDiffStore.Unlock()
	return mock.SDiffStoreFunc(destination, keys...)
}

// SDiffStoreCalls gets all the calls that were made to SDiffStore.
// Check the length with:
//     len(mockedUniversalClient.SDiffStoreCalls())
func (mock *UniversalClientMock) SDiffStoreCalls() []struct {
	Destination string
	Keys        []string
} {
	var calls []struct {
		Destination string
		Keys        []string
	}
	lockUniversalClientMockSDiffStore.RLock()
	calls = mock.calls.SDiffStore
	lockUniversalClientMockSDiffStore.RUnlock()
	return calls
}

// SInter calls SInterFunc.
func (mock *UniversalClientMock) SInter(keys ...string) *redis.StringSliceCmd {
	if mock.SInterFunc == nil {
		panic("UniversalClientMock.SInterFunc: method is nil but UniversalClient.SInter was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockSInter.Lock()
	mock.calls.SInter = append(mock.calls.SInter, callInfo)
	lockUniversalClientMockSInter.Unlock()
	return mock.SInterFunc(keys...)
}

// SInterCalls gets all the calls that were made to SInter.
// Check the length with:
//     len(mockedUniversalClient.SInterCalls())
func (mock *UniversalClientMock) SInterCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockSInter.RLock()
	calls = mock.calls.SInter
	lockUniversalClientMockSInter.RUnlock()
	return calls
}

// SInterStore calls SInterStoreFunc.
func (mock *UniversalClientMock) SInterStore(destination string, keys ...string) *redis.IntCmd {
	if mock.SInterStoreFunc == nil {
		panic("UniversalClientMock.SInterStoreFunc: method is nil but UniversalClient.SInterStore was just called")
	}
	callInfo := struct {
		Destination string
		Keys        []string
	}{
		Destination: destination,
		Keys:        keys,
	}
	lockUniversalClientMockSInterStore.Lock()
	mock.calls.SInterStore = append(mock.calls.SInterStore, callInfo)
	lockUniversalClientMockSInterStore.Unlock()
	return mock.SInterStoreFunc(destination, keys...)
}

// SInterStoreCalls gets all the calls that were made to SInterStore.
// Check the length with:
//     len(mockedUniversalClient.SInterStoreCalls())
func (mock *UniversalClientMock) SInterStoreCalls() []struct {
	Destination string
	Keys        []string
} {
	var calls []struct {
		Destination string
		Keys        []string
	}
	lockUniversalClientMockSInterStore.RLock()
	calls = mock.calls.SInterStore
	lockUniversalClientMockSInterStore.RUnlock()
	return calls
}

// SIsMember calls SIsMemberFunc.
func (mock *UniversalClientMock) SIsMember(key string, member interface{}) *redis.BoolCmd {
	if mock.SIsMemberFunc == nil {
		panic("UniversalClientMock.SIsMemberFunc: method is nil but UniversalClient.SIsMember was just called")
	}
	callInfo := struct {
		Key    string
		Member interface{}
	}{
		Key:    key,
		Member: member,
	}
	lockUniversalClientMockSIsMember.Lock()
	mock.calls.SIsMember = append(mock.calls.SIsMember, callInfo)
	lockUniversalClientMockSIsMember.Unlock()
	return mock.SIsMemberFunc(key, member)
}

// SIsMemberCalls gets all the calls that were made to SIsMember.
// Check the length with:
//     len(mockedUniversalClient.SIsMemberCalls())
func (mock *UniversalClientMock) SIsMemberCalls() []struct {
	Key    string
	Member interface{}
} {
	var calls []struct {
		Key    string
		Member interface{}
	}
	lockUniversalClientMockSIsMember.RLock()
	calls = mock.calls.SIsMember
	lockUniversalClientMockSIsMember.RUnlock()
	return calls
}

// SMembers calls SMembersFunc.
func (mock *UniversalClientMock) SMembers(key string) *redis.StringSliceCmd {
	if mock.SMembersFunc == nil {
		panic("UniversalClientMock.SMembersFunc: method is nil but UniversalClient.SMembers was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockSMembers.Lock()
	mock.calls.SMembers = append(mock.calls.SMembers, callInfo)
	lockUniversalClientMockSMembers.Unlock()
	return mock.SMembersFunc(key)
}

// SMembersCalls gets all the calls that were made to SMembers.
// Check the length with:
//     len(mockedUniversalClient.SMembersCalls())
func (mock *UniversalClientMock) SMembersCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockSMembers.RLock()
	calls = mock.calls.SMembers
	lockUniversalClientMockSMembers.RUnlock()
	return calls
}

// SMembersMap calls SMembersMapFunc.
func (mock *UniversalClientMock) SMembersMap(key string) *redis.StringStructMapCmd {
	if mock.SMembersMapFunc == nil {
		panic("UniversalClientMock.SMembersMapFunc: method is nil but UniversalClient.SMembersMap was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockSMembersMap.Lock()
	mock.calls.SMembersMap = append(mock.calls.SMembersMap, callInfo)
	lockUniversalClientMockSMembersMap.Unlock()
	return mock.SMembersMapFunc(key)
}

// SMembersMapCalls gets all the calls that were made to SMembersMap.
// Check the length with:
//     len(mockedUniversalClient.SMembersMapCalls())
func (mock *UniversalClientMock) SMembersMapCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockSMembersMap.RLock()
	calls = mock.calls.SMembersMap
	lockUniversalClientMockSMembersMap.RUnlock()
	return calls
}

// SMove calls SMoveFunc.
func (mock *UniversalClientMock) SMove(source string, destination string, member interface{}) *redis.BoolCmd {
	if mock.SMoveFunc == nil {
		panic("UniversalClientMock.SMoveFunc: method is nil but UniversalClient.SMove was just called")
	}
	callInfo := struct {
		Source      string
		Destination string
		Member      interface{}
	}{
		Source:      source,
		Destination: destination,
		Member:      member,
	}
	lockUniversalClientMockSMove.Lock()
	mock.calls.SMove = append(mock.calls.SMove, callInfo)
	lockUniversalClientMockSMove.Unlock()
	return mock.SMoveFunc(source, destination, member)
}

// SMoveCalls gets all the calls that were made to SMove.
// Check the length with:
//     len(mockedUniversalClient.SMoveCalls())
func (mock *UniversalClientMock) SMoveCalls() []struct {
	Source      string
	Destination string
	Member      interface{}
} {
	var calls []struct {
		Source      string
		Destination string
		Member      interface{}
	}
	lockUniversalClientMockSMove.RLock()
	calls = mock.calls.SMove
	lockUniversalClientMockSMove.RUnlock()
	return calls
}

// SPop calls SPopFunc.
func (mock *UniversalClientMock) SPop(key string) *redis.StringCmd {
	if mock.SPopFunc == nil {
		panic("UniversalClientMock.SPopFunc: method is nil but UniversalClient.SPop was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockSPop.Lock()
	mock.calls.SPop = append(mock.calls.SPop, callInfo)
	lockUniversalClientMockSPop.Unlock()
	return mock.SPopFunc(key)
}

// SPopCalls gets all the calls that were made to SPop.
// Check the length with:
//     len(mockedUniversalClient.SPopCalls())
func (mock *UniversalClientMock) SPopCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockSPop.RLock()
	calls = mock.calls.SPop
	lockUniversalClientMockSPop.RUnlock()
	return calls
}

// SPopN calls SPopNFunc.
func (mock *UniversalClientMock) SPopN(key string, count int64) *redis.StringSliceCmd {
	if mock.SPopNFunc == nil {
		panic("UniversalClientMock.SPopNFunc: method is nil but UniversalClient.SPopN was just called")
	}
	callInfo := struct {
		Key   string
		Count int64
	}{
		Key:   key,
		Count: count,
	}
	lockUniversalClientMockSPopN.Lock()
	mock.calls.SPopN = append(mock.calls.SPopN, callInfo)
	lockUniversalClientMockSPopN.Unlock()
	return mock.SPopNFunc(key, count)
}

// SPopNCalls gets all the calls that were made to SPopN.
// Check the length with:
//     len(mockedUniversalClient.SPopNCalls())
func (mock *UniversalClientMock) SPopNCalls() []struct {
	Key   string
	Count int64
} {
	var calls []struct {
		Key   string
		Count int64
	}
	lockUniversalClientMockSPopN.RLock()
	calls = mock.calls.SPopN
	lockUniversalClientMockSPopN.RUnlock()
	return calls
}

// SRandMember calls SRandMemberFunc.
func (mock *UniversalClientMock) SRandMember(key string) *redis.StringCmd {
	if mock.SRandMemberFunc == nil {
		panic("UniversalClientMock.SRandMemberFunc: method is nil but UniversalClient.SRandMember was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockSRandMember.Lock()
	mock.calls.SRandMember = append(mock.calls.SRandMember, callInfo)
	lockUniversalClientMockSRandMember.Unlock()
	return mock.SRandMemberFunc(key)
}

// SRandMemberCalls gets all the calls that were made to SRandMember.
// Check the length with:
//     len(mockedUniversalClient.SRandMemberCalls())
func (mock *UniversalClientMock) SRandMemberCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockSRandMember.RLock()
	calls = mock.calls.SRandMember
	lockUniversalClientMockSRandMember.RUnlock()
	return calls
}

// SRandMemberN calls SRandMemberNFunc.
func (mock *UniversalClientMock) SRandMemberN(key string, count int64) *redis.StringSliceCmd {
	if mock.SRandMemberNFunc == nil {
		panic("UniversalClientMock.SRandMemberNFunc: method is nil but UniversalClient.SRandMemberN was just called")
	}
	callInfo := struct {
		Key   string
		Count int64
	}{
		Key:   key,
		Count: count,
	}
	lockUniversalClientMockSRandMemberN.Lock()
	mock.calls.SRandMemberN = append(mock.calls.SRandMemberN, callInfo)
	lockUniversalClientMockSRandMemberN.Unlock()
	return mock.SRandMemberNFunc(key, count)
}

// SRandMemberNCalls gets all the calls that were made to SRandMemberN.
// Check the length with:
//     len(mockedUniversalClient.SRandMemberNCalls())
func (mock *UniversalClientMock) SRandMemberNCalls() []struct {
	Key   string
	Count int64
} {
	var calls []struct {
		Key   string
		Count int64
	}
	lockUniversalClientMockSRandMemberN.RLock()
	calls = mock.calls.SRandMemberN
	lockUniversalClientMockSRandMemberN.RUnlock()
	return calls
}

// SRem calls SRemFunc.
func (mock *UniversalClientMock) SRem(key string, members ...interface{}) *redis.IntCmd {
	if mock.SRemFunc == nil {
		panic("UniversalClientMock.SRemFunc: method is nil but UniversalClient.SRem was just called")
	}
	callInfo := struct {
		Key     string
		Members []interface{}
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockSRem.Lock()
	mock.calls.SRem = append(mock.calls.SRem, callInfo)
	lockUniversalClientMockSRem.Unlock()
	return mock.SRemFunc(key, members...)
}

// SRemCalls gets all the calls that were made to SRem.
// Check the length with:
//     len(mockedUniversalClient.SRemCalls())
func (mock *UniversalClientMock) SRemCalls() []struct {
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Key     string
		Members []interface{}
	}
	lockUniversalClientMockSRem.RLock()
	calls = mock.calls.SRem
	lockUniversalClientMockSRem.RUnlock()
	return calls
}

// SScan calls SScanFunc.
func (mock *UniversalClientMock) SScan(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.SScanFunc == nil {
		panic("UniversalClientMock.SScanFunc: method is nil but UniversalClient.SScan was just called")
	}
	callInfo := struct {
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	lockUniversalClientMockSScan.Lock()
	mock.calls.SScan = append(mock.calls.SScan, callInfo)
	lockUniversalClientMockSScan.Unlock()
	return mock.SScanFunc(key, cursor, match, count)
}

// SScanCalls gets all the calls that were made to SScan.
// Check the length with:
//     len(mockedUniversalClient.SScanCalls())
func (mock *UniversalClientMock) SScanCalls() []struct {
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	lockUniversalClientMockSScan.RLock()
	calls = mock.calls.SScan
	lockUniversalClientMockSScan.RUnlock()
	return calls
}

// SUnion calls SUnionFunc.
func (mock *UniversalClientMock) SUnion(keys ...string) *redis.StringSliceCmd {
	if mock.SUnionFunc == nil {
		panic("UniversalClientMock.SUnionFunc: method is nil but UniversalClient.SUnion was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockSUnion.Lock()
	mock.calls.SUnion = append(mock.calls.SUnion, callInfo)
	lockUniversalClientMockSUnion.Unlock()
	return mock.SUnionFunc(keys...)
}

// SUnionCalls gets all the calls that were made to SUnion.
// Check the length with:
//     len(mockedUniversalClient.SUnionCalls())
func (mock *UniversalClientMock) SUnionCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockSUnion.RLock()
	calls = mock.calls.SUnion
	lockUniversalClientMockSUnion.RUnlock()
	return calls
}

// SUnionStore calls SUnionStoreFunc.
func (mock *UniversalClientMock) SUnionStore(destination string, keys ...string) *redis.IntCmd {
	if mock.SUnionStoreFunc == nil {
		panic("UniversalClientMock.SUnionStoreFunc: method is nil but UniversalClient.SUnionStore was just called")
	}
	callInfo := struct {
		Destination string
		Keys        []string
	}{
		Destination: destination,
		Keys:        keys,
	}
	lockUniversalClientMockSUnionStore.Lock()
	mock.calls.SUnionStore = append(mock.calls.SUnionStore, callInfo)
	lockUniversalClientMockSUnionStore.Unlock()
	return mock.SUnionStoreFunc(destination, keys...)
}

// SUnionStoreCalls gets all the calls that were made to SUnionStore.
// Check the length with:
//     len(mockedUniversalClient.SUnionStoreCalls())
func (mock *UniversalClientMock) SUnionStoreCalls() []struct {
	Destination string
	Keys        []string
} {
	var calls []struct {
		Destination string
		Keys        []string
	}
	lockUniversalClientMockSUnionStore.RLock()
	calls = mock.calls.SUnionStore
	lockUniversalClientMockSUnionStore.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *UniversalClientMock) Save() *redis.StatusCmd {
	if mock.SaveFunc == nil {
		panic("UniversalClientMock.SaveFunc: method is nil but UniversalClient.Save was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	lockUniversalClientMockSave.Unlock()
	return mock.SaveFunc()
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//     len(mockedUniversalClient.SaveCalls())
func (mock *UniversalClientMock) SaveCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockSave.RLock()
	calls = mock.calls.Save
	lockUniversalClientMockSave.RUnlock()
	return calls
}

// Scan calls ScanFunc.
func (mock *UniversalClientMock) Scan(cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.ScanFunc == nil {
		panic("UniversalClientMock.ScanFunc: method is nil but UniversalClient.Scan was just called")
	}
	callInfo := struct {
		Cursor uint64
		Match  string
		Count  int64
	}{
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	lockUniversalClientMockScan.Lock()
	mock.calls.Scan = append(mock.calls.Scan, callInfo)
	lockUniversalClientMockScan.Unlock()
	return mock.ScanFunc(cursor, match, count)
}

// ScanCalls gets all the calls that were made to Scan.
// Check the length with:
//     len(mockedUniversalClient.ScanCalls())
func (mock *UniversalClientMock) ScanCalls() []struct {
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Cursor uint64
		Match  string
		Count  int64
	}
	lockUniversalClientMockScan.RLock()
	calls = mock.calls.Scan
	lockUniversalClientMockScan.RUnlock()
	return calls
}

// ScriptExists calls ScriptExistsFunc.
func (mock *UniversalClientMock) ScriptExists(hashes ...string) *redis.BoolSliceCmd {
	if mock.ScriptExistsFunc == nil {
		panic("UniversalClientMock.ScriptExistsFunc: method is nil but UniversalClient.ScriptExists was just called")
	}
	callInfo := struct {
		Hashes []string
	}{
		Hashes: hashes,
	}
	lockUniversalClientMockScriptExists.Lock()
	mock.calls.ScriptExists = append(mock.calls.ScriptExists, callInfo)
	lockUniversalClientMockScriptExists.Unlock()
	return mock.ScriptExistsFunc(hashes...)
}

// ScriptExistsCalls gets all the calls that were made to ScriptExists.
// Check the length with:
//     len(mockedUniversalClient.ScriptExistsCalls())
func (mock *UniversalClientMock) ScriptExistsCalls() []struct {
	Hashes []string
} {
	var calls []struct {
		Hashes []string
	}
	lockUniversalClientMockScriptExists.RLock()
	calls = mock.calls.ScriptExists
	lockUniversalClientMockScriptExists.RUnlock()
	return calls
}

// ScriptFlush calls ScriptFlushFunc.
func (mock *UniversalClientMock) ScriptFlush() *redis.StatusCmd {
	if mock.ScriptFlushFunc == nil {
		panic("UniversalClientMock.ScriptFlushFunc: method is nil but UniversalClient.ScriptFlush was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockScriptFlush.Lock()
	mock.calls.ScriptFlush = append(mock.calls.ScriptFlush, callInfo)
	lockUniversalClientMockScriptFlush.Unlock()
	return mock.ScriptFlushFunc()
}

// ScriptFlushCalls gets all the calls that were made to ScriptFlush.
// Check the length with:
//     len(mockedUniversalClient.ScriptFlushCalls())
func (mock *UniversalClientMock) ScriptFlushCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockScriptFlush.RLock()
	calls = mock.calls.ScriptFlush
	lockUniversalClientMockScriptFlush.RUnlock()
	return calls
}

// ScriptKill calls ScriptKillFunc.
func (mock *UniversalClientMock) ScriptKill() *redis.StatusCmd {
	if mock.ScriptKillFunc == nil {
		panic("UniversalClientMock.ScriptKillFunc: method is nil but UniversalClient.ScriptKill was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockScriptKill.Lock()
	mock.calls.ScriptKill = append(mock.calls.ScriptKill, callInfo)
	lockUniversalClientMockScriptKill.Unlock()
	return mock.ScriptKillFunc()
}

// ScriptKillCalls gets all the calls that were made to ScriptKill.
// Check the length with:
//     len(mockedUniversalClient.ScriptKillCalls())
func (mock *UniversalClientMock) ScriptKillCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockScriptKill.RLock()
	calls = mock.calls.ScriptKill
	lockUniversalClientMockScriptKill.RUnlock()
	return calls
}

// ScriptLoad calls ScriptLoadFunc.
func (mock *UniversalClientMock) ScriptLoad(script string) *redis.StringCmd {
	if mock.ScriptLoadFunc == nil {
		panic("UniversalClientMock.ScriptLoadFunc: method is nil but UniversalClient.ScriptLoad was just called")
	}
	callInfo := struct {
		Script string
	}{
		Script: script,
	}
	lockUniversalClientMockScriptLoad.Lock()
	mock.calls.ScriptLoad = append(mock.calls.ScriptLoad, callInfo)
	lockUniversalClientMockScriptLoad.Unlock()
	return mock.ScriptLoadFunc(script)
}

// ScriptLoadCalls gets all the calls that were made to ScriptLoad.
// Check the length with:
//     len(mockedUniversalClient.ScriptLoadCalls())
func (mock *UniversalClientMock) ScriptLoadCalls() []struct {
	Script string
} {
	var calls []struct {
		Script string
	}
	lockUniversalClientMockScriptLoad.RLock()
	calls = mock.calls.ScriptLoad
	lockUniversalClientMockScriptLoad.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *UniversalClientMock) Set(key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	if mock.SetFunc == nil {
		panic("UniversalClientMock.SetFunc: method is nil but UniversalClient.Set was just called")
	}
	callInfo := struct {
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	lockUniversalClientMockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	lockUniversalClientMockSet.Unlock()
	return mock.SetFunc(key, value, expiration)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//     len(mockedUniversalClient.SetCalls())
func (mock *UniversalClientMock) SetCalls() []struct {
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	lockUniversalClientMockSet.RLock()
	calls = mock.calls.Set
	lockUniversalClientMockSet.RUnlock()
	return calls
}

// SetBit calls SetBitFunc.
func (mock *UniversalClientMock) SetBit(key string, offset int64, value int) *redis.IntCmd {
	if mock.SetBitFunc == nil {
		panic("UniversalClientMock.SetBitFunc: method is nil but UniversalClient.SetBit was just called")
	}
	callInfo := struct {
		Key    string
		Offset int64
		Value  int
	}{
		Key:    key,
		Offset: offset,
		Value:  value,
	}
	lockUniversalClientMockSetBit.Lock()
	mock.calls.SetBit = append(mock.calls.SetBit, callInfo)
	lockUniversalClientMockSetBit.Unlock()
	return mock.SetBitFunc(key, offset, value)
}

// SetBitCalls gets all the calls that were made to SetBit.
// Check the length with:
//     len(mockedUniversalClient.SetBitCalls())
func (mock *UniversalClientMock) SetBitCalls() []struct {
	Key    string
	Offset int64
	Value  int
} {
	var calls []struct {
		Key    string
		Offset int64
		Value  int
	}
	lockUniversalClientMockSetBit.RLock()
	calls = mock.calls.SetBit
	lockUniversalClientMockSetBit.RUnlock()
	return calls
}

// SetNX calls SetNXFunc.
func (mock *UniversalClientMock) SetNX(key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	if mock.SetNXFunc == nil {
		panic("UniversalClientMock.SetNXFunc: method is nil but UniversalClient.SetNX was just called")
	}
	callInfo := struct {
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	lockUniversalClientMockSetNX.Lock()
	mock.calls.SetNX = append(mock.calls.SetNX, callInfo)
	lockUniversalClientMockSetNX.Unlock()
	return mock.SetNXFunc(key, value, expiration)
}

// SetNXCalls gets all the calls that were made to SetNX.
// Check the length with:
//     len(mockedUniversalClient.SetNXCalls())
func (mock *UniversalClientMock) SetNXCalls() []struct {
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	lockUniversalClientMockSetNX.RLock()
	calls = mock.calls.SetNX
	lockUniversalClientMockSetNX.RUnlock()
	return calls
}

// SetRange calls SetRangeFunc.
func (mock *UniversalClientMock) SetRange(key string, offset int64, value string) *redis.IntCmd {
	if mock.SetRangeFunc == nil {
		panic("UniversalClientMock.SetRangeFunc: method is nil but UniversalClient.SetRange was just called")
	}
	callInfo := struct {
		Key    string
		Offset int64
		Value  string
	}{
		Key:    key,
		Offset: offset,
		Value:  value,
	}
	lockUniversalClientMockSetRange.Lock()
	mock.calls.SetRange = append(mock.calls.SetRange, callInfo)
	lockUniversalClientMockSetRange.Unlock()
	return mock.SetRangeFunc(key, offset, value)
}

// SetRangeCalls gets all the calls that were made to SetRange.
// Check the length with:
//     len(mockedUniversalClient.SetRangeCalls())
func (mock *UniversalClientMock) SetRangeCalls() []struct {
	Key    string
	Offset int64
	Value  string
} {
	var calls []struct {
		Key    string
		Offset int64
		Value  string
	}
	lockUniversalClientMockSetRange.RLock()
	calls = mock.calls.SetRange
	lockUniversalClientMockSetRange.RUnlock()
	return calls
}

// SetXX calls SetXXFunc.
func (mock *UniversalClientMock) SetXX(key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	if mock.SetXXFunc == nil {
		panic("UniversalClientMock.SetXXFunc: method is nil but UniversalClient.SetXX was just called")
	}
	callInfo := struct {
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	lockUniversalClientMockSetXX.Lock()
	mock.calls.SetXX = append(mock.calls.SetXX, callInfo)
	lockUniversalClientMockSetXX.Unlock()
	return mock.SetXXFunc(key, value, expiration)
}

// SetXXCalls gets all the calls that were made to SetXX.
// Check the length with:
//     len(mockedUniversalClient.SetXXCalls())
func (mock *UniversalClientMock) SetXXCalls() []struct {
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	lockUniversalClientMockSetXX.RLock()
	calls = mock.calls.SetXX
	lockUniversalClientMockSetXX.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *UniversalClientMock) Shutdown() *redis.StatusCmd {
	if mock.ShutdownFunc == nil {
		panic("UniversalClientMock.ShutdownFunc: method is nil but UniversalClient.Shutdown was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	lockUniversalClientMockShutdown.Unlock()
	return mock.ShutdownFunc()
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//     len(mockedUniversalClient.ShutdownCalls())
func (mock *UniversalClientMock) ShutdownCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockShutdown.RLock()
	calls = mock.calls.Shutdown
	lockUniversalClientMockShutdown.RUnlock()
	return calls
}

// ShutdownNoSave calls ShutdownNoSaveFunc.
func (mock *UniversalClientMock) ShutdownNoSave() *redis.StatusCmd {
	if mock.ShutdownNoSaveFunc == nil {
		panic("UniversalClientMock.ShutdownNoSaveFunc: method is nil but UniversalClient.ShutdownNoSave was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockShutdownNoSave.Lock()
	mock.calls.ShutdownNoSave = append(mock.calls.ShutdownNoSave, callInfo)
	lockUniversalClientMockShutdownNoSave.Unlock()
	return mock.ShutdownNoSaveFunc()
}

// ShutdownNoSaveCalls gets all the calls that were made to ShutdownNoSave.
// Check the length with:
//     len(mockedUniversalClient.ShutdownNoSaveCalls())
func (mock *UniversalClientMock) ShutdownNoSaveCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockShutdownNoSave.RLock()
	calls = mock.calls.ShutdownNoSave
	lockUniversalClientMockShutdownNoSave.RUnlock()
	return calls
}

// ShutdownSave calls ShutdownSaveFunc.
func (mock *UniversalClientMock) ShutdownSave() *redis.StatusCmd {
	if mock.ShutdownSaveFunc == nil {
		panic("UniversalClientMock.ShutdownSaveFunc: method is nil but UniversalClient.ShutdownSave was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockShutdownSave.Lock()
	mock.calls.ShutdownSave = append(mock.calls.ShutdownSave, callInfo)
	lockUniversalClientMockShutdownSave.Unlock()
	return mock.ShutdownSaveFunc()
}

// ShutdownSaveCalls gets all the calls that were made to ShutdownSave.
// Check the length with:
//     len(mockedUniversalClient.ShutdownSaveCalls())
func (mock *UniversalClientMock) ShutdownSaveCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockShutdownSave.RLock()
	calls = mock.calls.ShutdownSave
	lockUniversalClientMockShutdownSave.RUnlock()
	return calls
}

// SlaveOf calls SlaveOfFunc.
func (mock *UniversalClientMock) SlaveOf(host string, port string) *redis.StatusCmd {
	if mock.SlaveOfFunc == nil {
		panic("UniversalClientMock.SlaveOfFunc: method is nil but UniversalClient.SlaveOf was just called")
	}
	callInfo := struct {
		Host string
		Port string
	}{
		Host: host,
		Port: port,
	}
	lockUniversalClientMockSlaveOf.Lock()
	mock.calls.SlaveOf = append(mock.calls.SlaveOf, callInfo)
	lockUniversalClientMockSlaveOf.Unlock()
	return mock.SlaveOfFunc(host, port)
}

// SlaveOfCalls gets all the calls that were made to SlaveOf.
// Check the length with:
//     len(mockedUniversalClient.SlaveOfCalls())
func (mock *UniversalClientMock) SlaveOfCalls() []struct {
	Host string
	Port string
} {
	var calls []struct {
		Host string
		Port string
	}
	lockUniversalClientMockSlaveOf.RLock()
	calls = mock.calls.SlaveOf
	lockUniversalClientMockSlaveOf.RUnlock()
	return calls
}

// Sort calls SortFunc.
func (mock *UniversalClientMock) Sort(key string, sort *redis.Sort) *redis.StringSliceCmd {
	if mock.SortFunc == nil {
		panic("UniversalClientMock.SortFunc: method is nil but UniversalClient.Sort was just called")
	}
	callInfo := struct {
		Key  string
		Sort *redis.Sort
	}{
		Key:  key,
		Sort: sort,
	}
	lockUniversalClientMockSort.Lock()
	mock.calls.Sort = append(mock.calls.Sort, callInfo)
	lockUniversalClientMockSort.Unlock()
	return mock.SortFunc(key, sort)
}

// SortCalls gets all the calls that were made to Sort.
// Check the length with:
//     len(mockedUniversalClient.SortCalls())
func (mock *UniversalClientMock) SortCalls() []struct {
	Key  string
	Sort *redis.Sort
} {
	var calls []struct {
		Key  string
		Sort *redis.Sort
	}
	lockUniversalClientMockSort.RLock()
	calls = mock.calls.Sort
	lockUniversalClientMockSort.RUnlock()
	return calls
}

// SortInterfaces calls SortInterfacesFunc.
func (mock *UniversalClientMock) SortInterfaces(key string, sort *redis.Sort) *redis.SliceCmd {
	if mock.SortInterfacesFunc == nil {
		panic("UniversalClientMock.SortInterfacesFunc: method is nil but UniversalClient.SortInterfaces was just called")
	}
	callInfo := struct {
		Key  string
		Sort *redis.Sort
	}{
		Key:  key,
		Sort: sort,
	}
	lockUniversalClientMockSortInterfaces.Lock()
	mock.calls.SortInterfaces = append(mock.calls.SortInterfaces, callInfo)
	lockUniversalClientMockSortInterfaces.Unlock()
	return mock.SortInterfacesFunc(key, sort)
}

// SortInterfacesCalls gets all the calls that were made to SortInterfaces.
// Check the length with:
//     len(mockedUniversalClient.SortInterfacesCalls())
func (mock *UniversalClientMock) SortInterfacesCalls() []struct {
	Key  string
	Sort *redis.Sort
} {
	var calls []struct {
		Key  string
		Sort *redis.Sort
	}
	lockUniversalClientMockSortInterfaces.RLock()
	calls = mock.calls.SortInterfaces
	lockUniversalClientMockSortInterfaces.RUnlock()
	return calls
}

// SortStore calls SortStoreFunc.
func (mock *UniversalClientMock) SortStore(key string, store string, sort *redis.Sort) *redis.IntCmd {
	if mock.SortStoreFunc == nil {
		panic("UniversalClientMock.SortStoreFunc: method is nil but UniversalClient.SortStore was just called")
	}
	callInfo := struct {
		Key   string
		Store string
		Sort  *redis.Sort
	}{
		Key:   key,
		Store: store,
		Sort:  sort,
	}
	lockUniversalClientMockSortStore.Lock()
	mock.calls.SortStore = append(mock.calls.SortStore, callInfo)
	lockUniversalClientMockSortStore.Unlock()
	return mock.SortStoreFunc(key, store, sort)
}

// SortStoreCalls gets all the calls that were made to SortStore.
// Check the length with:
//     len(mockedUniversalClient.SortStoreCalls())
func (mock *UniversalClientMock) SortStoreCalls() []struct {
	Key   string
	Store string
	Sort  *redis.Sort
} {
	var calls []struct {
		Key   string
		Store string
		Sort  *redis.Sort
	}
	lockUniversalClientMockSortStore.RLock()
	calls = mock.calls.SortStore
	lockUniversalClientMockSortStore.RUnlock()
	return calls
}

// StrLen calls StrLenFunc.
func (mock *UniversalClientMock) StrLen(key string) *redis.IntCmd {
	if mock.StrLenFunc == nil {
		panic("UniversalClientMock.StrLenFunc: method is nil but UniversalClient.StrLen was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockStrLen.Lock()
	mock.calls.StrLen = append(mock.calls.StrLen, callInfo)
	lockUniversalClientMockStrLen.Unlock()
	return mock.StrLenFunc(key)
}

// StrLenCalls gets all the calls that were made to StrLen.
// Check the length with:
//     len(mockedUniversalClient.StrLenCalls())
func (mock *UniversalClientMock) StrLenCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockStrLen.RLock()
	calls = mock.calls.StrLen
	lockUniversalClientMockStrLen.RUnlock()
	return calls
}

// Subscribe calls SubscribeFunc.
func (mock *UniversalClientMock) Subscribe(channels ...string) *redis.PubSub {
	if mock.SubscribeFunc == nil {
		panic("UniversalClientMock.SubscribeFunc: method is nil but UniversalClient.Subscribe was just called")
	}
	callInfo := struct {
		Channels []string
	}{
		Channels: channels,
	}
	lockUniversalClientMockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	lockUniversalClientMockSubscribe.Unlock()
	return mock.SubscribeFunc(channels...)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//     len(mockedUniversalClient.SubscribeCalls())
func (mock *UniversalClientMock) SubscribeCalls() []struct {
	Channels []string
} {
	var calls []struct {
		Channels []string
	}
	lockUniversalClientMockSubscribe.RLock()
	calls = mock.calls.Subscribe
	lockUniversalClientMockSubscribe.RUnlock()
	return calls
}

// TTL calls TTLFunc.
func (mock *UniversalClientMock) TTL(key string) *redis.DurationCmd {
	if mock.TTLFunc == nil {
		panic("UniversalClientMock.TTLFunc: method is nil but UniversalClient.TTL was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockTTL.Lock()
	mock.calls.TTL = append(mock.calls.TTL, callInfo)
	lockUniversalClientMockTTL.Unlock()
	return mock.TTLFunc(key)
}

// TTLCalls gets all the calls that were made to TTL.
// Check the length with:
//     len(mockedUniversalClient.TTLCalls())
func (mock *UniversalClientMock) TTLCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockTTL.RLock()
	calls = mock.calls.TTL
	lockUniversalClientMockTTL.RUnlock()
	return calls
}

// Time calls TimeFunc.
func (mock *UniversalClientMock) Time() *redis.TimeCmd {
	if mock.TimeFunc == nil {
		panic("UniversalClientMock.TimeFunc: method is nil but UniversalClient.Time was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockTime.Lock()
	mock.calls.Time = append(mock.calls.Time, callInfo)
	lockUniversalClientMockTime.Unlock()
	return mock.TimeFunc()
}

// TimeCalls gets all the calls that were made to Time.
// Check the length with:
//     len(mockedUniversalClient.TimeCalls())
func (mock *UniversalClientMock) TimeCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockTime.RLock()
	calls = mock.calls.Time
	lockUniversalClientMockTime.RUnlock()
	return calls
}

// Touch calls TouchFunc.
func (mock *UniversalClientMock) Touch(keys ...string) *redis.IntCmd {
	if mock.TouchFunc == nil {
		panic("UniversalClientMock.TouchFunc: method is nil but UniversalClient.Touch was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockTouch.Lock()
	mock.calls.Touch = append(mock.calls.Touch, callInfo)
	lockUniversalClientMockTouch.Unlock()
	return mock.TouchFunc(keys...)
}

// TouchCalls gets all the calls that were made to Touch.
// Check the length with:
//     len(mockedUniversalClient.TouchCalls())
func (mock *UniversalClientMock) TouchCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockTouch.RLock()
	calls = mock.calls.Touch
	lockUniversalClientMockTouch.RUnlock()
	return calls
}

// TxPipeline calls TxPipelineFunc.
func (mock *UniversalClientMock) TxPipeline() redis.Pipeliner {
	if mock.TxPipelineFunc == nil {
		panic("UniversalClientMock.TxPipelineFunc: method is nil but UniversalClient.TxPipeline was just called")
	}
	callInfo := struct {
	}{}
	lockUniversalClientMockTxPipeline.Lock()
	mock.calls.TxPipeline = append(mock.calls.TxPipeline, callInfo)
	lockUniversalClientMockTxPipeline.Unlock()
	return mock.TxPipelineFunc()
}

// TxPipelineCalls gets all the calls that were made to TxPipeline.
// Check the length with:
//     len(mockedUniversalClient.TxPipelineCalls())
func (mock *UniversalClientMock) TxPipelineCalls() []struct {
} {
	var calls []struct {
	}
	lockUniversalClientMockTxPipeline.RLock()
	calls = mock.calls.TxPipeline
	lockUniversalClientMockTxPipeline.RUnlock()
	return calls
}

// TxPipelined calls TxPipelinedFunc.
func (mock *UniversalClientMock) TxPipelined(fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	if mock.TxPipelinedFunc == nil {
		panic("UniversalClientMock.TxPipelinedFunc: method is nil but UniversalClient.TxPipelined was just called")
	}
	callInfo := struct {
		Fn func(redis.Pipeliner) error
	}{
		Fn: fn,
	}
	lockUniversalClientMockTxPipelined.Lock()
	mock.calls.TxPipelined = append(mock.calls.TxPipelined, callInfo)
	lockUniversalClientMockTxPipelined.Unlock()
	return mock.TxPipelinedFunc(fn)
}

// TxPipelinedCalls gets all the calls that were made to TxPipelined.
// Check the length with:
//     len(mockedUniversalClient.TxPipelinedCalls())
func (mock *UniversalClientMock) TxPipelinedCalls() []struct {
	Fn func(redis.Pipeliner) error
} {
	var calls []struct {
		Fn func(redis.Pipeliner) error
	}
	lockUniversalClientMockTxPipelined.RLock()
	calls = mock.calls.TxPipelined
	lockUniversalClientMockTxPipelined.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *UniversalClientMock) Type(key string) *redis.StatusCmd {
	if mock.TypeFunc == nil {
		panic("UniversalClientMock.TypeFunc: method is nil but UniversalClient.Type was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	lockUniversalClientMockType.Unlock()
	return mock.TypeFunc(key)
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//     len(mockedUniversalClient.TypeCalls())
func (mock *UniversalClientMock) TypeCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockType.RLock()
	calls = mock.calls.Type
	lockUniversalClientMockType.RUnlock()
	return calls
}

// Unlink calls UnlinkFunc.
func (mock *UniversalClientMock) Unlink(keys ...string) *redis.IntCmd {
	if mock.UnlinkFunc == nil {
		panic("UniversalClientMock.UnlinkFunc: method is nil but UniversalClient.Unlink was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	lockUniversalClientMockUnlink.Lock()
	mock.calls.Unlink = append(mock.calls.Unlink, callInfo)
	lockUniversalClientMockUnlink.Unlock()
	return mock.UnlinkFunc(keys...)
}

// UnlinkCalls gets all the calls that were made to Unlink.
// Check the length with:
//     len(mockedUniversalClient.UnlinkCalls())
func (mock *UniversalClientMock) UnlinkCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	lockUniversalClientMockUnlink.RLock()
	calls = mock.calls.Unlink
	lockUniversalClientMockUnlink.RUnlock()
	return calls
}

// Watch calls WatchFunc.
func (mock *UniversalClientMock) Watch(fn func(*redis.Tx) error, keys ...string) error {
	if mock.WatchFunc == nil {
		panic("UniversalClientMock.WatchFunc: method is nil but UniversalClient.Watch was just called")
	}
	callInfo := struct {
		Fn   func(*redis.Tx) error
		Keys []string
	}{
		Fn:   fn,
		Keys: keys,
	}
	lockUniversalClientMockWatch.Lock()
	mock.calls.Watch = append(mock.calls.Watch, callInfo)
	lockUniversalClientMockWatch.Unlock()
	return mock.WatchFunc(fn, keys...)
}

// WatchCalls gets all the calls that were made to Watch.
// Check the length with:
//     len(mockedUniversalClient.WatchCalls())
func (mock *UniversalClientMock) WatchCalls() []struct {
	Fn   func(*redis.Tx) error
	Keys []string
} {
	var calls []struct {
		Fn   func(*redis.Tx) error
		Keys []string
	}
	lockUniversalClientMockWatch.RLock()
	calls = mock.calls.Watch
	lockUniversalClientMockWatch.RUnlock()
	return calls
}

// WrapProcess calls WrapProcessFunc.
func (mock *UniversalClientMock) WrapProcess(fn func(oldProcess func(cmd redis.Cmder) error) func(cmd redis.Cmder) error) {
	if mock.WrapProcessFunc == nil {
		panic("UniversalClientMock.WrapProcessFunc: method is nil but UniversalClient.WrapProcess was just called")
	}
	callInfo := struct {
		Fn func(oldProcess func(cmd redis.Cmder) error) func(cmd redis.Cmder) error
	}{
		Fn: fn,
	}
	lockUniversalClientMockWrapProcess.Lock()
	mock.calls.WrapProcess = append(mock.calls.WrapProcess, callInfo)
	lockUniversalClientMockWrapProcess.Unlock()
	mock.WrapProcessFunc(fn)
}

// WrapProcessCalls gets all the calls that were made to WrapProcess.
// Check the length with:
//     len(mockedUniversalClient.WrapProcessCalls())
func (mock *UniversalClientMock) WrapProcessCalls() []struct {
	Fn func(oldProcess func(cmd redis.Cmder) error) func(cmd redis.Cmder) error
} {
	var calls []struct {
		Fn func(oldProcess func(cmd redis.Cmder) error) func(cmd redis.Cmder) error
	}
	lockUniversalClientMockWrapProcess.RLock()
	calls = mock.calls.WrapProcess
	lockUniversalClientMockWrapProcess.RUnlock()
	return calls
}

// XAck calls XAckFunc.
func (mock *UniversalClientMock) XAck(stream string, group string, ids ...string) *redis.IntCmd {
	if mock.XAckFunc == nil {
		panic("UniversalClientMock.XAckFunc: method is nil but UniversalClient.XAck was just called")
	}
	callInfo := struct {
		Stream string
		Group  string
		Ids    []string
	}{
		Stream: stream,
		Group:  group,
		Ids:    ids,
	}
	lockUniversalClientMockXAck.Lock()
	mock.calls.XAck = append(mock.calls.XAck, callInfo)
	lockUniversalClientMockXAck.Unlock()
	return mock.XAckFunc(stream, group, ids...)
}

// XAckCalls gets all the calls that were made to XAck.
// Check the length with:
//     len(mockedUniversalClient.XAckCalls())
func (mock *UniversalClientMock) XAckCalls() []struct {
	Stream string
	Group  string
	Ids    []string
} {
	var calls []struct {
		Stream string
		Group  string
		Ids    []string
	}
	lockUniversalClientMockXAck.RLock()
	calls = mock.calls.XAck
	lockUniversalClientMockXAck.RUnlock()
	return calls
}

// XAdd calls XAddFunc.
func (mock *UniversalClientMock) XAdd(a *redis.XAddArgs) *redis.StringCmd {
	if mock.XAddFunc == nil {
		panic("UniversalClientMock.XAddFunc: method is nil but UniversalClient.XAdd was just called")
	}
	callInfo := struct {
		A *redis.XAddArgs
	}{
		A: a,
	}
	lockUniversalClientMockXAdd.Lock()
	mock.calls.XAdd = append(mock.calls.XAdd, callInfo)
	lockUniversalClientMockXAdd.Unlock()
	return mock.XAddFunc(a)
}

// XAddCalls gets all the calls that were made to XAdd.
// Check the length with:
//     len(mockedUniversalClient.XAddCalls())
func (mock *UniversalClientMock) XAddCalls() []struct {
	A *redis.XAddArgs
} {
	var calls []struct {
		A *redis.XAddArgs
	}
	lockUniversalClientMockXAdd.RLock()
	calls = mock.calls.XAdd
	lockUniversalClientMockXAdd.RUnlock()
	return calls
}

// XClaim calls XClaimFunc.
func (mock *UniversalClientMock) XClaim(a *redis.XClaimArgs) *redis.XMessageSliceCmd {
	if mock.XClaimFunc == nil {
		panic("UniversalClientMock.XClaimFunc: method is nil but UniversalClient.XClaim was just called")
	}
	callInfo := struct {
		A *redis.XClaimArgs
	}{
		A: a,
	}
	lockUniversalClientMockXClaim.Lock()
	mock.calls.XClaim = append(mock.calls.XClaim, callInfo)
	lockUniversalClientMockXClaim.Unlock()
	return mock.XClaimFunc(a)
}

// XClaimCalls gets all the calls that were made to XClaim.
// Check the length with:
//     len(mockedUniversalClient.XClaimCalls())
func (mock *UniversalClientMock) XClaimCalls() []struct {
	A *redis.XClaimArgs
} {
	var calls []struct {
		A *redis.XClaimArgs
	}
	lockUniversalClientMockXClaim.RLock()
	calls = mock.calls.XClaim
	lockUniversalClientMockXClaim.RUnlock()
	return calls
}

// XClaimJustID calls XClaimJustIDFunc.
func (mock *UniversalClientMock) XClaimJustID(a *redis.XClaimArgs) *redis.StringSliceCmd {
	if mock.XClaimJustIDFunc == nil {
		panic("UniversalClientMock.XClaimJustIDFunc: method is nil but UniversalClient.XClaimJustID was just called")
	}
	callInfo := struct {
		A *redis.XClaimArgs
	}{
		A: a,
	}
	lockUniversalClientMockXClaimJustID.Lock()
	mock.calls.XClaimJustID = append(mock.calls.XClaimJustID, callInfo)
	lockUniversalClientMockXClaimJustID.Unlock()
	return mock.XClaimJustIDFunc(a)
}

// XClaimJustIDCalls gets all the calls that were made to XClaimJustID.
// Check the length with:
//     len(mockedUniversalClient.XClaimJustIDCalls())
func (mock *UniversalClientMock) XClaimJustIDCalls() []struct {
	A *redis.XClaimArgs
} {
	var calls []struct {
		A *redis.XClaimArgs
	}
	lockUniversalClientMockXClaimJustID.RLock()
	calls = mock.calls.XClaimJustID
	lockUniversalClientMockXClaimJustID.RUnlock()
	return calls
}

// XDel calls XDelFunc.
func (mock *UniversalClientMock) XDel(stream string, ids ...string) *redis.IntCmd {
	if mock.XDelFunc == nil {
		panic("UniversalClientMock.XDelFunc: method is nil but UniversalClient.XDel was just called")
	}
	callInfo := struct {
		Stream string
		Ids    []string
	}{
		Stream: stream,
		Ids:    ids,
	}
	lockUniversalClientMockXDel.Lock()
	mock.calls.XDel = append(mock.calls.XDel, callInfo)
	lockUniversalClientMockXDel.Unlock()
	return mock.XDelFunc(stream, ids...)
}

// XDelCalls gets all the calls that were made to XDel.
// Check the length with:
//     len(mockedUniversalClient.XDelCalls())
func (mock *UniversalClientMock) XDelCalls() []struct {
	Stream string
	Ids    []string
} {
	var calls []struct {
		Stream string
		Ids    []string
	}
	lockUniversalClientMockXDel.RLock()
	calls = mock.calls.XDel
	lockUniversalClientMockXDel.RUnlock()
	return calls
}

// XGroupCreate calls XGroupCreateFunc.
func (mock *UniversalClientMock) XGroupCreate(stream string, group string, start string) *redis.StatusCmd {
	if mock.XGroupCreateFunc == nil {
		panic("UniversalClientMock.XGroupCreateFunc: method is nil but UniversalClient.XGroupCreate was just called")
	}
	callInfo := struct {
		Stream string
		Group  string
		Start  string
	}{
		Stream: stream,
		Group:  group,
		Start:  start,
	}
	lockUniversalClientMockXGroupCreate.Lock()
	mock.calls.XGroupCreate = append(mock.calls.XGroupCreate, callInfo)
	lockUniversalClientMockXGroupCreate.Unlock()
	return mock.XGroupCreateFunc(stream, group, start)
}

// XGroupCreateCalls gets all the calls that were made to XGroupCreate.
// Check the length with:
//     len(mockedUniversalClient.XGroupCreateCalls())
func (mock *UniversalClientMock) XGroupCreateCalls() []struct {
	Stream string
	Group  string
	Start  string
} {
	var calls []struct {
		Stream string
		Group  string
		Start  string
	}
	lockUniversalClientMockXGroupCreate.RLock()
	calls = mock.calls.XGroupCreate
	lockUniversalClientMockXGroupCreate.RUnlock()
	return calls
}

// XGroupCreateMkStream calls XGroupCreateMkStreamFunc.
func (mock *UniversalClientMock) XGroupCreateMkStream(stream string, group string, start string) *redis.StatusCmd {
	if mock.XGroupCreateMkStreamFunc == nil {
		panic("UniversalClientMock.XGroupCreateMkStreamFunc: method is nil but UniversalClient.XGroupCreateMkStream was just called")
	}
	callInfo := struct {
		Stream string
		Group  string
		Start  string
	}{
		Stream: stream,
		Group:  group,
		Start:  start,
	}
	lockUniversalClientMockXGroupCreateMkStream.Lock()
	mock.calls.XGroupCreateMkStream = append(mock.calls.XGroupCreateMkStream, callInfo)
	lockUniversalClientMockXGroupCreateMkStream.Unlock()
	return mock.XGroupCreateMkStreamFunc(stream, group, start)
}

// XGroupCreateMkStreamCalls gets all the calls that were made to XGroupCreateMkStream.
// Check the length with:
//     len(mockedUniversalClient.XGroupCreateMkStreamCalls())
func (mock *UniversalClientMock) XGroupCreateMkStreamCalls() []struct {
	Stream string
	Group  string
	Start  string
} {
	var calls []struct {
		Stream string
		Group  string
		Start  string
	}
	lockUniversalClientMockXGroupCreateMkStream.RLock()
	calls = mock.calls.XGroupCreateMkStream
	lockUniversalClientMockXGroupCreateMkStream.RUnlock()
	return calls
}

// XGroupDelConsumer calls XGroupDelConsumerFunc.
func (mock *UniversalClientMock) XGroupDelConsumer(stream string, group string, consumer string) *redis.IntCmd {
	if mock.XGroupDelConsumerFunc == nil {
		panic("UniversalClientMock.XGroupDelConsumerFunc: method is nil but UniversalClient.XGroupDelConsumer was just called")
	}
	callInfo := struct {
		Stream   string
		Group    string
		Consumer string
	}{
		Stream:   stream,
		Group:    group,
		Consumer: consumer,
	}
	lockUniversalClientMockXGroupDelConsumer.Lock()
	mock.calls.XGroupDelConsumer = append(mock.calls.XGroupDelConsumer, callInfo)
	lockUniversalClientMockXGroupDelConsumer.Unlock()
	return mock.XGroupDelConsumerFunc(stream, group, consumer)
}

// XGroupDelConsumerCalls gets all the calls that were made to XGroupDelConsumer.
// Check the length with:
//     len(mockedUniversalClient.XGroupDelConsumerCalls())
func (mock *UniversalClientMock) XGroupDelConsumerCalls() []struct {
	Stream   string
	Group    string
	Consumer string
} {
	var calls []struct {
		Stream   string
		Group    string
		Consumer string
	}
	lockUniversalClientMockXGroupDelConsumer.RLock()
	calls = mock.calls.XGroupDelConsumer
	lockUniversalClientMockXGroupDelConsumer.RUnlock()
	return calls
}

// XGroupDestroy calls XGroupDestroyFunc.
func (mock *UniversalClientMock) XGroupDestroy(stream string, group string) *redis.IntCmd {
	if mock.XGroupDestroyFunc == nil {
		panic("UniversalClientMock.XGroupDestroyFunc: method is nil but UniversalClient.XGroupDestroy was just called")
	}
	callInfo := struct {
		Stream string
		Group  string
	}{
		Stream: stream,
		Group:  group,
	}
	lockUniversalClientMockXGroupDestroy.Lock()
	mock.calls.XGroupDestroy = append(mock.calls.XGroupDestroy, callInfo)
	lockUniversalClientMockXGroupDestroy.Unlock()
	return mock.XGroupDestroyFunc(stream, group)
}

// XGroupDestroyCalls gets all the calls that were made to XGroupDestroy.
// Check the length with:
//     len(mockedUniversalClient.XGroupDestroyCalls())
func (mock *UniversalClientMock) XGroupDestroyCalls() []struct {
	Stream string
	Group  string
} {
	var calls []struct {
		Stream string
		Group  string
	}
	lockUniversalClientMockXGroupDestroy.RLock()
	calls = mock.calls.XGroupDestroy
	lockUniversalClientMockXGroupDestroy.RUnlock()
	return calls
}

// XGroupSetID calls XGroupSetIDFunc.
func (mock *UniversalClientMock) XGroupSetID(stream string, group string, start string) *redis.StatusCmd {
	if mock.XGroupSetIDFunc == nil {
		panic("UniversalClientMock.XGroupSetIDFunc: method is nil but UniversalClient.XGroupSetID was just called")
	}
	callInfo := struct {
		Stream string
		Group  string
		Start  string
	}{
		Stream: stream,
		Group:  group,
		Start:  start,
	}
	lockUniversalClientMockXGroupSetID.Lock()
	mock.calls.XGroupSetID = append(mock.calls.XGroupSetID, callInfo)
	lockUniversalClientMockXGroupSetID.Unlock()
	return mock.XGroupSetIDFunc(stream, group, start)
}

// XGroupSetIDCalls gets all the calls that were made to XGroupSetID.
// Check the length with:
//     len(mockedUniversalClient.XGroupSetIDCalls())
func (mock *UniversalClientMock) XGroupSetIDCalls() []struct {
	Stream string
	Group  string
	Start  string
} {
	var calls []struct {
		Stream string
		Group  string
		Start  string
	}
	lockUniversalClientMockXGroupSetID.RLock()
	calls = mock.calls.XGroupSetID
	lockUniversalClientMockXGroupSetID.RUnlock()
	return calls
}

// XLen calls XLenFunc.
func (mock *UniversalClientMock) XLen(stream string) *redis.IntCmd {
	if mock.XLenFunc == nil {
		panic("UniversalClientMock.XLenFunc: method is nil but UniversalClient.XLen was just called")
	}
	callInfo := struct {
		Stream string
	}{
		Stream: stream,
	}
	lockUniversalClientMockXLen.Lock()
	mock.calls.XLen = append(mock.calls.XLen, callInfo)
	lockUniversalClientMockXLen.Unlock()
	return mock.XLenFunc(stream)
}

// XLenCalls gets all the calls that were made to XLen.
// Check the length with:
//     len(mockedUniversalClient.XLenCalls())
func (mock *UniversalClientMock) XLenCalls() []struct {
	Stream string
} {
	var calls []struct {
		Stream string
	}
	lockUniversalClientMockXLen.RLock()
	calls = mock.calls.XLen
	lockUniversalClientMockXLen.RUnlock()
	return calls
}

// XPending calls XPendingFunc.
func (mock *UniversalClientMock) XPending(stream string, group string) *redis.XPendingCmd {
	if mock.XPendingFunc == nil {
		panic("UniversalClientMock.XPendingFunc: method is nil but UniversalClient.XPending was just called")
	}
	callInfo := struct {
		Stream string
		Group  string
	}{
		Stream: stream,
		Group:  group,
	}
	lockUniversalClientMockXPending.Lock()
	mock.calls.XPending = append(mock.calls.XPending, callInfo)
	lockUniversalClientMockXPending.Unlock()
	return mock.XPendingFunc(stream, group)
}

// XPendingCalls gets all the calls that were made to XPending.
// Check the length with:
//     len(mockedUniversalClient.XPendingCalls())
func (mock *UniversalClientMock) XPendingCalls() []struct {
	Stream string
	Group  string
} {
	var calls []struct {
		Stream string
		Group  string
	}
	lockUniversalClientMockXPending.RLock()
	calls = mock.calls.XPending
	lockUniversalClientMockXPending.RUnlock()
	return calls
}

// XPendingExt calls XPendingExtFunc.
func (mock *UniversalClientMock) XPendingExt(a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
	if mock.XPendingExtFunc == nil {
		panic("UniversalClientMock.XPendingExtFunc: method is nil but UniversalClient.XPendingExt was just called")
	}
	callInfo := struct {
		A *redis.XPendingExtArgs
	}{
		A: a,
	}
	lockUniversalClientMockXPendingExt.Lock()
	mock.calls.XPendingExt = append(mock.calls.XPendingExt, callInfo)
	lockUniversalClientMockXPendingExt.Unlock()
	return mock.XPendingExtFunc(a)
}

// XPendingExtCalls gets all the calls that were made to XPendingExt.
// Check the length with:
//     len(mockedUniversalClient.XPendingExtCalls())
func (mock *UniversalClientMock) XPendingExtCalls() []struct {
	A *redis.XPendingExtArgs
} {
	var calls []struct {
		A *redis.XPendingExtArgs
	}
	lockUniversalClientMockXPendingExt.RLock()
	calls = mock.calls.XPendingExt
	lockUniversalClientMockXPendingExt.RUnlock()
	return calls
}

// XRange calls XRangeFunc.
func (mock *UniversalClientMock) XRange(stream string, start string, stop string) *redis.XMessageSliceCmd {
	if mock.XRangeFunc == nil {
		panic("UniversalClientMock.XRangeFunc: method is nil but UniversalClient.XRange was just called")
	}
	callInfo := struct {
		Stream string
		Start  string
		Stop   string
	}{
		Stream: stream,
		Start:  start,
		Stop:   stop,
	}
	lockUniversalClientMockXRange.Lock()
	mock.calls.XRange = append(mock.calls.XRange, callInfo)
	lockUniversalClientMockXRange.Unlock()
	return mock.XRangeFunc(stream, start, stop)
}

// XRangeCalls gets all the calls that were made to XRange.
// Check the length with:
//     len(mockedUniversalClient.XRangeCalls())
func (mock *UniversalClientMock) XRangeCalls() []struct {
	Stream string
	Start  string
	Stop   string
} {
	var calls []struct {
		Stream string
		Start  string
		Stop   string
	}
	lockUniversalClientMockXRange.RLock()
	calls = mock.calls.XRange
	lockUniversalClientMockXRange.RUnlock()
	return calls
}

// XRangeN calls XRangeNFunc.
func (mock *UniversalClientMock) XRangeN(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	if mock.XRangeNFunc == nil {
		panic("UniversalClientMock.XRangeNFunc: method is nil but UniversalClient.XRangeN was just called")
	}
	callInfo := struct {
		Stream string
		Start  string
		Stop   string
		Count  int64
	}{
		Stream: stream,
		Start:  start,
		Stop:   stop,
		Count:  count,
	}
	lockUniversalClientMockXRangeN.Lock()
	mock.calls.XRangeN = append(mock.calls.XRangeN, callInfo)
	lockUniversalClientMockXRangeN.Unlock()
	return mock.XRangeNFunc(stream, start, stop, count)
}

// XRangeNCalls gets all the calls that were made to XRangeN.
// Check the length with:
//     len(mockedUniversalClient.XRangeNCalls())
func (mock *UniversalClientMock) XRangeNCalls() []struct {
	Stream string
	Start  string
	Stop   string
	Count  int64
} {
	var calls []struct {
		Stream string
		Start  string
		Stop   string
		Count  int64
	}
	lockUniversalClientMockXRangeN.RLock()
	calls = mock.calls.XRangeN
	lockUniversalClientMockXRangeN.RUnlock()
	return calls
}

// XRead calls XReadFunc.
func (mock *UniversalClientMock) XRead(a *redis.XReadArgs) *redis.XStreamSliceCmd {
	if mock.XReadFunc == nil {
		panic("UniversalClientMock.XReadFunc: method is nil but UniversalClient.XRead was just called")
	}
	callInfo := struct {
		A *redis.XReadArgs
	}{
		A: a,
	}
	lockUniversalClientMockXRead.Lock()
	mock.calls.XRead = append(mock.calls.XRead, callInfo)
	lockUniversalClientMockXRead.Unlock()
	return mock.XReadFunc(a)
}

// XReadCalls gets all the calls that were made to XRead.
// Check the length with:
//     len(mockedUniversalClient.XReadCalls())
func (mock *UniversalClientMock) XReadCalls() []struct {
	A *redis.XReadArgs
} {
	var calls []struct {
		A *redis.XReadArgs
	}
	lockUniversalClientMockXRead.RLock()
	calls = mock.calls.XRead
	lockUniversalClientMockXRead.RUnlock()
	return calls
}

// XReadGroup calls XReadGroupFunc.
func (mock *UniversalClientMock) XReadGroup(a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
	if mock.XReadGroupFunc == nil {
		panic("UniversalClientMock.XReadGroupFunc: method is nil but UniversalClient.XReadGroup was just called")
	}
	callInfo := struct {
		A *redis.XReadGroupArgs
	}{
		A: a,
	}
	lockUniversalClientMockXReadGroup.Lock()
	mock.calls.XReadGroup = append(mock.calls.XReadGroup, callInfo)
	lockUniversalClientMockXReadGroup.Unlock()
	return mock.XReadGroupFunc(a)
}

// XReadGroupCalls gets all the calls that were made to XReadGroup.
// Check the length with:
//     len(mockedUniversalClient.XReadGroupCalls())
func (mock *UniversalClientMock) XReadGroupCalls() []struct {
	A *redis.XReadGroupArgs
} {
	var calls []struct {
		A *redis.XReadGroupArgs
	}
	lockUniversalClientMockXReadGroup.RLock()
	calls = mock.calls.XReadGroup
	lockUniversalClientMockXReadGroup.RUnlock()
	return calls
}

// XReadStreams calls XReadStreamsFunc.
func (mock *UniversalClientMock) XReadStreams(streams ...string) *redis.XStreamSliceCmd {
	if mock.XReadStreamsFunc == nil {
		panic("UniversalClientMock.XReadStreamsFunc: method is nil but UniversalClient.XReadStreams was just called")
	}
	callInfo := struct {
		Streams []string
	}{
		Streams: streams,
	}
	lockUniversalClientMockXReadStreams.Lock()
	mock.calls.XReadStreams = append(mock.calls.XReadStreams, callInfo)
	lockUniversalClientMockXReadStreams.Unlock()
	return mock.XReadStreamsFunc(streams...)
}

// XReadStreamsCalls gets all the calls that were made to XReadStreams.
// Check the length with:
//     len(mockedUniversalClient.XReadStreamsCalls())
func (mock *UniversalClientMock) XReadStreamsCalls() []struct {
	Streams []string
} {
	var calls []struct {
		Streams []string
	}
	lockUniversalClientMockXReadStreams.RLock()
	calls = mock.calls.XReadStreams
	lockUniversalClientMockXReadStreams.RUnlock()
	return calls
}

// XRevRange calls XRevRangeFunc.
func (mock *UniversalClientMock) XRevRange(stream string, start string, stop string) *redis.XMessageSliceCmd {
	if mock.XRevRangeFunc == nil {
		panic("UniversalClientMock.XRevRangeFunc: method is nil but UniversalClient.XRevRange was just called")
	}
	callInfo := struct {
		Stream string
		Start  string
		Stop   string
	}{
		Stream: stream,
		Start:  start,
		Stop:   stop,
	}
	lockUniversalClientMockXRevRange.Lock()
	mock.calls.XRevRange = append(mock.calls.XRevRange, callInfo)
	lockUniversalClientMockXRevRange.Unlock()
	return mock.XRevRangeFunc(stream, start, stop)
}

// XRevRangeCalls gets all the calls that were made to XRevRange.
// Check the length with:
//     len(mockedUniversalClient.XRevRangeCalls())
func (mock *UniversalClientMock) XRevRangeCalls() []struct {
	Stream string
	Start  string
	Stop   string
} {
	var calls []struct {
		Stream string
		Start  string
		Stop   string
	}
	lockUniversalClientMockXRevRange.RLock()
	calls = mock.calls.XRevRange
	lockUniversalClientMockXRevRange.RUnlock()
	return calls
}

// XRevRangeN calls XRevRangeNFunc.
func (mock *UniversalClientMock) XRevRangeN(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	if mock.XRevRangeNFunc == nil {
		panic("UniversalClientMock.XRevRangeNFunc: method is nil but UniversalClient.XRevRangeN was just called")
	}
	callInfo := struct {
		Stream string
		Start  string
		Stop   string
		Count  int64
	}{
		Stream: stream,
		Start:  start,
		Stop:   stop,
		Count:  count,
	}
	lockUniversalClientMockXRevRangeN.Lock()
	mock.calls.XRevRangeN = append(mock.calls.XRevRangeN, callInfo)
	lockUniversalClientMockXRevRangeN.Unlock()
	return mock.XRevRangeNFunc(stream, start, stop, count)
}

// XRevRangeNCalls gets all the calls that were made to XRevRangeN.
// Check the length with:
//     len(mockedUniversalClient.XRevRangeNCalls())
func (mock *UniversalClientMock) XRevRangeNCalls() []struct {
	Stream string
	Start  string
	Stop   string
	Count  int64
} {
	var calls []struct {
		Stream string
		Start  string
		Stop   string
		Count  int64
	}
	lockUniversalClientMockXRevRangeN.RLock()
	calls = mock.calls.XRevRangeN
	lockUniversalClientMockXRevRangeN.RUnlock()
	return calls
}

// XTrim calls XTrimFunc.
func (mock *UniversalClientMock) XTrim(key string, maxLen int64) *redis.IntCmd {
	if mock.XTrimFunc == nil {
		panic("UniversalClientMock.XTrimFunc: method is nil but UniversalClient.XTrim was just called")
	}
	callInfo := struct {
		Key    string
		MaxLen int64
	}{
		Key:    key,
		MaxLen: maxLen,
	}
	lockUniversalClientMockXTrim.Lock()
	mock.calls.XTrim = append(mock.calls.XTrim, callInfo)
	lockUniversalClientMockXTrim.Unlock()
	return mock.XTrimFunc(key, maxLen)
}

// XTrimCalls gets all the calls that were made to XTrim.
// Check the length with:
//     len(mockedUniversalClient.XTrimCalls())
func (mock *UniversalClientMock) XTrimCalls() []struct {
	Key    string
	MaxLen int64
} {
	var calls []struct {
		Key    string
		MaxLen int64
	}
	lockUniversalClientMockXTrim.RLock()
	calls = mock.calls.XTrim
	lockUniversalClientMockXTrim.RUnlock()
	return calls
}

// XTrimApprox calls XTrimApproxFunc.
func (mock *UniversalClientMock) XTrimApprox(key string, maxLen int64) *redis.IntCmd {
	if mock.XTrimApproxFunc == nil {
		panic("UniversalClientMock.XTrimApproxFunc: method is nil but UniversalClient.XTrimApprox was just called")
	}
	callInfo := struct {
		Key    string
		MaxLen int64
	}{
		Key:    key,
		MaxLen: maxLen,
	}
	lockUniversalClientMockXTrimApprox.Lock()
	mock.calls.XTrimApprox = append(mock.calls.XTrimApprox, callInfo)
	lockUniversalClientMockXTrimApprox.Unlock()
	return mock.XTrimApproxFunc(key, maxLen)
}

// XTrimApproxCalls gets all the calls that were made to XTrimApprox.
// Check the length with:
//     len(mockedUniversalClient.XTrimApproxCalls())
func (mock *UniversalClientMock) XTrimApproxCalls() []struct {
	Key    string
	MaxLen int64
} {
	var calls []struct {
		Key    string
		MaxLen int64
	}
	lockUniversalClientMockXTrimApprox.RLock()
	calls = mock.calls.XTrimApprox
	lockUniversalClientMockXTrimApprox.RUnlock()
	return calls
}

// ZAdd calls ZAddFunc.
func (mock *UniversalClientMock) ZAdd(key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddFunc == nil {
		panic("UniversalClientMock.ZAddFunc: method is nil but UniversalClient.ZAdd was just called")
	}
	callInfo := struct {
		Key     string
		Members []redis.Z
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockZAdd.Lock()
	mock.calls.ZAdd = append(mock.calls.ZAdd, callInfo)
	lockUniversalClientMockZAdd.Unlock()
	return mock.ZAddFunc(key, members...)
}

// ZAddCalls gets all the calls that were made to ZAdd.
// Check the length with:
//     len(mockedUniversalClient.ZAddCalls())
func (mock *UniversalClientMock) ZAddCalls() []struct {
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Key     string
		Members []redis.Z
	}
	lockUniversalClientMockZAdd.RLock()
	calls = mock.calls.ZAdd
	lockUniversalClientMockZAdd.RUnlock()
	return calls
}

// ZAddCh calls ZAddChFunc.
func (mock *UniversalClientMock) ZAddCh(key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddChFunc == nil {
		panic("UniversalClientMock.ZAddChFunc: method is nil but UniversalClient.ZAddCh was just called")
	}
	callInfo := struct {
		Key     string
		Members []redis.Z
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockZAddCh.Lock()
	mock.calls.ZAddCh = append(mock.calls.ZAddCh, callInfo)
	lockUniversalClientMockZAddCh.Unlock()
	return mock.ZAddChFunc(key, members...)
}

// ZAddChCalls gets all the calls that were made to ZAddCh.
// Check the length with:
//     len(mockedUniversalClient.ZAddChCalls())
func (mock *UniversalClientMock) ZAddChCalls() []struct {
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Key     string
		Members []redis.Z
	}
	lockUniversalClientMockZAddCh.RLock()
	calls = mock.calls.ZAddCh
	lockUniversalClientMockZAddCh.RUnlock()
	return calls
}

// ZAddNX calls ZAddNXFunc.
func (mock *UniversalClientMock) ZAddNX(key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddNXFunc == nil {
		panic("UniversalClientMock.ZAddNXFunc: method is nil but UniversalClient.ZAddNX was just called")
	}
	callInfo := struct {
		Key     string
		Members []redis.Z
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockZAddNX.Lock()
	mock.calls.ZAddNX = append(mock.calls.ZAddNX, callInfo)
	lockUniversalClientMockZAddNX.Unlock()
	return mock.ZAddNXFunc(key, members...)
}

// ZAddNXCalls gets all the calls that were made to ZAddNX.
// Check the length with:
//     len(mockedUniversalClient.ZAddNXCalls())
func (mock *UniversalClientMock) ZAddNXCalls() []struct {
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Key     string
		Members []redis.Z
	}
	lockUniversalClientMockZAddNX.RLock()
	calls = mock.calls.ZAddNX
	lockUniversalClientMockZAddNX.RUnlock()
	return calls
}

// ZAddNXCh calls ZAddNXChFunc.
func (mock *UniversalClientMock) ZAddNXCh(key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddNXChFunc == nil {
		panic("UniversalClientMock.ZAddNXChFunc: method is nil but UniversalClient.ZAddNXCh was just called")
	}
	callInfo := struct {
		Key     string
		Members []redis.Z
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockZAddNXCh.Lock()
	mock.calls.ZAddNXCh = append(mock.calls.ZAddNXCh, callInfo)
	lockUniversalClientMockZAddNXCh.Unlock()
	return mock.ZAddNXChFunc(key, members...)
}

// ZAddNXChCalls gets all the calls that were made to ZAddNXCh.
// Check the length with:
//     len(mockedUniversalClient.ZAddNXChCalls())
func (mock *UniversalClientMock) ZAddNXChCalls() []struct {
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Key     string
		Members []redis.Z
	}
	lockUniversalClientMockZAddNXCh.RLock()
	calls = mock.calls.ZAddNXCh
	lockUniversalClientMockZAddNXCh.RUnlock()
	return calls
}

// ZAddXX calls ZAddXXFunc.
func (mock *UniversalClientMock) ZAddXX(key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddXXFunc == nil {
		panic("UniversalClientMock.ZAddXXFunc: method is nil but UniversalClient.ZAddXX was just called")
	}
	callInfo := struct {
		Key     string
		Members []redis.Z
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockZAddXX.Lock()
	mock.calls.ZAddXX = append(mock.calls.ZAddXX, callInfo)
	lockUniversalClientMockZAddXX.Unlock()
	return mock.ZAddXXFunc(key, members...)
}

// ZAddXXCalls gets all the calls that were made to ZAddXX.
// Check the length with:
//     len(mockedUniversalClient.ZAddXXCalls())
func (mock *UniversalClientMock) ZAddXXCalls() []struct {
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Key     string
		Members []redis.Z
	}
	lockUniversalClientMockZAddXX.RLock()
	calls = mock.calls.ZAddXX
	lockUniversalClientMockZAddXX.RUnlock()
	return calls
}

// ZAddXXCh calls ZAddXXChFunc.
func (mock *UniversalClientMock) ZAddXXCh(key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddXXChFunc == nil {
		panic("UniversalClientMock.ZAddXXChFunc: method is nil but UniversalClient.ZAddXXCh was just called")
	}
	callInfo := struct {
		Key     string
		Members []redis.Z
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockZAddXXCh.Lock()
	mock.calls.ZAddXXCh = append(mock.calls.ZAddXXCh, callInfo)
	lockUniversalClientMockZAddXXCh.Unlock()
	return mock.ZAddXXChFunc(key, members...)
}

// ZAddXXChCalls gets all the calls that were made to ZAddXXCh.
// Check the length with:
//     len(mockedUniversalClient.ZAddXXChCalls())
func (mock *UniversalClientMock) ZAddXXChCalls() []struct {
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Key     string
		Members []redis.Z
	}
	lockUniversalClientMockZAddXXCh.RLock()
	calls = mock.calls.ZAddXXCh
	lockUniversalClientMockZAddXXCh.RUnlock()
	return calls
}

// ZCard calls ZCardFunc.
func (mock *UniversalClientMock) ZCard(key string) *redis.IntCmd {
	if mock.ZCardFunc == nil {
		panic("UniversalClientMock.ZCardFunc: method is nil but UniversalClient.ZCard was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockUniversalClientMockZCard.Lock()
	mock.calls.ZCard = append(mock.calls.ZCard, callInfo)
	lockUniversalClientMockZCard.Unlock()
	return mock.ZCardFunc(key)
}

// ZCardCalls gets all the calls that were made to ZCard.
// Check the length with:
//     len(mockedUniversalClient.ZCardCalls())
func (mock *UniversalClientMock) ZCardCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockUniversalClientMockZCard.RLock()
	calls = mock.calls.ZCard
	lockUniversalClientMockZCard.RUnlock()
	return calls
}

// ZCount calls ZCountFunc.
func (mock *UniversalClientMock) ZCount(key string, min string, max string) *redis.IntCmd {
	if mock.ZCountFunc == nil {
		panic("UniversalClientMock.ZCountFunc: method is nil but UniversalClient.ZCount was just called")
	}
	callInfo := struct {
		Key string
		Min string
		Max string
	}{
		Key: key,
		Min: min,
		Max: max,
	}
	lockUniversalClientMockZCount.Lock()
	mock.calls.ZCount = append(mock.calls.ZCount, callInfo)
	lockUniversalClientMockZCount.Unlock()
	return mock.ZCountFunc(key, min, max)
}

// ZCountCalls gets all the calls that were made to ZCount.
// Check the length with:
//     len(mockedUniversalClient.ZCountCalls())
func (mock *UniversalClientMock) ZCountCalls() []struct {
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Key string
		Min string
		Max string
	}
	lockUniversalClientMockZCount.RLock()
	calls = mock.calls.ZCount
	lockUniversalClientMockZCount.RUnlock()
	return calls
}

// ZIncr calls ZIncrFunc.
func (mock *UniversalClientMock) ZIncr(key string, member redis.Z) *redis.FloatCmd {
	if mock.ZIncrFunc == nil {
		panic("UniversalClientMock.ZIncrFunc: method is nil but UniversalClient.ZIncr was just called")
	}
	callInfo := struct {
		Key    string
		Member redis.Z
	}{
		Key:    key,
		Member: member,
	}
	lockUniversalClientMockZIncr.Lock()
	mock.calls.ZIncr = append(mock.calls.ZIncr, callInfo)
	lockUniversalClientMockZIncr.Unlock()
	return mock.ZIncrFunc(key, member)
}

// ZIncrCalls gets all the calls that were made to ZIncr.
// Check the length with:
//     len(mockedUniversalClient.ZIncrCalls())
func (mock *UniversalClientMock) ZIncrCalls() []struct {
	Key    string
	Member redis.Z
} {
	var calls []struct {
		Key    string
		Member redis.Z
	}
	lockUniversalClientMockZIncr.RLock()
	calls = mock.calls.ZIncr
	lockUniversalClientMockZIncr.RUnlock()
	return calls
}

// ZIncrBy calls ZIncrByFunc.
func (mock *UniversalClientMock) ZIncrBy(key string, increment float64, member string) *redis.FloatCmd {
	if mock.ZIncrByFunc == nil {
		panic("UniversalClientMock.ZIncrByFunc: method is nil but UniversalClient.ZIncrBy was just called")
	}
	callInfo := struct {
		Key       string
		Increment float64
		Member    string
	}{
		Key:       key,
		Increment: increment,
		Member:    member,
	}
	lockUniversalClientMockZIncrBy.Lock()
	mock.calls.ZIncrBy = append(mock.calls.ZIncrBy, callInfo)
	lockUniversalClientMockZIncrBy.Unlock()
	return mock.ZIncrByFunc(key, increment, member)
}

// ZIncrByCalls gets all the calls that were made to ZIncrBy.
// Check the length with:
//     len(mockedUniversalClient.ZIncrByCalls())
func (mock *UniversalClientMock) ZIncrByCalls() []struct {
	Key       string
	Increment float64
	Member    string
} {
	var calls []struct {
		Key       string
		Increment float64
		Member    string
	}
	lockUniversalClientMockZIncrBy.RLock()
	calls = mock.calls.ZIncrBy
	lockUniversalClientMockZIncrBy.RUnlock()
	return calls
}

// ZIncrNX calls ZIncrNXFunc.
func (mock *UniversalClientMock) ZIncrNX(key string, member redis.Z) *redis.FloatCmd {
	if mock.ZIncrNXFunc == nil {
		panic("UniversalClientMock.ZIncrNXFunc: method is nil but UniversalClient.ZIncrNX was just called")
	}
	callInfo := struct {
		Key    string
		Member redis.Z
	}{
		Key:    key,
		Member: member,
	}
	lockUniversalClientMockZIncrNX.Lock()
	mock.calls.ZIncrNX = append(mock.calls.ZIncrNX, callInfo)
	lockUniversalClientMockZIncrNX.Unlock()
	return mock.ZIncrNXFunc(key, member)
}

// ZIncrNXCalls gets all the calls that were made to ZIncrNX.
// Check the length with:
//     len(mockedUniversalClient.ZIncrNXCalls())
func (mock *UniversalClientMock) ZIncrNXCalls() []struct {
	Key    string
	Member redis.Z
} {
	var calls []struct {
		Key    string
		Member redis.Z
	}
	lockUniversalClientMockZIncrNX.RLock()
	calls = mock.calls.ZIncrNX
	lockUniversalClientMockZIncrNX.RUnlock()
	return calls
}

// ZIncrXX calls ZIncrXXFunc.
func (mock *UniversalClientMock) ZIncrXX(key string, member redis.Z) *redis.FloatCmd {
	if mock.ZIncrXXFunc == nil {
		panic("UniversalClientMock.ZIncrXXFunc: method is nil but UniversalClient.ZIncrXX was just called")
	}
	callInfo := struct {
		Key    string
		Member redis.Z
	}{
		Key:    key,
		Member: member,
	}
	lockUniversalClientMockZIncrXX.Lock()
	mock.calls.ZIncrXX = append(mock.calls.ZIncrXX, callInfo)
	lockUniversalClientMockZIncrXX.Unlock()
	return mock.ZIncrXXFunc(key, member)
}

// ZIncrXXCalls gets all the calls that were made to ZIncrXX.
// Check the length with:
//     len(mockedUniversalClient.ZIncrXXCalls())
func (mock *UniversalClientMock) ZIncrXXCalls() []struct {
	Key    string
	Member redis.Z
} {
	var calls []struct {
		Key    string
		Member redis.Z
	}
	lockUniversalClientMockZIncrXX.RLock()
	calls = mock.calls.ZIncrXX
	lockUniversalClientMockZIncrXX.RUnlock()
	return calls
}

// ZInterStore calls ZInterStoreFunc.
func (mock *UniversalClientMock) ZInterStore(destination string, store redis.ZStore, keys ...string) *redis.IntCmd {
	if mock.ZInterStoreFunc == nil {
		panic("UniversalClientMock.ZInterStoreFunc: method is nil but UniversalClient.ZInterStore was just called")
	}
	callInfo := struct {
		Destination string
		Store       redis.ZStore
		Keys        []string
	}{
		Destination: destination,
		Store:       store,
		Keys:        keys,
	}
	lockUniversalClientMockZInterStore.Lock()
	mock.calls.ZInterStore = append(mock.calls.ZInterStore, callInfo)
	lockUniversalClientMockZInterStore.Unlock()
	return mock.ZInterStoreFunc(destination, store, keys...)
}

// ZInterStoreCalls gets all the calls that were made to ZInterStore.
// Check the length with:
//     len(mockedUniversalClient.ZInterStoreCalls())
func (mock *UniversalClientMock) ZInterStoreCalls() []struct {
	Destination string
	Store       redis.ZStore
	Keys        []string
} {
	var calls []struct {
		Destination string
		Store       redis.ZStore
		Keys        []string
	}
	lockUniversalClientMockZInterStore.RLock()
	calls = mock.calls.ZInterStore
	lockUniversalClientMockZInterStore.RUnlock()
	return calls
}

// ZLexCount calls ZLexCountFunc.
func (mock *UniversalClientMock) ZLexCount(key string, min string, max string) *redis.IntCmd {
	if mock.ZLexCountFunc == nil {
		panic("UniversalClientMock.ZLexCountFunc: method is nil but UniversalClient.ZLexCount was just called")
	}
	callInfo := struct {
		Key string
		Min string
		Max string
	}{
		Key: key,
		Min: min,
		Max: max,
	}
	lockUniversalClientMockZLexCount.Lock()
	mock.calls.ZLexCount = append(mock.calls.ZLexCount, callInfo)
	lockUniversalClientMockZLexCount.Unlock()
	return mock.ZLexCountFunc(key, min, max)
}

// ZLexCountCalls gets all the calls that were made to ZLexCount.
// Check the length with:
//     len(mockedUniversalClient.ZLexCountCalls())
func (mock *UniversalClientMock) ZLexCountCalls() []struct {
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Key string
		Min string
		Max string
	}
	lockUniversalClientMockZLexCount.RLock()
	calls = mock.calls.ZLexCount
	lockUniversalClientMockZLexCount.RUnlock()
	return calls
}

// ZPopMax calls ZPopMaxFunc.
func (mock *UniversalClientMock) ZPopMax(key string, count ...int64) *redis.ZSliceCmd {
	if mock.ZPopMaxFunc == nil {
		panic("UniversalClientMock.ZPopMaxFunc: method is nil but UniversalClient.ZPopMax was just called")
	}
	callInfo := struct {
		Key   string
		Count []int64
	}{
		Key:   key,
		Count: count,
	}
	lockUniversalClientMockZPopMax.Lock()
	mock.calls.ZPopMax = append(mock.calls.ZPopMax, callInfo)
	lockUniversalClientMockZPopMax.Unlock()
	return mock.ZPopMaxFunc(key, count...)
}

// ZPopMaxCalls gets all the calls that were made to ZPopMax.
// Check the length with:
//     len(mockedUniversalClient.ZPopMaxCalls())
func (mock *UniversalClientMock) ZPopMaxCalls() []struct {
	Key   string
	Count []int64
} {
	var calls []struct {
		Key   string
		Count []int64
	}
	lockUniversalClientMockZPopMax.RLock()
	calls = mock.calls.ZPopMax
	lockUniversalClientMockZPopMax.RUnlock()
	return calls
}

// ZPopMin calls ZPopMinFunc.
func (mock *UniversalClientMock) ZPopMin(key string, count ...int64) *redis.ZSliceCmd {
	if mock.ZPopMinFunc == nil {
		panic("UniversalClientMock.ZPopMinFunc: method is nil but UniversalClient.ZPopMin was just called")
	}
	callInfo := struct {
		Key   string
		Count []int64
	}{
		Key:   key,
		Count: count,
	}
	lockUniversalClientMockZPopMin.Lock()
	mock.calls.ZPopMin = append(mock.calls.ZPopMin, callInfo)
	lockUniversalClientMockZPopMin.Unlock()
	return mock.ZPopMinFunc(key, count...)
}

// ZPopMinCalls gets all the calls that were made to ZPopMin.
// Check the length with:
//     len(mockedUniversalClient.ZPopMinCalls())
func (mock *UniversalClientMock) ZPopMinCalls() []struct {
	Key   string
	Count []int64
} {
	var calls []struct {
		Key   string
		Count []int64
	}
	lockUniversalClientMockZPopMin.RLock()
	calls = mock.calls.ZPopMin
	lockUniversalClientMockZPopMin.RUnlock()
	return calls
}

// ZRange calls ZRangeFunc.
func (mock *UniversalClientMock) ZRange(key string, start int64, stop int64) *redis.StringSliceCmd {
	if mock.ZRangeFunc == nil {
		panic("UniversalClientMock.ZRangeFunc: method is nil but UniversalClient.ZRange was just called")
	}
	callInfo := struct {
		Key   string
		Start int64
		Stop  int64
	}{
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	lockUniversalClientMockZRange.Lock()
	mock.calls.ZRange = append(mock.calls.ZRange, callInfo)
	lockUniversalClientMockZRange.Unlock()
	return mock.ZRangeFunc(key, start, stop)
}

// ZRangeCalls gets all the calls that were made to ZRange.
// Check the length with:
//     len(mockedUniversalClient.ZRangeCalls())
func (mock *UniversalClientMock) ZRangeCalls() []struct {
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Key   string
		Start int64
		Stop  int64
	}
	lockUniversalClientMockZRange.RLock()
	calls = mock.calls.ZRange
	lockUniversalClientMockZRange.RUnlock()
	return calls
}

// ZRangeByLex calls ZRangeByLexFunc.
func (mock *UniversalClientMock) ZRangeByLex(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRangeByLexFunc == nil {
		panic("UniversalClientMock.ZRangeByLexFunc: method is nil but UniversalClient.ZRangeByLex was just called")
	}
	callInfo := struct {
		Key string
		Opt redis.ZRangeBy
	}{
		Key: key,
		Opt: opt,
	}
	lockUniversalClientMockZRangeByLex.Lock()
	mock.calls.ZRangeByLex = append(mock.calls.ZRangeByLex, callInfo)
	lockUniversalClientMockZRangeByLex.Unlock()
	return mock.ZRangeByLexFunc(key, opt)
}

// ZRangeByLexCalls gets all the calls that were made to ZRangeByLex.
// Check the length with:
//     len(mockedUniversalClient.ZRangeByLexCalls())
func (mock *UniversalClientMock) ZRangeByLexCalls() []struct {
	Key string
	Opt redis.ZRangeBy
} {
	var calls []struct {
		Key string
		Opt redis.ZRangeBy
	}
	lockUniversalClientMockZRangeByLex.RLock()
	calls = mock.calls.ZRangeByLex
	lockUniversalClientMockZRangeByLex.RUnlock()
	return calls
}

// ZRangeByScore calls ZRangeByScoreFunc.
func (mock *UniversalClientMock) ZRangeByScore(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRangeByScoreFunc == nil {
		panic("UniversalClientMock.ZRangeByScoreFunc: method is nil but UniversalClient.ZRangeByScore was just called")
	}
	callInfo := struct {
		Key string
		Opt redis.ZRangeBy
	}{
		Key: key,
		Opt: opt,
	}
	lockUniversalClientMockZRangeByScore.Lock()
	mock.calls.ZRangeByScore = append(mock.calls.ZRangeByScore, callInfo)
	lockUniversalClientMockZRangeByScore.Unlock()
	return mock.ZRangeByScoreFunc(key, opt)
}

// ZRangeByScoreCalls gets all the calls that were made to ZRangeByScore.
// Check the length with:
//     len(mockedUniversalClient.ZRangeByScoreCalls())
func (mock *UniversalClientMock) ZRangeByScoreCalls() []struct {
	Key string
	Opt redis.ZRangeBy
} {
	var calls []struct {
		Key string
		Opt redis.ZRangeBy
	}
	lockUniversalClientMockZRangeByScore.RLock()
	calls = mock.calls.ZRangeByScore
	lockUniversalClientMockZRangeByScore.RUnlock()
	return calls
}

// ZRangeByScoreWithScores calls ZRangeByScoreWithScoresFunc.
func (mock *UniversalClientMock) ZRangeByScoreWithScores(key string, opt redis.ZRangeBy) *redis.ZSliceCmd {
	if mock.ZRangeByScoreWithScoresFunc == nil {
		panic("UniversalClientMock.ZRangeByScoreWithScoresFunc: method is nil but UniversalClient.ZRangeByScoreWithScores was just called")
	}
	callInfo := struct {
		Key string
		Opt redis.ZRangeBy
	}{
		Key: key,
		Opt: opt,
	}
	lockUniversalClientMockZRangeByScoreWithScores.Lock()
	mock.calls.ZRangeByScoreWithScores = append(mock.calls.ZRangeByScoreWithScores, callInfo)
	lockUniversalClientMockZRangeByScoreWithScores.Unlock()
	return mock.ZRangeByScoreWithScoresFunc(key, opt)
}

// ZRangeByScoreWithScoresCalls gets all the calls that were made to ZRangeByScoreWithScores.
// Check the length with:
//     len(mockedUniversalClient.ZRangeByScoreWithScoresCalls())
func (mock *UniversalClientMock) ZRangeByScoreWithScoresCalls() []struct {
	Key string
	Opt redis.ZRangeBy
} {
	var calls []struct {
		Key string
		Opt redis.ZRangeBy
	}
	lockUniversalClientMockZRangeByScoreWithScores.RLock()
	calls = mock.calls.ZRangeByScoreWithScores
	lockUniversalClientMockZRangeByScoreWithScores.RUnlock()
	return calls
}

// ZRangeWithScores calls ZRangeWithScoresFunc.
func (mock *UniversalClientMock) ZRangeWithScores(key string, start int64, stop int64) *redis.ZSliceCmd {
	if mock.ZRangeWithScoresFunc == nil {
		panic("UniversalClientMock.ZRangeWithScoresFunc: method is nil but UniversalClient.ZRangeWithScores was just called")
	}
	callInfo := struct {
		Key   string
		Start int64
		Stop  int64
	}{
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	lockUniversalClientMockZRangeWithScores.Lock()
	mock.calls.ZRangeWithScores = append(mock.calls.ZRangeWithScores, callInfo)
	lockUniversalClientMockZRangeWithScores.Unlock()
	return mock.ZRangeWithScoresFunc(key, start, stop)
}

// ZRangeWithScoresCalls gets all the calls that were made to ZRangeWithScores.
// Check the length with:
//     len(mockedUniversalClient.ZRangeWithScoresCalls())
func (mock *UniversalClientMock) ZRangeWithScoresCalls() []struct {
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Key   string
		Start int64
		Stop  int64
	}
	lockUniversalClientMockZRangeWithScores.RLock()
	calls = mock.calls.ZRangeWithScores
	lockUniversalClientMockZRangeWithScores.RUnlock()
	return calls
}

// ZRank calls ZRankFunc.
func (mock *UniversalClientMock) ZRank(key string, member string) *redis.IntCmd {
	if mock.ZRankFunc == nil {
		panic("UniversalClientMock.ZRankFunc: method is nil but UniversalClient.ZRank was just called")
	}
	callInfo := struct {
		Key    string
		Member string
	}{
		Key:    key,
		Member: member,
	}
	lockUniversalClientMockZRank.Lock()
	mock.calls.ZRank = append(mock.calls.ZRank, callInfo)
	lockUniversalClientMockZRank.Unlock()
	return mock.ZRankFunc(key, member)
}

// ZRankCalls gets all the calls that were made to ZRank.
// Check the length with:
//     len(mockedUniversalClient.ZRankCalls())
func (mock *UniversalClientMock) ZRankCalls() []struct {
	Key    string
	Member string
} {
	var calls []struct {
		Key    string
		Member string
	}
	lockUniversalClientMockZRank.RLock()
	calls = mock.calls.ZRank
	lockUniversalClientMockZRank.RUnlock()
	return calls
}

// ZRem calls ZRemFunc.
func (mock *UniversalClientMock) ZRem(key string, members ...interface{}) *redis.IntCmd {
	if mock.ZRemFunc == nil {
		panic("UniversalClientMock.ZRemFunc: method is nil but UniversalClient.ZRem was just called")
	}
	callInfo := struct {
		Key     string
		Members []interface{}
	}{
		Key:     key,
		Members: members,
	}
	lockUniversalClientMockZRem.Lock()
	mock.calls.ZRem = append(mock.calls.ZRem, callInfo)
	lockUniversalClientMockZRem.Unlock()
	return mock.ZRemFunc(key, members...)
}

// ZRemCalls gets all the calls that were made to ZRem.
// Check the length with:
//     len(mockedUniversalClient.ZRemCalls())
func (mock *UniversalClientMock) ZRemCalls() []struct {
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Key     string
		Members []interface{}
	}
	lockUniversalClientMockZRem.RLock()
	calls = mock.calls.ZRem
	lockUniversalClientMockZRem.RUnlock()
	return calls
}

// ZRemRangeByLex calls ZRemRangeByLexFunc.
func (mock *UniversalClientMock) ZRemRangeByLex(key string, min string, max string) *redis.IntCmd {
	if mock.ZRemRangeByLexFunc == nil {
		panic("UniversalClientMock.ZRemRangeByLexFunc: method is nil but UniversalClient.ZRemRangeByLex was just called")
	}
	callInfo := struct {
		Key string
		Min string
		Max string
	}{
		Key: key,
		Min: min,
		Max: max,
	}
	lockUniversalClientMockZRemRangeByLex.Lock()
	mock.calls.ZRemRangeByLex = append(mock.calls.ZRemRangeByLex, callInfo)
	lockUniversalClientMockZRemRangeByLex.Unlock()
	return mock.ZRemRangeByLexFunc(key, min, max)
}

// ZRemRangeByLexCalls gets all the calls that were made to ZRemRangeByLex.
// Check the length with:
//     len(mockedUniversalClient.ZRemRangeByLexCalls())
func (mock *UniversalClientMock) ZRemRangeByLexCalls() []struct {
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Key string
		Min string
		Max string
	}
	lockUniversalClientMockZRemRangeByLex.RLock()
	calls = mock.calls.ZRemRangeByLex
	lockUniversalClientMockZRemRangeByLex.RUnlock()
	return calls
}

// ZRemRangeByRank calls ZRemRangeByRankFunc.
func (mock *UniversalClientMock) ZRemRangeByRank(key string, start int64, stop int64) *redis.IntCmd {
	if mock.ZRemRangeByRankFunc == nil {
		panic("UniversalClientMock.ZRemRangeByRankFunc: method is nil but UniversalClient.ZRemRangeByRank was just called")
	}
	callInfo := struct {
		Key   string
		Start int64
		Stop  int64
	}{
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	lockUniversalClientMockZRemRangeByRank.Lock()
	mock.calls.ZRemRangeByRank = append(mock.calls.ZRemRangeByRank, callInfo)
	lockUniversalClientMockZRemRangeByRank.Unlock()
	return mock.ZRemRangeByRankFunc(key, start, stop)
}

// ZRemRangeByRankCalls gets all the calls that were made to ZRemRangeByRank.
// Check the length with:
//     len(mockedUniversalClient.ZRemRangeByRankCalls())
func (mock *UniversalClientMock) ZRemRangeByRankCalls() []struct {
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Key   string
		Start int64
		Stop  int64
	}
	lockUniversalClientMockZRemRangeByRank.RLock()
	calls = mock.calls.ZRemRangeByRank
	lockUniversalClientMockZRemRangeByRank.RUnlock()
	return calls
}

// ZRemRangeByScore calls ZRemRangeByScoreFunc.
func (mock *UniversalClientMock) ZRemRangeByScore(key string, min string, max string) *redis.IntCmd {
	if mock.ZRemRangeByScoreFunc == nil {
		panic("UniversalClientMock.ZRemRangeByScoreFunc: method is nil but UniversalClient.ZRemRangeByScore was just called")
	}
	callInfo := struct {
		Key string
		Min string
		Max string
	}{
		Key: key,
		Min: min,
		Max: max,
	}
	lockUniversalClientMockZRemRangeByScore.Lock()
	mock.calls.ZRemRangeByScore = append(mock.calls.ZRemRangeByScore, callInfo)
	lockUniversalClientMockZRemRangeByScore.Unlock()
	return mock.ZRemRangeByScoreFunc(key, min, max)
}

// ZRemRangeByScoreCalls gets all the calls that were made to ZRemRangeByScore.
// Check the length with:
//     len(mockedUniversalClient.ZRemRangeByScoreCalls())
func (mock *UniversalClientMock) ZRemRangeByScoreCalls() []struct {
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Key string
		Min string
		Max string
	}
	lockUniversalClientMockZRemRangeByScore.RLock()
	calls = mock.calls.ZRemRangeByScore
	lockUniversalClientMockZRemRangeByScore.RUnlock()
	return calls
}

// ZRevRange calls ZRevRangeFunc.
func (mock *UniversalClientMock) ZRevRange(key string, start int64, stop int64) *redis.StringSliceCmd {
	if mock.ZRevRangeFunc == nil {
		panic("UniversalClientMock.ZRevRangeFunc: method is nil but UniversalClient.ZRevRange was just called")
	}
	callInfo := struct {
		Key   string
		Start int64
		Stop  int64
	}{
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	lockUniversalClientMockZRevRange.Lock()
	mock.calls.ZRevRange = append(mock.calls.ZRevRange, callInfo)
	lockUniversalClientMockZRevRange.Unlock()
	return mock.ZRevRangeFunc(key, start, stop)
}

// ZRevRangeCalls gets all the calls that were made to ZRevRange.
// Check the length with:
//     len(mockedUniversalClient.ZRevRangeCalls())
func (mock *UniversalClientMock) ZRevRangeCalls() []struct {
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Key   string
		Start int64
		Stop  int64
	}
	lockUniversalClientMockZRevRange.RLock()
	calls = mock.calls.ZRevRange
	lockUniversalClientMockZRevRange.RUnlock()
	return calls
}

// ZRevRangeByLex calls ZRevRangeByLexFunc.
func (mock *UniversalClientMock) ZRevRangeByLex(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRevRangeByLexFunc == nil {
		panic("UniversalClientMock.ZRevRangeByLexFunc: method is nil but UniversalClient.ZRevRangeByLex was just called")
	}
	callInfo := struct {
		Key string
		Opt redis.ZRangeBy
	}{
		Key: key,
		Opt: opt,
	}
	lockUniversalClientMockZRevRangeByLex.Lock()
	mock.calls.ZRevRangeByLex = append(mock.calls.ZRevRangeByLex, callInfo)
	lockUniversalClientMockZRevRangeByLex.Unlock()
	return mock.ZRevRangeByLexFunc(key, opt)
}

// ZRevRangeByLexCalls gets all the calls that were made to ZRevRangeByLex.
// Check the length with:
//     len(mockedUniversalClient.ZRevRangeByLexCalls())
func (mock *UniversalClientMock) ZRevRangeByLexCalls() []struct {
	Key string
	Opt redis.ZRangeBy
} {
	var calls []struct {
		Key string
		Opt redis.ZRangeBy
	}
	lockUniversalClientMockZRevRangeByLex.RLock()
	calls = mock.calls.ZRevRangeByLex
	lockUniversalClientMockZRevRangeByLex.RUnlock()
	return calls
}

// ZRevRangeByScore calls ZRevRangeByScoreFunc.
func (mock *UniversalClientMock) ZRevRangeByScore(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRevRangeByScoreFunc == nil {
		panic("UniversalClientMock.ZRevRangeByScoreFunc: method is nil but UniversalClient.ZRevRangeByScore was just called")
	}
	callInfo := struct {
		Key string
		Opt redis.ZRangeBy
	}{
		Key: key,
		Opt: opt,
	}
	lockUniversalClientMockZRevRangeByScore.Lock()
	mock.calls.ZRevRangeByScore = append(mock.calls.ZRevRangeByScore, callInfo)
	lockUniversalClientMockZRevRangeByScore.Unlock()
	return mock.ZRevRangeByScoreFunc(key, opt)
}

// ZRevRangeByScoreCalls gets all the calls that were made to ZRevRangeByScore.
// Check the length with:
//     len(mockedUniversalClient.ZRevRangeByScoreCalls())
func (mock *UniversalClientMock) ZRevRangeByScoreCalls() []struct {
	Key string
	Opt redis.ZRangeBy
} {
	var calls []struct {
		Key string
		Opt redis.ZRangeBy
	}
	lockUniversalClientMockZRevRangeByScore.RLock()
	calls = mock.calls.ZRevRangeByScore
	lockUniversalClientMockZRevRangeByScore.RUnlock()
	return calls
}

// ZRevRangeByScoreWithScores calls ZRevRangeByScoreWithScoresFunc.
func (mock *UniversalClientMock) ZRevRangeByScoreWithScores(key string, opt redis.ZRangeBy) *redis.ZSliceCmd {
	if mock.ZRevRangeByScoreWithScoresFunc == nil {
		panic("UniversalClientMock.ZRevRangeByScoreWithScoresFunc: method is nil but UniversalClient.ZRevRangeByScoreWithScores was just called")
	}
	callInfo := struct {
		Key string
		Opt redis.ZRangeBy
	}{
		Key: key,
		Opt: opt,
	}
	lockUniversalClientMockZRevRangeByScoreWithScores.Lock()
	mock.calls.ZRevRangeByScoreWithScores = append(mock.calls.ZRevRangeByScoreWithScores, callInfo)
	lockUniversalClientMockZRevRangeByScoreWithScores.Unlock()
	return mock.ZRevRangeByScoreWithScoresFunc(key, opt)
}

// ZRevRangeByScoreWithScoresCalls gets all the calls that were made to ZRevRangeByScoreWithScores.
// Check the length with:
//     len(mockedUniversalClient.ZRevRangeByScoreWithScoresCalls())
func (mock *UniversalClientMock) ZRevRangeByScoreWithScoresCalls() []struct {
	Key string
	Opt redis.ZRangeBy
} {
	var calls []struct {
		Key string
		Opt redis.ZRangeBy
	}
	lockUniversalClientMockZRevRangeByScoreWithScores.RLock()
	calls = mock.calls.ZRevRangeByScoreWithScores
	lockUniversalClientMockZRevRangeByScoreWithScores.RUnlock()
	return calls
}

// ZRevRangeWithScores calls ZRevRangeWithScoresFunc.
func (mock *UniversalClientMock) ZRevRangeWithScores(key string, start int64, stop int64) *redis.ZSliceCmd {
	if mock.ZRevRangeWithScoresFunc == nil {
		panic("UniversalClientMock.ZRevRangeWithScoresFunc: method is nil but UniversalClient.ZRevRangeWithScores was just called")
	}
	callInfo := struct {
		Key   string
		Start int64
		Stop  int64
	}{
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	lockUniversalClientMockZRevRangeWithScores.Lock()
	mock.calls.ZRevRangeWithScores = append(mock.calls.ZRevRangeWithScores, callInfo)
	lockUniversalClientMockZRevRangeWithScores.Unlock()
	return mock.ZRevRangeWithScoresFunc(key, start, stop)
}

// ZRevRangeWithScoresCalls gets all the calls that were made to ZRevRangeWithScores.
// Check the length with:
//     len(mockedUniversalClient.ZRevRangeWithScoresCalls())
func (mock *UniversalClientMock) ZRevRangeWithScoresCalls() []struct {
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Key   string
		Start int64
		Stop  int64
	}
	lockUniversalClientMockZRevRangeWithScores.RLock()
	calls = mock.calls.ZRevRangeWithScores
	lockUniversalClientMockZRevRangeWithScores.RUnlock()
	return calls
}

// ZRevRank calls ZRevRankFunc.
func (mock *UniversalClientMock) ZRevRank(key string, member string) *redis.IntCmd {
	if mock.ZRevRankFunc == nil {
		panic("UniversalClientMock.ZRevRankFunc: method is nil but UniversalClient.ZRevRank was just called")
	}
	callInfo := struct {
		Key    string
		Member string
	}{
		Key:    key,
		Member: member,
	}
	lockUniversalClientMockZRevRank.Lock()
	mock.calls.ZRevRank = append(mock.calls.ZRevRank, callInfo)
	lockUniversalClientMockZRevRank.Unlock()
	return mock.ZRevRankFunc(key, member)
}

// ZRevRankCalls gets all the calls that were made to ZRevRank.
// Check the length with:
//     len(mockedUniversalClient.ZRevRankCalls())
func (mock *UniversalClientMock) ZRevRankCalls() []struct {
	Key    string
	Member string
} {
	var calls []struct {
		Key    string
		Member string
	}
	lockUniversalClientMockZRevRank.RLock()
	calls = mock.calls.ZRevRank
	lockUniversalClientMockZRevRank.RUnlock()
	return calls
}

// ZScan calls ZScanFunc.
func (mock *UniversalClientMock) ZScan(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.ZScanFunc == nil {
		panic("UniversalClientMock.ZScanFunc: method is nil but UniversalClient.ZScan was just called")
	}
	callInfo := struct {
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	lockUniversalClientMockZScan.Lock()
	mock.calls.ZScan = append(mock.calls.ZScan, callInfo)
	lockUniversalClientMockZScan.Unlock()
	return mock.ZScanFunc(key, cursor, match, count)
}

// ZScanCalls gets all the calls that were made to ZScan.
// Check the length with:
//     len(mockedUniversalClient.ZScanCalls())
func (mock *UniversalClientMock) ZScanCalls() []struct {
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	lockUniversalClientMockZScan.RLock()
	calls = mock.calls.ZScan
	lockUniversalClientMockZScan.RUnlock()
	return calls
}

// ZScore calls ZScoreFunc.
func (mock *UniversalClientMock) ZScore(key string, member string) *redis.FloatCmd {
	if mock.ZScoreFunc == nil {
		panic("UniversalClientMock.ZScoreFunc: method is nil but UniversalClient.ZScore was just called")
	}
	callInfo := struct {
		Key    string
		Member string
	}{
		Key:    key,
		Member: member,
	}
	lockUniversalClientMockZScore.Lock()
	mock.calls.ZScore = append(mock.calls.ZScore, callInfo)
	lockUniversalClientMockZScore.Unlock()
	return mock.ZScoreFunc(key, member)
}

// ZScoreCalls gets all the calls that were made to ZScore.
// Check the length with:
//     len(mockedUniversalClient.ZScoreCalls())
func (mock *UniversalClientMock) ZScoreCalls() []struct {
	Key    string
	Member string
} {
	var calls []struct {
		Key    string
		Member string
	}
	lockUniversalClientMockZScore.RLock()
	calls = mock.calls.ZScore
	lockUniversalClientMockZScore.RUnlock()
	return calls
}

// ZUnionStore calls ZUnionStoreFunc.
func (mock *UniversalClientMock) ZUnionStore(dest string, store redis.ZStore, keys ...string) *redis.IntCmd {
	if mock.ZUnionStoreFunc == nil {
		panic("UniversalClientMock.ZUnionStoreFunc: method is nil but UniversalClient.ZUnionStore was just called")
	}
	callInfo := struct {
		Dest  string
		Store redis.ZStore
		Keys  []string
	}{
		Dest:  dest,
		Store: store,
		Keys:  keys,
	}
	lockUniversalClientMockZUnionStore.Lock()
	mock.calls.ZUnionStore = append(mock.calls.ZUnionStore, callInfo)
	lockUniversalClientMockZUnionStore.Unlock()
	return mock.ZUnionStoreFunc(dest, store, keys...)
}

// ZUnionStoreCalls gets all the calls that were made to ZUnionStore.
// Check the length with:
//     len(mockedUniversalClient.ZUnionStoreCalls())
func (mock *UniversalClientMock) ZUnionStoreCalls() []struct {
	Dest  string
	Store redis.ZStore
	Keys  []string
} {
	var calls []struct {
		Dest  string
		Store redis.ZStore
		Keys  []string
	}
	lockUniversalClientMockZUnionStore.RLock()
	calls = mock.calls.ZUnionStore
	lockUniversalClientMockZUnionStore.RUnlock()
	return calls
}
